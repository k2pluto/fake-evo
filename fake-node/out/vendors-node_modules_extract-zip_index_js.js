exports.id = "vendors-node_modules_extract-zip_index_js";
exports.ids = ["vendors-node_modules_extract-zip_index_js"];
exports.modules = {

/***/ "./node_modules/extract-zip/index.js":
/*!*******************************************!*\
  !*** ./node_modules/extract-zip/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/index.js")('extract-zip')
// eslint-disable-next-line node/no-unsupported-features/node-builtins
const { createWriteStream, promises: fs } = __webpack_require__(/*! fs */ "fs")
const getStream = __webpack_require__(/*! get-stream */ "./node_modules/extract-zip/node_modules/get-stream/index.js")
const path = __webpack_require__(/*! path */ "path")
const { promisify } = __webpack_require__(/*! util */ "util")
const stream = __webpack_require__(/*! stream */ "stream")
const yauzl = __webpack_require__(/*! yauzl */ "./node_modules/yauzl/index.js")

const openZip = promisify(yauzl.open)
const pipeline = promisify(stream.pipeline)

class Extractor {
  constructor (zipPath, opts) {
    this.zipPath = zipPath
    this.opts = opts
  }

  async extract () {
    debug('opening', this.zipPath, 'with opts', this.opts)

    this.zipfile = await openZip(this.zipPath, { lazyEntries: true })
    this.canceled = false

    return new Promise((resolve, reject) => {
      this.zipfile.on('error', err => {
        this.canceled = true
        reject(err)
      })
      this.zipfile.readEntry()

      this.zipfile.on('close', () => {
        if (!this.canceled) {
          debug('zip extraction complete')
          resolve()
        }
      })

      this.zipfile.on('entry', async entry => {
        /* istanbul ignore if */
        if (this.canceled) {
          debug('skipping entry', entry.fileName, { cancelled: this.canceled })
          return
        }

        debug('zipfile entry', entry.fileName)

        if (entry.fileName.startsWith('__MACOSX/')) {
          this.zipfile.readEntry()
          return
        }

        const destDir = path.dirname(path.join(this.opts.dir, entry.fileName))

        try {
          await fs.mkdir(destDir, { recursive: true })

          const canonicalDestDir = await fs.realpath(destDir)
          const relativeDestDir = path.relative(this.opts.dir, canonicalDestDir)

          if (relativeDestDir.split(path.sep).includes('..')) {
            throw new Error(`Out of bound path "${canonicalDestDir}" found while processing file ${entry.fileName}`)
          }

          await this.extractEntry(entry)
          debug('finished processing', entry.fileName)
          this.zipfile.readEntry()
        } catch (err) {
          this.canceled = true
          this.zipfile.close()
          reject(err)
        }
      })
    })
  }

  async extractEntry (entry) {
    /* istanbul ignore if */
    if (this.canceled) {
      debug('skipping entry extraction', entry.fileName, { cancelled: this.canceled })
      return
    }

    if (this.opts.onEntry) {
      this.opts.onEntry(entry, this.zipfile)
    }

    const dest = path.join(this.opts.dir, entry.fileName)

    // convert external file attr int into a fs stat mode int
    const mode = (entry.externalFileAttributes >> 16) & 0xFFFF
    // check if it's a symlink or dir (using stat mode constants)
    const IFMT = 61440
    const IFDIR = 16384
    const IFLNK = 40960
    const symlink = (mode & IFMT) === IFLNK
    let isDir = (mode & IFMT) === IFDIR

    // Failsafe, borrowed from jsZip
    if (!isDir && entry.fileName.endsWith('/')) {
      isDir = true
    }

    // check for windows weird way of specifying a directory
    // https://github.com/maxogden/extract-zip/issues/13#issuecomment-154494566
    const madeBy = entry.versionMadeBy >> 8
    if (!isDir) isDir = (madeBy === 0 && entry.externalFileAttributes === 16)

    debug('extracting entry', { filename: entry.fileName, isDir: isDir, isSymlink: symlink })

    const procMode = this.getExtractedMode(mode, isDir) & 0o777

    // always ensure folders are created
    const destDir = isDir ? dest : path.dirname(dest)

    const mkdirOptions = { recursive: true }
    if (isDir) {
      mkdirOptions.mode = procMode
    }
    debug('mkdir', { dir: destDir, ...mkdirOptions })
    await fs.mkdir(destDir, mkdirOptions)
    if (isDir) return

    debug('opening read stream', dest)
    const readStream = await promisify(this.zipfile.openReadStream.bind(this.zipfile))(entry)

    if (symlink) {
      const link = await getStream(readStream)
      debug('creating symlink', link, dest)
      await fs.symlink(link, dest)
    } else {
      await pipeline(readStream, createWriteStream(dest, { mode: procMode }))
    }
  }

  getExtractedMode (entryMode, isDir) {
    let mode = entryMode
    // Set defaults, if necessary
    if (mode === 0) {
      if (isDir) {
        if (this.opts.defaultDirMode) {
          mode = parseInt(this.opts.defaultDirMode, 10)
        }

        if (!mode) {
          mode = 0o755
        }
      } else {
        if (this.opts.defaultFileMode) {
          mode = parseInt(this.opts.defaultFileMode, 10)
        }

        if (!mode) {
          mode = 0o644
        }
      }
    }

    return mode
  }
}

module.exports = async function (zipPath, opts) {
  debug('creating target directory', opts.dir)

  if (!path.isAbsolute(opts.dir)) {
    throw new Error('Target directory is expected to be absolute')
  }

  await fs.mkdir(opts.dir, { recursive: true })
  opts.dir = await fs.realpath(opts.dir)
  return new Extractor(zipPath, opts).extract()
}


/***/ }),

/***/ "./node_modules/extract-zip/node_modules/get-stream/buffer-stream.js":
/*!***************************************************************************!*\
  !*** ./node_modules/extract-zip/node_modules/get-stream/buffer-stream.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {PassThrough: PassThroughStream} = __webpack_require__(/*! stream */ "stream");

module.exports = options => {
	options = {...options};

	const {array} = options;
	let {encoding} = options;
	const isBuffer = encoding === 'buffer';
	let objectMode = false;

	if (array) {
		objectMode = !(encoding || isBuffer);
	} else {
		encoding = encoding || 'utf8';
	}

	if (isBuffer) {
		encoding = null;
	}

	const stream = new PassThroughStream({objectMode});

	if (encoding) {
		stream.setEncoding(encoding);
	}

	let length = 0;
	const chunks = [];

	stream.on('data', chunk => {
		chunks.push(chunk);

		if (objectMode) {
			length = chunks.length;
		} else {
			length += chunk.length;
		}
	});

	stream.getBufferedValue = () => {
		if (array) {
			return chunks;
		}

		return isBuffer ? Buffer.concat(chunks, length) : chunks.join('');
	};

	stream.getBufferedLength = () => length;

	return stream;
};


/***/ }),

/***/ "./node_modules/extract-zip/node_modules/get-stream/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/extract-zip/node_modules/get-stream/index.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {constants: BufferConstants} = __webpack_require__(/*! buffer */ "buffer");
const pump = __webpack_require__(/*! pump */ "./node_modules/pump/index.js");
const bufferStream = __webpack_require__(/*! ./buffer-stream */ "./node_modules/extract-zip/node_modules/get-stream/buffer-stream.js");

class MaxBufferError extends Error {
	constructor() {
		super('maxBuffer exceeded');
		this.name = 'MaxBufferError';
	}
}

async function getStream(inputStream, options) {
	if (!inputStream) {
		return Promise.reject(new Error('Expected a stream'));
	}

	options = {
		maxBuffer: Infinity,
		...options
	};

	const {maxBuffer} = options;

	let stream;
	await new Promise((resolve, reject) => {
		const rejectPromise = error => {
			// Don't retrieve an oversized buffer.
			if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
				error.bufferedData = stream.getBufferedValue();
			}

			reject(error);
		};

		stream = pump(inputStream, bufferStream(options), error => {
			if (error) {
				rejectPromise(error);
				return;
			}

			resolve();
		});

		stream.on('data', () => {
			if (stream.getBufferedLength() > maxBuffer) {
				rejectPromise(new MaxBufferError());
			}
		});
	});

	return stream.getBufferedValue();
}

module.exports = getStream;
// TODO: Remove this for the next major release
module.exports["default"] = getStream;
module.exports.buffer = (stream, options) => getStream(stream, {...options, encoding: 'buffer'});
module.exports.array = (stream, options) => getStream(stream, {...options, array: true});
module.exports.MaxBufferError = MaxBufferError;


/***/ }),

/***/ "./node_modules/fd-slicer/index.js":
/*!*****************************************!*\
  !*** ./node_modules/fd-slicer/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var fs = __webpack_require__(/*! fs */ "fs");
var util = __webpack_require__(/*! util */ "util");
var stream = __webpack_require__(/*! stream */ "stream");
var Readable = stream.Readable;
var Writable = stream.Writable;
var PassThrough = stream.PassThrough;
var Pend = __webpack_require__(/*! pend */ "./node_modules/pend/index.js");
var EventEmitter = (__webpack_require__(/*! events */ "events").EventEmitter);

exports.createFromBuffer = createFromBuffer;
exports.createFromFd = createFromFd;
exports.BufferSlicer = BufferSlicer;
exports.FdSlicer = FdSlicer;

util.inherits(FdSlicer, EventEmitter);
function FdSlicer(fd, options) {
  options = options || {};
  EventEmitter.call(this);

  this.fd = fd;
  this.pend = new Pend();
  this.pend.max = 1;
  this.refCount = 0;
  this.autoClose = !!options.autoClose;
}

FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
  var self = this;
  self.pend.go(function(cb) {
    fs.read(self.fd, buffer, offset, length, position, function(err, bytesRead, buffer) {
      cb();
      callback(err, bytesRead, buffer);
    });
  });
};

FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
  var self = this;
  self.pend.go(function(cb) {
    fs.write(self.fd, buffer, offset, length, position, function(err, written, buffer) {
      cb();
      callback(err, written, buffer);
    });
  });
};

FdSlicer.prototype.createReadStream = function(options) {
  return new ReadStream(this, options);
};

FdSlicer.prototype.createWriteStream = function(options) {
  return new WriteStream(this, options);
};

FdSlicer.prototype.ref = function() {
  this.refCount += 1;
};

FdSlicer.prototype.unref = function() {
  var self = this;
  self.refCount -= 1;

  if (self.refCount > 0) return;
  if (self.refCount < 0) throw new Error("invalid unref");

  if (self.autoClose) {
    fs.close(self.fd, onCloseDone);
  }

  function onCloseDone(err) {
    if (err) {
      self.emit('error', err);
    } else {
      self.emit('close');
    }
  }
};

util.inherits(ReadStream, Readable);
function ReadStream(context, options) {
  options = options || {};
  Readable.call(this, options);

  this.context = context;
  this.context.ref();

  this.start = options.start || 0;
  this.endOffset = options.end;
  this.pos = this.start;
  this.destroyed = false;
}

ReadStream.prototype._read = function(n) {
  var self = this;
  if (self.destroyed) return;

  var toRead = Math.min(self._readableState.highWaterMark, n);
  if (self.endOffset != null) {
    toRead = Math.min(toRead, self.endOffset - self.pos);
  }
  if (toRead <= 0) {
    self.destroyed = true;
    self.push(null);
    self.context.unref();
    return;
  }
  self.context.pend.go(function(cb) {
    if (self.destroyed) return cb();
    var buffer = new Buffer(toRead);
    fs.read(self.context.fd, buffer, 0, toRead, self.pos, function(err, bytesRead) {
      if (err) {
        self.destroy(err);
      } else if (bytesRead === 0) {
        self.destroyed = true;
        self.push(null);
        self.context.unref();
      } else {
        self.pos += bytesRead;
        self.push(buffer.slice(0, bytesRead));
      }
      cb();
    });
  });
};

ReadStream.prototype.destroy = function(err) {
  if (this.destroyed) return;
  err = err || new Error("stream destroyed");
  this.destroyed = true;
  this.emit('error', err);
  this.context.unref();
};

util.inherits(WriteStream, Writable);
function WriteStream(context, options) {
  options = options || {};
  Writable.call(this, options);

  this.context = context;
  this.context.ref();

  this.start = options.start || 0;
  this.endOffset = (options.end == null) ? Infinity : +options.end;
  this.bytesWritten = 0;
  this.pos = this.start;
  this.destroyed = false;

  this.on('finish', this.destroy.bind(this));
}

WriteStream.prototype._write = function(buffer, encoding, callback) {
  var self = this;
  if (self.destroyed) return;

  if (self.pos + buffer.length > self.endOffset) {
    var err = new Error("maximum file length exceeded");
    err.code = 'ETOOBIG';
    self.destroy();
    callback(err);
    return;
  }
  self.context.pend.go(function(cb) {
    if (self.destroyed) return cb();
    fs.write(self.context.fd, buffer, 0, buffer.length, self.pos, function(err, bytes) {
      if (err) {
        self.destroy();
        cb();
        callback(err);
      } else {
        self.bytesWritten += bytes;
        self.pos += bytes;
        self.emit('progress');
        cb();
        callback();
      }
    });
  });
};

WriteStream.prototype.destroy = function() {
  if (this.destroyed) return;
  this.destroyed = true;
  this.context.unref();
};

util.inherits(BufferSlicer, EventEmitter);
function BufferSlicer(buffer, options) {
  EventEmitter.call(this);

  options = options || {};
  this.refCount = 0;
  this.buffer = buffer;
  this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;
}

BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
  var end = position + length;
  var delta = end - this.buffer.length;
  var written = (delta > 0) ? delta : length;
  this.buffer.copy(buffer, offset, position, end);
  setImmediate(function() {
    callback(null, written);
  });
};

BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
  buffer.copy(this.buffer, position, offset, offset + length);
  setImmediate(function() {
    callback(null, length, buffer);
  });
};

BufferSlicer.prototype.createReadStream = function(options) {
  options = options || {};
  var readStream = new PassThrough(options);
  readStream.destroyed = false;
  readStream.start = options.start || 0;
  readStream.endOffset = options.end;
  // by the time this function returns, we'll be done.
  readStream.pos = readStream.endOffset || this.buffer.length;

  // respect the maxChunkSize option to slice up the chunk into smaller pieces.
  var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
  var offset = 0;
  while (true) {
    var nextOffset = offset + this.maxChunkSize;
    if (nextOffset >= entireSlice.length) {
      // last chunk
      if (offset < entireSlice.length) {
        readStream.write(entireSlice.slice(offset, entireSlice.length));
      }
      break;
    }
    readStream.write(entireSlice.slice(offset, nextOffset));
    offset = nextOffset;
  }

  readStream.end();
  readStream.destroy = function() {
    readStream.destroyed = true;
  };
  return readStream;
};

BufferSlicer.prototype.createWriteStream = function(options) {
  var bufferSlicer = this;
  options = options || {};
  var writeStream = new Writable(options);
  writeStream.start = options.start || 0;
  writeStream.endOffset = (options.end == null) ? this.buffer.length : +options.end;
  writeStream.bytesWritten = 0;
  writeStream.pos = writeStream.start;
  writeStream.destroyed = false;
  writeStream._write = function(buffer, encoding, callback) {
    if (writeStream.destroyed) return;

    var end = writeStream.pos + buffer.length;
    if (end > writeStream.endOffset) {
      var err = new Error("maximum file length exceeded");
      err.code = 'ETOOBIG';
      writeStream.destroyed = true;
      callback(err);
      return;
    }
    buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);

    writeStream.bytesWritten += buffer.length;
    writeStream.pos = end;
    writeStream.emit('progress');
    callback();
  };
  writeStream.destroy = function() {
    writeStream.destroyed = true;
  };
  return writeStream;
};

BufferSlicer.prototype.ref = function() {
  this.refCount += 1;
};

BufferSlicer.prototype.unref = function() {
  this.refCount -= 1;

  if (this.refCount < 0) {
    throw new Error("invalid unref");
  }
};

function createFromBuffer(buffer, options) {
  return new BufferSlicer(buffer, options);
}

function createFromFd(fd, options) {
  return new FdSlicer(fd, options);
}


/***/ }),

/***/ "./node_modules/pend/index.js":
/*!************************************!*\
  !*** ./node_modules/pend/index.js ***!
  \************************************/
/***/ ((module) => {

module.exports = Pend;

function Pend() {
  this.pending = 0;
  this.max = Infinity;
  this.listeners = [];
  this.waiting = [];
  this.error = null;
}

Pend.prototype.go = function(fn) {
  if (this.pending < this.max) {
    pendGo(this, fn);
  } else {
    this.waiting.push(fn);
  }
};

Pend.prototype.wait = function(cb) {
  if (this.pending === 0) {
    cb(this.error);
  } else {
    this.listeners.push(cb);
  }
};

Pend.prototype.hold = function() {
  return pendHold(this);
};

function pendHold(self) {
  self.pending += 1;
  var called = false;
  return onCb;
  function onCb(err) {
    if (called) throw new Error("callback called twice");
    called = true;
    self.error = self.error || err;
    self.pending -= 1;
    if (self.waiting.length > 0 && self.pending < self.max) {
      pendGo(self, self.waiting.shift());
    } else if (self.pending === 0) {
      var listeners = self.listeners;
      self.listeners = [];
      listeners.forEach(cbListener);
    }
  }
  function cbListener(listener) {
    listener(self.error);
  }
}

function pendGo(self, fn) {
  fn(pendHold(self));
}


/***/ }),

/***/ "./node_modules/pump/index.js":
/*!************************************!*\
  !*** ./node_modules/pump/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var once = __webpack_require__(/*! once */ "./node_modules/once/once.js")
var eos = __webpack_require__(/*! end-of-stream */ "./node_modules/end-of-stream/index.js")
var fs

try {
  fs = __webpack_require__(/*! fs */ "fs") // we only need fs to get the ReadStream and WriteStream prototypes
} catch (e) {}

var noop = function () {}
var ancient = typeof process === 'undefined' ? false : /^v?\.0/.test(process.version)

var isFn = function (fn) {
  return typeof fn === 'function'
}

var isFS = function (stream) {
  if (!ancient) return false // newer node version do not need to care about fs is a special way
  if (!fs) return false // browser
  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)
}

var isRequest = function (stream) {
  return stream.setHeader && isFn(stream.abort)
}

var destroyer = function (stream, reading, writing, callback) {
  callback = once(callback)

  var closed = false
  stream.on('close', function () {
    closed = true
  })

  eos(stream, {readable: reading, writable: writing}, function (err) {
    if (err) return callback(err)
    closed = true
    callback()
  })

  var destroyed = false
  return function (err) {
    if (closed) return
    if (destroyed) return
    destroyed = true

    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks
    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy()

    callback(err || new Error('stream was destroyed'))
  }
}

var call = function (fn) {
  fn()
}

var pipe = function (from, to) {
  return from.pipe(to)
}

var pump = function () {
  var streams = Array.prototype.slice.call(arguments)
  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop

  if (Array.isArray(streams[0])) streams = streams[0]
  if (streams.length < 2) throw new Error('pump requires two streams per minimum')

  var error
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1
    var writing = i > 0
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err
      if (err) destroys.forEach(call)
      if (reading) return
      destroys.forEach(call)
      callback(error)
    })
  })

  return streams.reduce(pipe)
}

module.exports = pump


/***/ }),

/***/ "./node_modules/yauzl/index.js":
/*!*************************************!*\
  !*** ./node_modules/yauzl/index.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var fs = __webpack_require__(/*! fs */ "fs");
var zlib = __webpack_require__(/*! zlib */ "zlib");
var fd_slicer = __webpack_require__(/*! fd-slicer */ "./node_modules/fd-slicer/index.js");
var crc32 = __webpack_require__(/*! buffer-crc32 */ "./node_modules/yauzl/node_modules/buffer-crc32/index.js");
var util = __webpack_require__(/*! util */ "util");
var EventEmitter = (__webpack_require__(/*! events */ "events").EventEmitter);
var Transform = (__webpack_require__(/*! stream */ "stream").Transform);
var PassThrough = (__webpack_require__(/*! stream */ "stream").PassThrough);
var Writable = (__webpack_require__(/*! stream */ "stream").Writable);

exports.open = open;
exports.fromFd = fromFd;
exports.fromBuffer = fromBuffer;
exports.fromRandomAccessReader = fromRandomAccessReader;
exports.dosDateTimeToDate = dosDateTimeToDate;
exports.validateFileName = validateFileName;
exports.ZipFile = ZipFile;
exports.Entry = Entry;
exports.RandomAccessReader = RandomAccessReader;

function open(path, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  if (options.autoClose == null) options.autoClose = true;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  if (callback == null) callback = defaultCallback;
  fs.open(path, "r", function(err, fd) {
    if (err) return callback(err);
    fromFd(fd, options, function(err, zipfile) {
      if (err) fs.close(fd, defaultCallback);
      callback(err, zipfile);
    });
  });
}

function fromFd(fd, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  if (options.autoClose == null) options.autoClose = false;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  if (callback == null) callback = defaultCallback;
  fs.fstat(fd, function(err, stats) {
    if (err) return callback(err);
    var reader = fd_slicer.createFromFd(fd, {autoClose: true});
    fromRandomAccessReader(reader, stats.size, options, callback);
  });
}

function fromBuffer(buffer, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  options.autoClose = false;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  // limit the max chunk size. see https://github.com/thejoshwolfe/yauzl/issues/87
  var reader = fd_slicer.createFromBuffer(buffer, {maxChunkSize: 0x10000});
  fromRandomAccessReader(reader, buffer.length, options, callback);
}

function fromRandomAccessReader(reader, totalSize, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  if (options.autoClose == null) options.autoClose = true;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  var decodeStrings = !!options.decodeStrings;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  if (callback == null) callback = defaultCallback;
  if (typeof totalSize !== "number") throw new Error("expected totalSize parameter to be a number");
  if (totalSize > Number.MAX_SAFE_INTEGER) {
    throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
  }

  // the matching unref() call is in zipfile.close()
  reader.ref();

  // eocdr means End of Central Directory Record.
  // search backwards for the eocdr signature.
  // the last field of the eocdr is a variable-length comment.
  // the comment size is encoded in a 2-byte field in the eocdr, which we can't find without trudging backwards through the comment to find it.
  // as a consequence of this design decision, it's possible to have ambiguous zip file metadata if a coherent eocdr was in the comment.
  // we search backwards for a eocdr signature, and hope that whoever made the zip file was smart enough to forbid the eocdr signature in the comment.
  var eocdrWithoutCommentSize = 22;
  var maxCommentSize = 0xffff; // 2-byte size
  var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
  var buffer = newBuffer(bufferSize);
  var bufferReadStart = totalSize - buffer.length;
  readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
    if (err) return callback(err);
    for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {
      if (buffer.readUInt32LE(i) !== 0x06054b50) continue;
      // found eocdr
      var eocdrBuffer = buffer.slice(i);

      // 0 - End of central directory signature = 0x06054b50
      // 4 - Number of this disk
      var diskNumber = eocdrBuffer.readUInt16LE(4);
      if (diskNumber !== 0) {
        return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
      }
      // 6 - Disk where central directory starts
      // 8 - Number of central directory records on this disk
      // 10 - Total number of central directory records
      var entryCount = eocdrBuffer.readUInt16LE(10);
      // 12 - Size of central directory (bytes)
      // 16 - Offset of start of central directory, relative to start of archive
      var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
      // 20 - Comment length
      var commentLength = eocdrBuffer.readUInt16LE(20);
      var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
      if (commentLength !== expectedCommentLength) {
        return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
      }
      // 22 - Comment
      // the encoding is always cp437.
      var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false)
                                  : eocdrBuffer.slice(22);

      if (!(entryCount === 0xffff || centralDirectoryOffset === 0xffffffff)) {
        return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
      }

      // ZIP64 format

      // ZIP64 Zip64 end of central directory locator
      var zip64EocdlBuffer = newBuffer(20);
      var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
      readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err) {
        if (err) return callback(err);

        // 0 - zip64 end of central dir locator signature = 0x07064b50
        if (zip64EocdlBuffer.readUInt32LE(0) !== 0x07064b50) {
          return callback(new Error("invalid zip64 end of central directory locator signature"));
        }
        // 4 - number of the disk with the start of the zip64 end of central directory
        // 8 - relative offset of the zip64 end of central directory record
        var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
        // 16 - total number of disks

        // ZIP64 end of central directory record
        var zip64EocdrBuffer = newBuffer(56);
        readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err) {
          if (err) return callback(err);

          // 0 - zip64 end of central dir signature                           4 bytes  (0x06064b50)
          if (zip64EocdrBuffer.readUInt32LE(0) !== 0x06064b50) {
            return callback(new Error("invalid zip64 end of central directory record signature"));
          }
          // 4 - size of zip64 end of central directory record                8 bytes
          // 12 - version made by                                             2 bytes
          // 14 - version needed to extract                                   2 bytes
          // 16 - number of this disk                                         4 bytes
          // 20 - number of the disk with the start of the central directory  4 bytes
          // 24 - total number of entries in the central directory on this disk         8 bytes
          // 32 - total number of entries in the central directory            8 bytes
          entryCount = readUInt64LE(zip64EocdrBuffer, 32);
          // 40 - size of the central directory                               8 bytes
          // 48 - offset of start of central directory with respect to the starting disk number     8 bytes
          centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
          // 56 - zip64 extensible data sector                                (variable size)
          return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
        });
      });
      return;
    }
    callback(new Error("end of central directory record signature not found"));
  });
}

util.inherits(ZipFile, EventEmitter);
function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
  var self = this;
  EventEmitter.call(self);
  self.reader = reader;
  // forward close events
  self.reader.on("error", function(err) {
    // error closing the fd
    emitError(self, err);
  });
  self.reader.once("close", function() {
    self.emit("close");
  });
  self.readEntryCursor = centralDirectoryOffset;
  self.fileSize = fileSize;
  self.entryCount = entryCount;
  self.comment = comment;
  self.entriesRead = 0;
  self.autoClose = !!autoClose;
  self.lazyEntries = !!lazyEntries;
  self.decodeStrings = !!decodeStrings;
  self.validateEntrySizes = !!validateEntrySizes;
  self.strictFileNames = !!strictFileNames;
  self.isOpen = true;
  self.emittedError = false;

  if (!self.lazyEntries) self._readEntry();
}
ZipFile.prototype.close = function() {
  if (!this.isOpen) return;
  this.isOpen = false;
  this.reader.unref();
};

function emitErrorAndAutoClose(self, err) {
  if (self.autoClose) self.close();
  emitError(self, err);
}
function emitError(self, err) {
  if (self.emittedError) return;
  self.emittedError = true;
  self.emit("error", err);
}

ZipFile.prototype.readEntry = function() {
  if (!this.lazyEntries) throw new Error("readEntry() called without lazyEntries:true");
  this._readEntry();
};
ZipFile.prototype._readEntry = function() {
  var self = this;
  if (self.entryCount === self.entriesRead) {
    // done with metadata
    setImmediate(function() {
      if (self.autoClose) self.close();
      if (self.emittedError) return;
      self.emit("end");
    });
    return;
  }
  if (self.emittedError) return;
  var buffer = newBuffer(46);
  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {
    if (err) return emitErrorAndAutoClose(self, err);
    if (self.emittedError) return;
    var entry = new Entry();
    // 0 - Central directory file header signature
    var signature = buffer.readUInt32LE(0);
    if (signature !== 0x02014b50) return emitErrorAndAutoClose(self, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
    // 4 - Version made by
    entry.versionMadeBy = buffer.readUInt16LE(4);
    // 6 - Version needed to extract (minimum)
    entry.versionNeededToExtract = buffer.readUInt16LE(6);
    // 8 - General purpose bit flag
    entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
    // 10 - Compression method
    entry.compressionMethod = buffer.readUInt16LE(10);
    // 12 - File last modification time
    entry.lastModFileTime = buffer.readUInt16LE(12);
    // 14 - File last modification date
    entry.lastModFileDate = buffer.readUInt16LE(14);
    // 16 - CRC-32
    entry.crc32 = buffer.readUInt32LE(16);
    // 20 - Compressed size
    entry.compressedSize = buffer.readUInt32LE(20);
    // 24 - Uncompressed size
    entry.uncompressedSize = buffer.readUInt32LE(24);
    // 28 - File name length (n)
    entry.fileNameLength = buffer.readUInt16LE(28);
    // 30 - Extra field length (m)
    entry.extraFieldLength = buffer.readUInt16LE(30);
    // 32 - File comment length (k)
    entry.fileCommentLength = buffer.readUInt16LE(32);
    // 34 - Disk number where file starts
    // 36 - Internal file attributes
    entry.internalFileAttributes = buffer.readUInt16LE(36);
    // 38 - External file attributes
    entry.externalFileAttributes = buffer.readUInt32LE(38);
    // 42 - Relative offset of local file header
    entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);

    if (entry.generalPurposeBitFlag & 0x40) return emitErrorAndAutoClose(self, new Error("strong encryption is not supported"));

    self.readEntryCursor += 46;

    buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
    readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {
      if (err) return emitErrorAndAutoClose(self, err);
      if (self.emittedError) return;
      // 46 - File name
      var isUtf8 = (entry.generalPurposeBitFlag & 0x800) !== 0;
      entry.fileName = self.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8)
                                          : buffer.slice(0, entry.fileNameLength);

      // 46+n - Extra field
      var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
      var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);
      entry.extraFields = [];
      var i = 0;
      while (i < extraFieldBuffer.length - 3) {
        var headerId = extraFieldBuffer.readUInt16LE(i + 0);
        var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
        var dataStart = i + 4;
        var dataEnd = dataStart + dataSize;
        if (dataEnd > extraFieldBuffer.length) return emitErrorAndAutoClose(self, new Error("extra field length exceeds extra field buffer size"));
        var dataBuffer = newBuffer(dataSize);
        extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
        entry.extraFields.push({
          id: headerId,
          data: dataBuffer,
        });
        i = dataEnd;
      }

      // 46+n+m - File comment
      entry.fileComment = self.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8)
                                             : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
      // compatibility hack for https://github.com/thejoshwolfe/yauzl/issues/47
      entry.comment = entry.fileComment;

      self.readEntryCursor += buffer.length;
      self.entriesRead += 1;

      if (entry.uncompressedSize            === 0xffffffff ||
          entry.compressedSize              === 0xffffffff ||
          entry.relativeOffsetOfLocalHeader === 0xffffffff) {
        // ZIP64 format
        // find the Zip64 Extended Information Extra Field
        var zip64EiefBuffer = null;
        for (var i = 0; i < entry.extraFields.length; i++) {
          var extraField = entry.extraFields[i];
          if (extraField.id === 0x0001) {
            zip64EiefBuffer = extraField.data;
            break;
          }
        }
        if (zip64EiefBuffer == null) {
          return emitErrorAndAutoClose(self, new Error("expected zip64 extended information extra field"));
        }
        var index = 0;
        // 0 - Original Size          8 bytes
        if (entry.uncompressedSize === 0xffffffff) {
          if (index + 8 > zip64EiefBuffer.length) {
            return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include uncompressed size"));
          }
          entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
          index += 8;
        }
        // 8 - Compressed Size        8 bytes
        if (entry.compressedSize === 0xffffffff) {
          if (index + 8 > zip64EiefBuffer.length) {
            return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include compressed size"));
          }
          entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
          index += 8;
        }
        // 16 - Relative Header Offset 8 bytes
        if (entry.relativeOffsetOfLocalHeader === 0xffffffff) {
          if (index + 8 > zip64EiefBuffer.length) {
            return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include relative header offset"));
          }
          entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
          index += 8;
        }
        // 24 - Disk Start Number      4 bytes
      }

      // check for Info-ZIP Unicode Path Extra Field (0x7075)
      // see https://github.com/thejoshwolfe/yauzl/issues/33
      if (self.decodeStrings) {
        for (var i = 0; i < entry.extraFields.length; i++) {
          var extraField = entry.extraFields[i];
          if (extraField.id === 0x7075) {
            if (extraField.data.length < 6) {
              // too short to be meaningful
              continue;
            }
            // Version       1 byte      version of this extra field, currently 1
            if (extraField.data.readUInt8(0) !== 1) {
              // > Changes may not be backward compatible so this extra
              // > field should not be used if the version is not recognized.
              continue;
            }
            // NameCRC32     4 bytes     File Name Field CRC32 Checksum
            var oldNameCrc32 = extraField.data.readUInt32LE(1);
            if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {
              // > If the CRC check fails, this UTF-8 Path Extra Field should be
              // > ignored and the File Name field in the header should be used instead.
              continue;
            }
            // UnicodeName   Variable    UTF-8 version of the entry File Name
            entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
            break;
          }
        }
      }

      // validate file size
      if (self.validateEntrySizes && entry.compressionMethod === 0) {
        var expectedCompressedSize = entry.uncompressedSize;
        if (entry.isEncrypted()) {
          // traditional encryption prefixes the file data with a header
          expectedCompressedSize += 12;
        }
        if (entry.compressedSize !== expectedCompressedSize) {
          var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
          return emitErrorAndAutoClose(self, new Error(msg));
        }
      }

      if (self.decodeStrings) {
        if (!self.strictFileNames) {
          // allow backslash
          entry.fileName = entry.fileName.replace(/\\/g, "/");
        }
        var errorMessage = validateFileName(entry.fileName, self.validateFileNameOptions);
        if (errorMessage != null) return emitErrorAndAutoClose(self, new Error(errorMessage));
      }
      self.emit("entry", entry);

      if (!self.lazyEntries) self._readEntry();
    });
  });
};

ZipFile.prototype.openReadStream = function(entry, options, callback) {
  var self = this;
  // parameter validation
  var relativeStart = 0;
  var relativeEnd = entry.compressedSize;
  if (callback == null) {
    callback = options;
    options = {};
  } else {
    // validate options that the caller has no excuse to get wrong
    if (options.decrypt != null) {
      if (!entry.isEncrypted()) {
        throw new Error("options.decrypt can only be specified for encrypted entries");
      }
      if (options.decrypt !== false) throw new Error("invalid options.decrypt value: " + options.decrypt);
      if (entry.isCompressed()) {
        if (options.decompress !== false) throw new Error("entry is encrypted and compressed, and options.decompress !== false");
      }
    }
    if (options.decompress != null) {
      if (!entry.isCompressed()) {
        throw new Error("options.decompress can only be specified for compressed entries");
      }
      if (!(options.decompress === false || options.decompress === true)) {
        throw new Error("invalid options.decompress value: " + options.decompress);
      }
    }
    if (options.start != null || options.end != null) {
      if (entry.isCompressed() && options.decompress !== false) {
        throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
      }
      if (entry.isEncrypted() && options.decrypt !== false) {
        throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
      }
    }
    if (options.start != null) {
      relativeStart = options.start;
      if (relativeStart < 0) throw new Error("options.start < 0");
      if (relativeStart > entry.compressedSize) throw new Error("options.start > entry.compressedSize");
    }
    if (options.end != null) {
      relativeEnd = options.end;
      if (relativeEnd < 0) throw new Error("options.end < 0");
      if (relativeEnd > entry.compressedSize) throw new Error("options.end > entry.compressedSize");
      if (relativeEnd < relativeStart) throw new Error("options.end < options.start");
    }
  }
  // any further errors can either be caused by the zipfile,
  // or were introduced in a minor version of yauzl,
  // so should be passed to the client rather than thrown.
  if (!self.isOpen) return callback(new Error("closed"));
  if (entry.isEncrypted()) {
    if (options.decrypt !== false) return callback(new Error("entry is encrypted, and options.decrypt !== false"));
  }
  // make sure we don't lose the fd before we open the actual read stream
  self.reader.ref();
  var buffer = newBuffer(30);
  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
    try {
      if (err) return callback(err);
      // 0 - Local file header signature = 0x04034b50
      var signature = buffer.readUInt32LE(0);
      if (signature !== 0x04034b50) {
        return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
      }
      // all this should be redundant
      // 4 - Version needed to extract (minimum)
      // 6 - General purpose bit flag
      // 8 - Compression method
      // 10 - File last modification time
      // 12 - File last modification date
      // 14 - CRC-32
      // 18 - Compressed size
      // 22 - Uncompressed size
      // 26 - File name length (n)
      var fileNameLength = buffer.readUInt16LE(26);
      // 28 - Extra field length (m)
      var extraFieldLength = buffer.readUInt16LE(28);
      // 30 - File name
      // 30+n - Extra field
      var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
      var decompress;
      if (entry.compressionMethod === 0) {
        // 0 - The file is stored (no compression)
        decompress = false;
      } else if (entry.compressionMethod === 8) {
        // 8 - The file is Deflated
        decompress = options.decompress != null ? options.decompress : true;
      } else {
        return callback(new Error("unsupported compression method: " + entry.compressionMethod));
      }
      var fileDataStart = localFileHeaderEnd;
      var fileDataEnd = fileDataStart + entry.compressedSize;
      if (entry.compressedSize !== 0) {
        // bounds check now, because the read streams will probably not complain loud enough.
        // since we're dealing with an unsigned offset plus an unsigned size,
        // we only have 1 thing to check for.
        if (fileDataEnd > self.fileSize) {
          return callback(new Error("file data overflows file bounds: " +
              fileDataStart + " + " + entry.compressedSize + " > " + self.fileSize));
        }
      }
      var readStream = self.reader.createReadStream({
        start: fileDataStart + relativeStart,
        end: fileDataStart + relativeEnd,
      });
      var endpointStream = readStream;
      if (decompress) {
        var destroyed = false;
        var inflateFilter = zlib.createInflateRaw();
        readStream.on("error", function(err) {
          // setImmediate here because errors can be emitted during the first call to pipe()
          setImmediate(function() {
            if (!destroyed) inflateFilter.emit("error", err);
          });
        });
        readStream.pipe(inflateFilter);

        if (self.validateEntrySizes) {
          endpointStream = new AssertByteCountStream(entry.uncompressedSize);
          inflateFilter.on("error", function(err) {
            // forward zlib errors to the client-visible stream
            setImmediate(function() {
              if (!destroyed) endpointStream.emit("error", err);
            });
          });
          inflateFilter.pipe(endpointStream);
        } else {
          // the zlib filter is the client-visible stream
          endpointStream = inflateFilter;
        }
        // this is part of yauzl's API, so implement this function on the client-visible stream
        endpointStream.destroy = function() {
          destroyed = true;
          if (inflateFilter !== endpointStream) inflateFilter.unpipe(endpointStream);
          readStream.unpipe(inflateFilter);
          // TODO: the inflateFilter may cause a memory leak. see Issue #27.
          readStream.destroy();
        };
      }
      callback(null, endpointStream);
    } finally {
      self.reader.unref();
    }
  });
};

function Entry() {
}
Entry.prototype.getLastModDate = function() {
  return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
};
Entry.prototype.isEncrypted = function() {
  return (this.generalPurposeBitFlag & 0x1) !== 0;
};
Entry.prototype.isCompressed = function() {
  return this.compressionMethod === 8;
};

function dosDateTimeToDate(date, time) {
  var day = date & 0x1f; // 1-31
  var month = (date >> 5 & 0xf) - 1; // 1-12, 0-11
  var year = (date >> 9 & 0x7f) + 1980; // 0-128, 1980-2108

  var millisecond = 0;
  var second = (time & 0x1f) * 2; // 0-29, 0-58 (even numbers)
  var minute = time >> 5 & 0x3f; // 0-59
  var hour = time >> 11 & 0x1f; // 0-23

  return new Date(year, month, day, hour, minute, second, millisecond);
}

function validateFileName(fileName) {
  if (fileName.indexOf("\\") !== -1) {
    return "invalid characters in fileName: " + fileName;
  }
  if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
    return "absolute path: " + fileName;
  }
  if (fileName.split("/").indexOf("..") !== -1) {
    return "invalid relative path: " + fileName;
  }
  // all good
  return null;
}

function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
  if (length === 0) {
    // fs.read will throw an out-of-bounds error if you try to read 0 bytes from a 0 byte file
    return setImmediate(function() { callback(null, newBuffer(0)); });
  }
  reader.read(buffer, offset, length, position, function(err, bytesRead) {
    if (err) return callback(err);
    if (bytesRead < length) {
      return callback(new Error("unexpected EOF"));
    }
    callback();
  });
}

util.inherits(AssertByteCountStream, Transform);
function AssertByteCountStream(byteCount) {
  Transform.call(this);
  this.actualByteCount = 0;
  this.expectedByteCount = byteCount;
}
AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
  this.actualByteCount += chunk.length;
  if (this.actualByteCount > this.expectedByteCount) {
    var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
    return cb(new Error(msg));
  }
  cb(null, chunk);
};
AssertByteCountStream.prototype._flush = function(cb) {
  if (this.actualByteCount < this.expectedByteCount) {
    var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
    return cb(new Error(msg));
  }
  cb();
};

util.inherits(RandomAccessReader, EventEmitter);
function RandomAccessReader() {
  EventEmitter.call(this);
  this.refCount = 0;
}
RandomAccessReader.prototype.ref = function() {
  this.refCount += 1;
};
RandomAccessReader.prototype.unref = function() {
  var self = this;
  self.refCount -= 1;

  if (self.refCount > 0) return;
  if (self.refCount < 0) throw new Error("invalid unref");

  self.close(onCloseDone);

  function onCloseDone(err) {
    if (err) return self.emit('error', err);
    self.emit('close');
  }
};
RandomAccessReader.prototype.createReadStream = function(options) {
  var start = options.start;
  var end = options.end;
  if (start === end) {
    var emptyStream = new PassThrough();
    setImmediate(function() {
      emptyStream.end();
    });
    return emptyStream;
  }
  var stream = this._readStreamForRange(start, end);

  var destroyed = false;
  var refUnrefFilter = new RefUnrefFilter(this);
  stream.on("error", function(err) {
    setImmediate(function() {
      if (!destroyed) refUnrefFilter.emit("error", err);
    });
  });
  refUnrefFilter.destroy = function() {
    stream.unpipe(refUnrefFilter);
    refUnrefFilter.unref();
    stream.destroy();
  };

  var byteCounter = new AssertByteCountStream(end - start);
  refUnrefFilter.on("error", function(err) {
    setImmediate(function() {
      if (!destroyed) byteCounter.emit("error", err);
    });
  });
  byteCounter.destroy = function() {
    destroyed = true;
    refUnrefFilter.unpipe(byteCounter);
    refUnrefFilter.destroy();
  };

  return stream.pipe(refUnrefFilter).pipe(byteCounter);
};
RandomAccessReader.prototype._readStreamForRange = function(start, end) {
  throw new Error("not implemented");
};
RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
  var readStream = this.createReadStream({start: position, end: position + length});
  var writeStream = new Writable();
  var written = 0;
  writeStream._write = function(chunk, encoding, cb) {
    chunk.copy(buffer, offset + written, 0, chunk.length);
    written += chunk.length;
    cb();
  };
  writeStream.on("finish", callback);
  readStream.on("error", function(error) {
    callback(error);
  });
  readStream.pipe(writeStream);
};
RandomAccessReader.prototype.close = function(callback) {
  setImmediate(callback);
};

util.inherits(RefUnrefFilter, PassThrough);
function RefUnrefFilter(context) {
  PassThrough.call(this);
  this.context = context;
  this.context.ref();
  this.unreffedYet = false;
}
RefUnrefFilter.prototype._flush = function(cb) {
  this.unref();
  cb();
};
RefUnrefFilter.prototype.unref = function(cb) {
  if (this.unreffedYet) return;
  this.unreffedYet = true;
  this.context.unref();
};

var cp437 = '\u0000☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ';
function decodeBuffer(buffer, start, end, isUtf8) {
  if (isUtf8) {
    return buffer.toString("utf8", start, end);
  } else {
    var result = "";
    for (var i = start; i < end; i++) {
      result += cp437[buffer[i]];
    }
    return result;
  }
}

function readUInt64LE(buffer, offset) {
  // there is no native function for this, because we can't actually store 64-bit integers precisely.
  // after 53 bits, JavaScript's Number type (IEEE 754 double) can't store individual integers anymore.
  // but since 53 bits is a whole lot more than 32 bits, we do our best anyway.
  var lower32 = buffer.readUInt32LE(offset);
  var upper32 = buffer.readUInt32LE(offset + 4);
  // we can't use bitshifting here, because JavaScript bitshifting only works on 32-bit integers.
  return upper32 * 0x100000000 + lower32;
  // as long as we're bounds checking the result of this function against the total file size,
  // we'll catch any overflow errors, because we already made sure the total file size was within reason.
}

// Node 10 deprecated new Buffer().
var newBuffer;
if (typeof Buffer.allocUnsafe === "function") {
  newBuffer = function(len) {
    return Buffer.allocUnsafe(len);
  };
} else {
  newBuffer = function(len) {
    return new Buffer(len);
  };
}

function defaultCallback(err) {
  if (err) throw err;
}


/***/ }),

/***/ "./node_modules/yauzl/node_modules/buffer-crc32/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/yauzl/node_modules/buffer-crc32/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__(/*! buffer */ "buffer").Buffer);

var CRC_TABLE = [
  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,
  0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,
  0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,
  0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
  0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,
  0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
  0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,
  0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
  0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
  0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,
  0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,
  0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,
  0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
  0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,
  0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
  0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,
  0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
  0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,
  0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
  0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,
  0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,
  0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,
  0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,
  0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,
  0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
  0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
  0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,
  0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
  0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,
  0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
  0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,
  0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,
  0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,
  0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,
  0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,
  0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,
  0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
  0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,
  0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
  0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,
  0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
  0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
  0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
  0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,
  0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,
  0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,
  0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,
  0x2d02ef8d
];

if (typeof Int32Array !== 'undefined') {
  CRC_TABLE = new Int32Array(CRC_TABLE);
}

function ensureBuffer(input) {
  if (Buffer.isBuffer(input)) {
    return input;
  }

  var hasNewBufferAPI =
      typeof Buffer.alloc === "function" &&
      typeof Buffer.from === "function";

  if (typeof input === "number") {
    return hasNewBufferAPI ? Buffer.alloc(input) : new Buffer(input);
  }
  else if (typeof input === "string") {
    return hasNewBufferAPI ? Buffer.from(input) : new Buffer(input);
  }
  else {
    throw new Error("input must be buffer, number, or string, received " +
                    typeof input);
  }
}

function bufferizeInt(num) {
  var tmp = ensureBuffer(4);
  tmp.writeInt32BE(num, 0);
  return tmp;
}

function _crc32(buf, previous) {
  buf = ensureBuffer(buf);
  if (Buffer.isBuffer(previous)) {
    previous = previous.readUInt32BE(0);
  }
  var crc = ~~previous ^ -1;
  for (var n = 0; n < buf.length; n++) {
    crc = CRC_TABLE[(crc ^ buf[n]) & 0xff] ^ (crc >>> 8);
  }
  return (crc ^ -1);
}

function crc32() {
  return bufferizeInt(_crc32.apply(null, arguments));
}
crc32.signed = function () {
  return _crc32.apply(null, arguments);
};
crc32.unsigned = function () {
  return _crc32.apply(null, arguments) >>> 0;
};

module.exports = crc32;


/***/ })

};
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZXh0cmFjdC16aXBfaW5kZXhfanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLGNBQWMsbUJBQU8sQ0FBQyxnREFBTztBQUM3QjtBQUNBLFFBQVEsa0NBQWtDLEVBQUUsbUJBQU8sQ0FBQyxjQUFJO0FBQ3hELGtCQUFrQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3RDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixjQUFjLG1CQUFPLENBQUMsNENBQU87O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlEQUFpRCxtQkFBbUI7QUFDcEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDBCQUEwQjtBQUM5RTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0NBQW9DLGlCQUFpQjs7QUFFckQ7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRCxpQkFBaUIsZ0NBQWdDLGVBQWU7QUFDbEg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsMEJBQTBCO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLDREQUE0RDs7QUFFNUY7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLCtCQUErQjtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkRBQTJELGdCQUFnQjtBQUMzRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDNUthO0FBQ2IsT0FBTyxnQ0FBZ0MsRUFBRSxtQkFBTyxDQUFDLHNCQUFROztBQUV6RDtBQUNBLFlBQVk7O0FBRVosUUFBUSxPQUFPO0FBQ2YsTUFBTSxVQUFVO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsV0FBVzs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDbkRhO0FBQ2IsT0FBTyw0QkFBNEIsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ3JELGFBQWEsbUJBQU8sQ0FBQywwQ0FBTTtBQUMzQixxQkFBcUIsbUJBQU8sQ0FBQyw0RkFBaUI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBc0I7QUFDdEIscUJBQXFCLDJDQUEyQywrQkFBK0I7QUFDL0Ysb0JBQW9CLDJDQUEyQyx3QkFBd0I7QUFDdkYsNkJBQTZCOzs7Ozs7Ozs7OztBQzNEN0IsU0FBUyxtQkFBTyxDQUFDLGNBQUk7QUFDckIsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsMENBQU07QUFDekIsbUJBQW1CLDBEQUE4Qjs7QUFFakQsd0JBQXdCO0FBQ3hCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2U0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJ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U0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmFrZS1ub2RlLy4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtemlwL2luZGV4LmpzIiwid2VicGFjazovL2Zha2Utbm9kZS8uL25vZGVfbW9kdWxlcy9leHRyYWN0LXppcC9ub2RlX21vZHVsZXMvZ2V0LXN0cmVhbS9idWZmZXItc3RyZWFtLmpzIiwid2VicGFjazovL2Zha2Utbm9kZS8uL25vZGVfbW9kdWxlcy9leHRyYWN0LXppcC9ub2RlX21vZHVsZXMvZ2V0LXN0cmVhbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9mYWtlLW5vZGUvLi9ub2RlX21vZHVsZXMvZmQtc2xpY2VyL2luZGV4LmpzIiwid2VicGFjazovL2Zha2Utbm9kZS8uL25vZGVfbW9kdWxlcy9wZW5kL2luZGV4LmpzIiwid2VicGFjazovL2Zha2Utbm9kZS8uL25vZGVfbW9kdWxlcy9wdW1wL2luZGV4LmpzIiwid2VicGFjazovL2Zha2Utbm9kZS8uL25vZGVfbW9kdWxlcy95YXV6bC9pbmRleC5qcyIsIndlYnBhY2s6Ly9mYWtlLW5vZGUvLi9ub2RlX21vZHVsZXMveWF1emwvbm9kZV9tb2R1bGVzL2J1ZmZlci1jcmMzMi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2V4dHJhY3QtemlwJylcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbmNvbnN0IHsgY3JlYXRlV3JpdGVTdHJlYW0sIHByb21pc2VzOiBmcyB9ID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgZ2V0U3RyZWFtID0gcmVxdWlyZSgnZ2V0LXN0cmVhbScpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpXG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKVxuY29uc3QgeWF1emwgPSByZXF1aXJlKCd5YXV6bCcpXG5cbmNvbnN0IG9wZW5aaXAgPSBwcm9taXNpZnkoeWF1emwub3BlbilcbmNvbnN0IHBpcGVsaW5lID0gcHJvbWlzaWZ5KHN0cmVhbS5waXBlbGluZSlcblxuY2xhc3MgRXh0cmFjdG9yIHtcbiAgY29uc3RydWN0b3IgKHppcFBhdGgsIG9wdHMpIHtcbiAgICB0aGlzLnppcFBhdGggPSB6aXBQYXRoXG4gICAgdGhpcy5vcHRzID0gb3B0c1xuICB9XG5cbiAgYXN5bmMgZXh0cmFjdCAoKSB7XG4gICAgZGVidWcoJ29wZW5pbmcnLCB0aGlzLnppcFBhdGgsICd3aXRoIG9wdHMnLCB0aGlzLm9wdHMpXG5cbiAgICB0aGlzLnppcGZpbGUgPSBhd2FpdCBvcGVuWmlwKHRoaXMuemlwUGF0aCwgeyBsYXp5RW50cmllczogdHJ1ZSB9KVxuICAgIHRoaXMuY2FuY2VsZWQgPSBmYWxzZVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuemlwZmlsZS5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICB0aGlzLmNhbmNlbGVkID0gdHJ1ZVxuICAgICAgICByZWplY3QoZXJyKVxuICAgICAgfSlcbiAgICAgIHRoaXMuemlwZmlsZS5yZWFkRW50cnkoKVxuXG4gICAgICB0aGlzLnppcGZpbGUub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuY2FuY2VsZWQpIHtcbiAgICAgICAgICBkZWJ1ZygnemlwIGV4dHJhY3Rpb24gY29tcGxldGUnKVxuICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICB0aGlzLnppcGZpbGUub24oJ2VudHJ5JywgYXN5bmMgZW50cnkgPT4ge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsZWQpIHtcbiAgICAgICAgICBkZWJ1Zygnc2tpcHBpbmcgZW50cnknLCBlbnRyeS5maWxlTmFtZSwgeyBjYW5jZWxsZWQ6IHRoaXMuY2FuY2VsZWQgfSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGRlYnVnKCd6aXBmaWxlIGVudHJ5JywgZW50cnkuZmlsZU5hbWUpXG5cbiAgICAgICAgaWYgKGVudHJ5LmZpbGVOYW1lLnN0YXJ0c1dpdGgoJ19fTUFDT1NYLycpKSB7XG4gICAgICAgICAgdGhpcy56aXBmaWxlLnJlYWRFbnRyeSgpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZXN0RGlyID0gcGF0aC5kaXJuYW1lKHBhdGguam9pbih0aGlzLm9wdHMuZGlyLCBlbnRyeS5maWxlTmFtZSkpXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBmcy5ta2RpcihkZXN0RGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KVxuXG4gICAgICAgICAgY29uc3QgY2Fub25pY2FsRGVzdERpciA9IGF3YWl0IGZzLnJlYWxwYXRoKGRlc3REaXIpXG4gICAgICAgICAgY29uc3QgcmVsYXRpdmVEZXN0RGlyID0gcGF0aC5yZWxhdGl2ZSh0aGlzLm9wdHMuZGlyLCBjYW5vbmljYWxEZXN0RGlyKVxuXG4gICAgICAgICAgaWYgKHJlbGF0aXZlRGVzdERpci5zcGxpdChwYXRoLnNlcCkuaW5jbHVkZXMoJy4uJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT3V0IG9mIGJvdW5kIHBhdGggXCIke2Nhbm9uaWNhbERlc3REaXJ9XCIgZm91bmQgd2hpbGUgcHJvY2Vzc2luZyBmaWxlICR7ZW50cnkuZmlsZU5hbWV9YClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhd2FpdCB0aGlzLmV4dHJhY3RFbnRyeShlbnRyeSlcbiAgICAgICAgICBkZWJ1ZygnZmluaXNoZWQgcHJvY2Vzc2luZycsIGVudHJ5LmZpbGVOYW1lKVxuICAgICAgICAgIHRoaXMuemlwZmlsZS5yZWFkRW50cnkoKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aGlzLmNhbmNlbGVkID0gdHJ1ZVxuICAgICAgICAgIHRoaXMuemlwZmlsZS5jbG9zZSgpXG4gICAgICAgICAgcmVqZWN0KGVycilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgYXN5bmMgZXh0cmFjdEVudHJ5IChlbnRyeSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLmNhbmNlbGVkKSB7XG4gICAgICBkZWJ1Zygnc2tpcHBpbmcgZW50cnkgZXh0cmFjdGlvbicsIGVudHJ5LmZpbGVOYW1lLCB7IGNhbmNlbGxlZDogdGhpcy5jYW5jZWxlZCB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0cy5vbkVudHJ5KSB7XG4gICAgICB0aGlzLm9wdHMub25FbnRyeShlbnRyeSwgdGhpcy56aXBmaWxlKVxuICAgIH1cblxuICAgIGNvbnN0IGRlc3QgPSBwYXRoLmpvaW4odGhpcy5vcHRzLmRpciwgZW50cnkuZmlsZU5hbWUpXG5cbiAgICAvLyBjb252ZXJ0IGV4dGVybmFsIGZpbGUgYXR0ciBpbnQgaW50byBhIGZzIHN0YXQgbW9kZSBpbnRcbiAgICBjb25zdCBtb2RlID0gKGVudHJ5LmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgPj4gMTYpICYgMHhGRkZGXG4gICAgLy8gY2hlY2sgaWYgaXQncyBhIHN5bWxpbmsgb3IgZGlyICh1c2luZyBzdGF0IG1vZGUgY29uc3RhbnRzKVxuICAgIGNvbnN0IElGTVQgPSA2MTQ0MFxuICAgIGNvbnN0IElGRElSID0gMTYzODRcbiAgICBjb25zdCBJRkxOSyA9IDQwOTYwXG4gICAgY29uc3Qgc3ltbGluayA9IChtb2RlICYgSUZNVCkgPT09IElGTE5LXG4gICAgbGV0IGlzRGlyID0gKG1vZGUgJiBJRk1UKSA9PT0gSUZESVJcblxuICAgIC8vIEZhaWxzYWZlLCBib3Jyb3dlZCBmcm9tIGpzWmlwXG4gICAgaWYgKCFpc0RpciAmJiBlbnRyeS5maWxlTmFtZS5lbmRzV2l0aCgnLycpKSB7XG4gICAgICBpc0RpciA9IHRydWVcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3Igd2luZG93cyB3ZWlyZCB3YXkgb2Ygc3BlY2lmeWluZyBhIGRpcmVjdG9yeVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXhvZ2Rlbi9leHRyYWN0LXppcC9pc3N1ZXMvMTMjaXNzdWVjb21tZW50LTE1NDQ5NDU2NlxuICAgIGNvbnN0IG1hZGVCeSA9IGVudHJ5LnZlcnNpb25NYWRlQnkgPj4gOFxuICAgIGlmICghaXNEaXIpIGlzRGlyID0gKG1hZGVCeSA9PT0gMCAmJiBlbnRyeS5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzID09PSAxNilcblxuICAgIGRlYnVnKCdleHRyYWN0aW5nIGVudHJ5JywgeyBmaWxlbmFtZTogZW50cnkuZmlsZU5hbWUsIGlzRGlyOiBpc0RpciwgaXNTeW1saW5rOiBzeW1saW5rIH0pXG5cbiAgICBjb25zdCBwcm9jTW9kZSA9IHRoaXMuZ2V0RXh0cmFjdGVkTW9kZShtb2RlLCBpc0RpcikgJiAwbzc3N1xuXG4gICAgLy8gYWx3YXlzIGVuc3VyZSBmb2xkZXJzIGFyZSBjcmVhdGVkXG4gICAgY29uc3QgZGVzdERpciA9IGlzRGlyID8gZGVzdCA6IHBhdGguZGlybmFtZShkZXN0KVxuXG4gICAgY29uc3QgbWtkaXJPcHRpb25zID0geyByZWN1cnNpdmU6IHRydWUgfVxuICAgIGlmIChpc0Rpcikge1xuICAgICAgbWtkaXJPcHRpb25zLm1vZGUgPSBwcm9jTW9kZVxuICAgIH1cbiAgICBkZWJ1ZygnbWtkaXInLCB7IGRpcjogZGVzdERpciwgLi4ubWtkaXJPcHRpb25zIH0pXG4gICAgYXdhaXQgZnMubWtkaXIoZGVzdERpciwgbWtkaXJPcHRpb25zKVxuICAgIGlmIChpc0RpcikgcmV0dXJuXG5cbiAgICBkZWJ1Zygnb3BlbmluZyByZWFkIHN0cmVhbScsIGRlc3QpXG4gICAgY29uc3QgcmVhZFN0cmVhbSA9IGF3YWl0IHByb21pc2lmeSh0aGlzLnppcGZpbGUub3BlblJlYWRTdHJlYW0uYmluZCh0aGlzLnppcGZpbGUpKShlbnRyeSlcblxuICAgIGlmIChzeW1saW5rKSB7XG4gICAgICBjb25zdCBsaW5rID0gYXdhaXQgZ2V0U3RyZWFtKHJlYWRTdHJlYW0pXG4gICAgICBkZWJ1ZygnY3JlYXRpbmcgc3ltbGluaycsIGxpbmssIGRlc3QpXG4gICAgICBhd2FpdCBmcy5zeW1saW5rKGxpbmssIGRlc3QpXG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IHBpcGVsaW5lKHJlYWRTdHJlYW0sIGNyZWF0ZVdyaXRlU3RyZWFtKGRlc3QsIHsgbW9kZTogcHJvY01vZGUgfSkpXG4gICAgfVxuICB9XG5cbiAgZ2V0RXh0cmFjdGVkTW9kZSAoZW50cnlNb2RlLCBpc0Rpcikge1xuICAgIGxldCBtb2RlID0gZW50cnlNb2RlXG4gICAgLy8gU2V0IGRlZmF1bHRzLCBpZiBuZWNlc3NhcnlcbiAgICBpZiAobW9kZSA9PT0gMCkge1xuICAgICAgaWYgKGlzRGlyKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuZGVmYXVsdERpck1vZGUpIHtcbiAgICAgICAgICBtb2RlID0gcGFyc2VJbnQodGhpcy5vcHRzLmRlZmF1bHREaXJNb2RlLCAxMClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbW9kZSkge1xuICAgICAgICAgIG1vZGUgPSAwbzc1NVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5vcHRzLmRlZmF1bHRGaWxlTW9kZSkge1xuICAgICAgICAgIG1vZGUgPSBwYXJzZUludCh0aGlzLm9wdHMuZGVmYXVsdEZpbGVNb2RlLCAxMClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbW9kZSkge1xuICAgICAgICAgIG1vZGUgPSAwbzY0NFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZGVcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzeW5jIGZ1bmN0aW9uICh6aXBQYXRoLCBvcHRzKSB7XG4gIGRlYnVnKCdjcmVhdGluZyB0YXJnZXQgZGlyZWN0b3J5Jywgb3B0cy5kaXIpXG5cbiAgaWYgKCFwYXRoLmlzQWJzb2x1dGUob3B0cy5kaXIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUYXJnZXQgZGlyZWN0b3J5IGlzIGV4cGVjdGVkIHRvIGJlIGFic29sdXRlJylcbiAgfVxuXG4gIGF3YWl0IGZzLm1rZGlyKG9wdHMuZGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KVxuICBvcHRzLmRpciA9IGF3YWl0IGZzLnJlYWxwYXRoKG9wdHMuZGlyKVxuICByZXR1cm4gbmV3IEV4dHJhY3Rvcih6aXBQYXRoLCBvcHRzKS5leHRyYWN0KClcbn1cbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHtQYXNzVGhyb3VnaDogUGFzc1Rocm91Z2hTdHJlYW19ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gb3B0aW9ucyA9PiB7XG5cdG9wdGlvbnMgPSB7Li4ub3B0aW9uc307XG5cblx0Y29uc3Qge2FycmF5fSA9IG9wdGlvbnM7XG5cdGxldCB7ZW5jb2Rpbmd9ID0gb3B0aW9ucztcblx0Y29uc3QgaXNCdWZmZXIgPSBlbmNvZGluZyA9PT0gJ2J1ZmZlcic7XG5cdGxldCBvYmplY3RNb2RlID0gZmFsc2U7XG5cblx0aWYgKGFycmF5KSB7XG5cdFx0b2JqZWN0TW9kZSA9ICEoZW5jb2RpbmcgfHwgaXNCdWZmZXIpO1xuXHR9IGVsc2Uge1xuXHRcdGVuY29kaW5nID0gZW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXHR9XG5cblx0aWYgKGlzQnVmZmVyKSB7XG5cdFx0ZW5jb2RpbmcgPSBudWxsO1xuXHR9XG5cblx0Y29uc3Qgc3RyZWFtID0gbmV3IFBhc3NUaHJvdWdoU3RyZWFtKHtvYmplY3RNb2RlfSk7XG5cblx0aWYgKGVuY29kaW5nKSB7XG5cdFx0c3RyZWFtLnNldEVuY29kaW5nKGVuY29kaW5nKTtcblx0fVxuXG5cdGxldCBsZW5ndGggPSAwO1xuXHRjb25zdCBjaHVua3MgPSBbXTtcblxuXHRzdHJlYW0ub24oJ2RhdGEnLCBjaHVuayA9PiB7XG5cdFx0Y2h1bmtzLnB1c2goY2h1bmspO1xuXG5cdFx0aWYgKG9iamVjdE1vZGUpIHtcblx0XHRcdGxlbmd0aCA9IGNodW5rcy5sZW5ndGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxlbmd0aCArPSBjaHVuay5sZW5ndGg7XG5cdFx0fVxuXHR9KTtcblxuXHRzdHJlYW0uZ2V0QnVmZmVyZWRWYWx1ZSA9ICgpID0+IHtcblx0XHRpZiAoYXJyYXkpIHtcblx0XHRcdHJldHVybiBjaHVua3M7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGlzQnVmZmVyID8gQnVmZmVyLmNvbmNhdChjaHVua3MsIGxlbmd0aCkgOiBjaHVua3Muam9pbignJyk7XG5cdH07XG5cblx0c3RyZWFtLmdldEJ1ZmZlcmVkTGVuZ3RoID0gKCkgPT4gbGVuZ3RoO1xuXG5cdHJldHVybiBzdHJlYW07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3Qge2NvbnN0YW50czogQnVmZmVyQ29uc3RhbnRzfSA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xuY29uc3QgcHVtcCA9IHJlcXVpcmUoJ3B1bXAnKTtcbmNvbnN0IGJ1ZmZlclN0cmVhbSA9IHJlcXVpcmUoJy4vYnVmZmVyLXN0cmVhbScpO1xuXG5jbGFzcyBNYXhCdWZmZXJFcnJvciBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoJ21heEJ1ZmZlciBleGNlZWRlZCcpO1xuXHRcdHRoaXMubmFtZSA9ICdNYXhCdWZmZXJFcnJvcic7XG5cdH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0U3RyZWFtKGlucHV0U3RyZWFtLCBvcHRpb25zKSB7XG5cdGlmICghaW5wdXRTdHJlYW0pIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdFeHBlY3RlZCBhIHN0cmVhbScpKTtcblx0fVxuXG5cdG9wdGlvbnMgPSB7XG5cdFx0bWF4QnVmZmVyOiBJbmZpbml0eSxcblx0XHQuLi5vcHRpb25zXG5cdH07XG5cblx0Y29uc3Qge21heEJ1ZmZlcn0gPSBvcHRpb25zO1xuXG5cdGxldCBzdHJlYW07XG5cdGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRjb25zdCByZWplY3RQcm9taXNlID0gZXJyb3IgPT4ge1xuXHRcdFx0Ly8gRG9uJ3QgcmV0cmlldmUgYW4gb3ZlcnNpemVkIGJ1ZmZlci5cblx0XHRcdGlmIChlcnJvciAmJiBzdHJlYW0uZ2V0QnVmZmVyZWRMZW5ndGgoKSA8PSBCdWZmZXJDb25zdGFudHMuTUFYX0xFTkdUSCkge1xuXHRcdFx0XHRlcnJvci5idWZmZXJlZERhdGEgPSBzdHJlYW0uZ2V0QnVmZmVyZWRWYWx1ZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdH07XG5cblx0XHRzdHJlYW0gPSBwdW1wKGlucHV0U3RyZWFtLCBidWZmZXJTdHJlYW0ob3B0aW9ucyksIGVycm9yID0+IHtcblx0XHRcdGlmIChlcnJvcikge1xuXHRcdFx0XHRyZWplY3RQcm9taXNlKGVycm9yKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNvbHZlKCk7XG5cdFx0fSk7XG5cblx0XHRzdHJlYW0ub24oJ2RhdGEnLCAoKSA9PiB7XG5cdFx0XHRpZiAoc3RyZWFtLmdldEJ1ZmZlcmVkTGVuZ3RoKCkgPiBtYXhCdWZmZXIpIHtcblx0XHRcdFx0cmVqZWN0UHJvbWlzZShuZXcgTWF4QnVmZmVyRXJyb3IoKSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXG5cdHJldHVybiBzdHJlYW0uZ2V0QnVmZmVyZWRWYWx1ZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN0cmVhbTtcbi8vIFRPRE86IFJlbW92ZSB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0U3RyZWFtO1xubW9kdWxlLmV4cG9ydHMuYnVmZmVyID0gKHN0cmVhbSwgb3B0aW9ucykgPT4gZ2V0U3RyZWFtKHN0cmVhbSwgey4uLm9wdGlvbnMsIGVuY29kaW5nOiAnYnVmZmVyJ30pO1xubW9kdWxlLmV4cG9ydHMuYXJyYXkgPSAoc3RyZWFtLCBvcHRpb25zKSA9PiBnZXRTdHJlYW0oc3RyZWFtLCB7Li4ub3B0aW9ucywgYXJyYXk6IHRydWV9KTtcbm1vZHVsZS5leHBvcnRzLk1heEJ1ZmZlckVycm9yID0gTWF4QnVmZmVyRXJyb3I7XG4iLCJ2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG52YXIgUmVhZGFibGUgPSBzdHJlYW0uUmVhZGFibGU7XG52YXIgV3JpdGFibGUgPSBzdHJlYW0uV3JpdGFibGU7XG52YXIgUGFzc1Rocm91Z2ggPSBzdHJlYW0uUGFzc1Rocm91Z2g7XG52YXIgUGVuZCA9IHJlcXVpcmUoJ3BlbmQnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbmV4cG9ydHMuY3JlYXRlRnJvbUJ1ZmZlciA9IGNyZWF0ZUZyb21CdWZmZXI7XG5leHBvcnRzLmNyZWF0ZUZyb21GZCA9IGNyZWF0ZUZyb21GZDtcbmV4cG9ydHMuQnVmZmVyU2xpY2VyID0gQnVmZmVyU2xpY2VyO1xuZXhwb3J0cy5GZFNsaWNlciA9IEZkU2xpY2VyO1xuXG51dGlsLmluaGVyaXRzKEZkU2xpY2VyLCBFdmVudEVtaXR0ZXIpO1xuZnVuY3Rpb24gRmRTbGljZXIoZmQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuZmQgPSBmZDtcbiAgdGhpcy5wZW5kID0gbmV3IFBlbmQoKTtcbiAgdGhpcy5wZW5kLm1heCA9IDE7XG4gIHRoaXMucmVmQ291bnQgPSAwO1xuICB0aGlzLmF1dG9DbG9zZSA9ICEhb3B0aW9ucy5hdXRvQ2xvc2U7XG59XG5cbkZkU2xpY2VyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5wZW5kLmdvKGZ1bmN0aW9uKGNiKSB7XG4gICAgZnMucmVhZChzZWxmLmZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgZnVuY3Rpb24oZXJyLCBieXRlc1JlYWQsIGJ1ZmZlcikge1xuICAgICAgY2IoKTtcbiAgICAgIGNhbGxiYWNrKGVyciwgYnl0ZXNSZWFkLCBidWZmZXIpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbkZkU2xpY2VyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYucGVuZC5nbyhmdW5jdGlvbihjYikge1xuICAgIGZzLndyaXRlKHNlbGYuZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBmdW5jdGlvbihlcnIsIHdyaXR0ZW4sIGJ1ZmZlcikge1xuICAgICAgY2IoKTtcbiAgICAgIGNhbGxiYWNrKGVyciwgd3JpdHRlbiwgYnVmZmVyKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5GZFNsaWNlci5wcm90b3R5cGUuY3JlYXRlUmVhZFN0cmVhbSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBSZWFkU3RyZWFtKHRoaXMsIG9wdGlvbnMpO1xufTtcblxuRmRTbGljZXIucHJvdG90eXBlLmNyZWF0ZVdyaXRlU3RyZWFtID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICByZXR1cm4gbmV3IFdyaXRlU3RyZWFtKHRoaXMsIG9wdGlvbnMpO1xufTtcblxuRmRTbGljZXIucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlZkNvdW50ICs9IDE7XG59O1xuXG5GZFNsaWNlci5wcm90b3R5cGUudW5yZWYgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnJlZkNvdW50IC09IDE7XG5cbiAgaWYgKHNlbGYucmVmQ291bnQgPiAwKSByZXR1cm47XG4gIGlmIChzZWxmLnJlZkNvdW50IDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1bnJlZlwiKTtcblxuICBpZiAoc2VsZi5hdXRvQ2xvc2UpIHtcbiAgICBmcy5jbG9zZShzZWxmLmZkLCBvbkNsb3NlRG9uZSk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkNsb3NlRG9uZShlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5lbWl0KCdjbG9zZScpO1xuICAgIH1cbiAgfVxufTtcblxudXRpbC5pbmhlcml0cyhSZWFkU3RyZWFtLCBSZWFkYWJsZSk7XG5mdW5jdGlvbiBSZWFkU3RyZWFtKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5jb250ZXh0LnJlZigpO1xuXG4gIHRoaXMuc3RhcnQgPSBvcHRpb25zLnN0YXJ0IHx8IDA7XG4gIHRoaXMuZW5kT2Zmc2V0ID0gb3B0aW9ucy5lbmQ7XG4gIHRoaXMucG9zID0gdGhpcy5zdGFydDtcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbn1cblxuUmVhZFN0cmVhbS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm47XG5cbiAgdmFyIHRvUmVhZCA9IE1hdGgubWluKHNlbGYuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaywgbik7XG4gIGlmIChzZWxmLmVuZE9mZnNldCAhPSBudWxsKSB7XG4gICAgdG9SZWFkID0gTWF0aC5taW4odG9SZWFkLCBzZWxmLmVuZE9mZnNldCAtIHNlbGYucG9zKTtcbiAgfVxuICBpZiAodG9SZWFkIDw9IDApIHtcbiAgICBzZWxmLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgc2VsZi5wdXNoKG51bGwpO1xuICAgIHNlbGYuY29udGV4dC51bnJlZigpO1xuICAgIHJldHVybjtcbiAgfVxuICBzZWxmLmNvbnRleHQucGVuZC5nbyhmdW5jdGlvbihjYikge1xuICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuIGNiKCk7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIodG9SZWFkKTtcbiAgICBmcy5yZWFkKHNlbGYuY29udGV4dC5mZCwgYnVmZmVyLCAwLCB0b1JlYWQsIHNlbGYucG9zLCBmdW5jdGlvbihlcnIsIGJ5dGVzUmVhZCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBzZWxmLmRlc3Ryb3koZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoYnl0ZXNSZWFkID09PSAwKSB7XG4gICAgICAgIHNlbGYuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5wdXNoKG51bGwpO1xuICAgICAgICBzZWxmLmNvbnRleHQudW5yZWYoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYucG9zICs9IGJ5dGVzUmVhZDtcbiAgICAgICAgc2VsZi5wdXNoKGJ1ZmZlci5zbGljZSgwLCBieXRlc1JlYWQpKTtcbiAgICAgIH1cbiAgICAgIGNiKCk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuUmVhZFN0cmVhbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKGVycikge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVybjtcbiAgZXJyID0gZXJyIHx8IG5ldyBFcnJvcihcInN0cmVhbSBkZXN0cm95ZWRcIik7XG4gIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHRoaXMuY29udGV4dC51bnJlZigpO1xufTtcblxudXRpbC5pbmhlcml0cyhXcml0ZVN0cmVhbSwgV3JpdGFibGUpO1xuZnVuY3Rpb24gV3JpdGVTdHJlYW0oY29udGV4dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmNvbnRleHQucmVmKCk7XG5cbiAgdGhpcy5zdGFydCA9IG9wdGlvbnMuc3RhcnQgfHwgMDtcbiAgdGhpcy5lbmRPZmZzZXQgPSAob3B0aW9ucy5lbmQgPT0gbnVsbCkgPyBJbmZpbml0eSA6ICtvcHRpb25zLmVuZDtcbiAgdGhpcy5ieXRlc1dyaXR0ZW4gPSAwO1xuICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQ7XG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgdGhpcy5vbignZmluaXNoJywgdGhpcy5kZXN0cm95LmJpbmQodGhpcykpO1xufVxuXG5Xcml0ZVN0cmVhbS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oYnVmZmVyLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVybjtcblxuICBpZiAoc2VsZi5wb3MgKyBidWZmZXIubGVuZ3RoID4gc2VsZi5lbmRPZmZzZXQpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKFwibWF4aW11bSBmaWxlIGxlbmd0aCBleGNlZWRlZFwiKTtcbiAgICBlcnIuY29kZSA9ICdFVE9PQklHJztcbiAgICBzZWxmLmRlc3Ryb3koKTtcbiAgICBjYWxsYmFjayhlcnIpO1xuICAgIHJldHVybjtcbiAgfVxuICBzZWxmLmNvbnRleHQucGVuZC5nbyhmdW5jdGlvbihjYikge1xuICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuIGNiKCk7XG4gICAgZnMud3JpdGUoc2VsZi5jb250ZXh0LmZkLCBidWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGgsIHNlbGYucG9zLCBmdW5jdGlvbihlcnIsIGJ5dGVzKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHNlbGYuZGVzdHJveSgpO1xuICAgICAgICBjYigpO1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5ieXRlc1dyaXR0ZW4gKz0gYnl0ZXM7XG4gICAgICAgIHNlbGYucG9zICs9IGJ5dGVzO1xuICAgICAgICBzZWxmLmVtaXQoJ3Byb2dyZXNzJyk7XG4gICAgICAgIGNiKCk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuV3JpdGVTdHJlYW0ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm47XG4gIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgdGhpcy5jb250ZXh0LnVucmVmKCk7XG59O1xuXG51dGlsLmluaGVyaXRzKEJ1ZmZlclNsaWNlciwgRXZlbnRFbWl0dGVyKTtcbmZ1bmN0aW9uIEJ1ZmZlclNsaWNlcihidWZmZXIsIG9wdGlvbnMpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMucmVmQ291bnQgPSAwO1xuICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgdGhpcy5tYXhDaHVua1NpemUgPSBvcHRpb25zLm1heENodW5rU2l6ZSB8fCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuQnVmZmVyU2xpY2VyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKSB7XG4gIHZhciBlbmQgPSBwb3NpdGlvbiArIGxlbmd0aDtcbiAgdmFyIGRlbHRhID0gZW5kIC0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICB2YXIgd3JpdHRlbiA9IChkZWx0YSA+IDApID8gZGVsdGEgOiBsZW5ndGg7XG4gIHRoaXMuYnVmZmVyLmNvcHkoYnVmZmVyLCBvZmZzZXQsIHBvc2l0aW9uLCBlbmQpO1xuICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgY2FsbGJhY2sobnVsbCwgd3JpdHRlbik7XG4gIH0pO1xufTtcblxuQnVmZmVyU2xpY2VyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaykge1xuICBidWZmZXIuY29weSh0aGlzLmJ1ZmZlciwgcG9zaXRpb24sIG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgIGNhbGxiYWNrKG51bGwsIGxlbmd0aCwgYnVmZmVyKTtcbiAgfSk7XG59O1xuXG5CdWZmZXJTbGljZXIucHJvdG90eXBlLmNyZWF0ZVJlYWRTdHJlYW0gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcmVhZFN0cmVhbSA9IG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcbiAgcmVhZFN0cmVhbS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgcmVhZFN0cmVhbS5zdGFydCA9IG9wdGlvbnMuc3RhcnQgfHwgMDtcbiAgcmVhZFN0cmVhbS5lbmRPZmZzZXQgPSBvcHRpb25zLmVuZDtcbiAgLy8gYnkgdGhlIHRpbWUgdGhpcyBmdW5jdGlvbiByZXR1cm5zLCB3ZSdsbCBiZSBkb25lLlxuICByZWFkU3RyZWFtLnBvcyA9IHJlYWRTdHJlYW0uZW5kT2Zmc2V0IHx8IHRoaXMuYnVmZmVyLmxlbmd0aDtcblxuICAvLyByZXNwZWN0IHRoZSBtYXhDaHVua1NpemUgb3B0aW9uIHRvIHNsaWNlIHVwIHRoZSBjaHVuayBpbnRvIHNtYWxsZXIgcGllY2VzLlxuICB2YXIgZW50aXJlU2xpY2UgPSB0aGlzLmJ1ZmZlci5zbGljZShyZWFkU3RyZWFtLnN0YXJ0LCByZWFkU3RyZWFtLnBvcyk7XG4gIHZhciBvZmZzZXQgPSAwO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBuZXh0T2Zmc2V0ID0gb2Zmc2V0ICsgdGhpcy5tYXhDaHVua1NpemU7XG4gICAgaWYgKG5leHRPZmZzZXQgPj0gZW50aXJlU2xpY2UubGVuZ3RoKSB7XG4gICAgICAvLyBsYXN0IGNodW5rXG4gICAgICBpZiAob2Zmc2V0IDwgZW50aXJlU2xpY2UubGVuZ3RoKSB7XG4gICAgICAgIHJlYWRTdHJlYW0ud3JpdGUoZW50aXJlU2xpY2Uuc2xpY2Uob2Zmc2V0LCBlbnRpcmVTbGljZS5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZWFkU3RyZWFtLndyaXRlKGVudGlyZVNsaWNlLnNsaWNlKG9mZnNldCwgbmV4dE9mZnNldCkpO1xuICAgIG9mZnNldCA9IG5leHRPZmZzZXQ7XG4gIH1cblxuICByZWFkU3RyZWFtLmVuZCgpO1xuICByZWFkU3RyZWFtLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICByZWFkU3RyZWFtLmRlc3Ryb3llZCA9IHRydWU7XG4gIH07XG4gIHJldHVybiByZWFkU3RyZWFtO1xufTtcblxuQnVmZmVyU2xpY2VyLnByb3RvdHlwZS5jcmVhdGVXcml0ZVN0cmVhbSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIGJ1ZmZlclNsaWNlciA9IHRoaXM7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgd3JpdGVTdHJlYW0gPSBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIHdyaXRlU3RyZWFtLnN0YXJ0ID0gb3B0aW9ucy5zdGFydCB8fCAwO1xuICB3cml0ZVN0cmVhbS5lbmRPZmZzZXQgPSAob3B0aW9ucy5lbmQgPT0gbnVsbCkgPyB0aGlzLmJ1ZmZlci5sZW5ndGggOiArb3B0aW9ucy5lbmQ7XG4gIHdyaXRlU3RyZWFtLmJ5dGVzV3JpdHRlbiA9IDA7XG4gIHdyaXRlU3RyZWFtLnBvcyA9IHdyaXRlU3RyZWFtLnN0YXJ0O1xuICB3cml0ZVN0cmVhbS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgd3JpdGVTdHJlYW0uX3dyaXRlID0gZnVuY3Rpb24oYnVmZmVyLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICBpZiAod3JpdGVTdHJlYW0uZGVzdHJveWVkKSByZXR1cm47XG5cbiAgICB2YXIgZW5kID0gd3JpdGVTdHJlYW0ucG9zICsgYnVmZmVyLmxlbmd0aDtcbiAgICBpZiAoZW5kID4gd3JpdGVTdHJlYW0uZW5kT2Zmc2V0KSB7XG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKFwibWF4aW11bSBmaWxlIGxlbmd0aCBleGNlZWRlZFwiKTtcbiAgICAgIGVyci5jb2RlID0gJ0VUT09CSUcnO1xuICAgICAgd3JpdGVTdHJlYW0uZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGJ1ZmZlci5jb3B5KGJ1ZmZlclNsaWNlci5idWZmZXIsIHdyaXRlU3RyZWFtLnBvcywgMCwgYnVmZmVyLmxlbmd0aCk7XG5cbiAgICB3cml0ZVN0cmVhbS5ieXRlc1dyaXR0ZW4gKz0gYnVmZmVyLmxlbmd0aDtcbiAgICB3cml0ZVN0cmVhbS5wb3MgPSBlbmQ7XG4gICAgd3JpdGVTdHJlYW0uZW1pdCgncHJvZ3Jlc3MnKTtcbiAgICBjYWxsYmFjaygpO1xuICB9O1xuICB3cml0ZVN0cmVhbS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgd3JpdGVTdHJlYW0uZGVzdHJveWVkID0gdHJ1ZTtcbiAgfTtcbiAgcmV0dXJuIHdyaXRlU3RyZWFtO1xufTtcblxuQnVmZmVyU2xpY2VyLnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZWZDb3VudCArPSAxO1xufTtcblxuQnVmZmVyU2xpY2VyLnByb3RvdHlwZS51bnJlZiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlZkNvdW50IC09IDE7XG5cbiAgaWYgKHRoaXMucmVmQ291bnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1bnJlZlwiKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY3JlYXRlRnJvbUJ1ZmZlcihidWZmZXIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBCdWZmZXJTbGljZXIoYnVmZmVyLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRnJvbUZkKGZkLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgRmRTbGljZXIoZmQsIG9wdGlvbnMpO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBQZW5kO1xuXG5mdW5jdGlvbiBQZW5kKCkge1xuICB0aGlzLnBlbmRpbmcgPSAwO1xuICB0aGlzLm1heCA9IEluZmluaXR5O1xuICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICB0aGlzLndhaXRpbmcgPSBbXTtcbiAgdGhpcy5lcnJvciA9IG51bGw7XG59XG5cblBlbmQucHJvdG90eXBlLmdvID0gZnVuY3Rpb24oZm4pIHtcbiAgaWYgKHRoaXMucGVuZGluZyA8IHRoaXMubWF4KSB7XG4gICAgcGVuZEdvKHRoaXMsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhaXRpbmcucHVzaChmbik7XG4gIH1cbn07XG5cblBlbmQucHJvdG90eXBlLndhaXQgPSBmdW5jdGlvbihjYikge1xuICBpZiAodGhpcy5wZW5kaW5nID09PSAwKSB7XG4gICAgY2IodGhpcy5lcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5saXN0ZW5lcnMucHVzaChjYik7XG4gIH1cbn07XG5cblBlbmQucHJvdG90eXBlLmhvbGQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHBlbmRIb2xkKHRoaXMpO1xufTtcblxuZnVuY3Rpb24gcGVuZEhvbGQoc2VsZikge1xuICBzZWxmLnBlbmRpbmcgKz0gMTtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gb25DYjtcbiAgZnVuY3Rpb24gb25DYihlcnIpIHtcbiAgICBpZiAoY2FsbGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJjYWxsYmFjayBjYWxsZWQgdHdpY2VcIik7XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBzZWxmLmVycm9yID0gc2VsZi5lcnJvciB8fCBlcnI7XG4gICAgc2VsZi5wZW5kaW5nIC09IDE7XG4gICAgaWYgKHNlbGYud2FpdGluZy5sZW5ndGggPiAwICYmIHNlbGYucGVuZGluZyA8IHNlbGYubWF4KSB7XG4gICAgICBwZW5kR28oc2VsZiwgc2VsZi53YWl0aW5nLnNoaWZ0KCkpO1xuICAgIH0gZWxzZSBpZiAoc2VsZi5wZW5kaW5nID09PSAwKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gc2VsZi5saXN0ZW5lcnM7XG4gICAgICBzZWxmLmxpc3RlbmVycyA9IFtdO1xuICAgICAgbGlzdGVuZXJzLmZvckVhY2goY2JMaXN0ZW5lcik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNiTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICBsaXN0ZW5lcihzZWxmLmVycm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwZW5kR28oc2VsZiwgZm4pIHtcbiAgZm4ocGVuZEhvbGQoc2VsZikpO1xufVxuIiwidmFyIG9uY2UgPSByZXF1aXJlKCdvbmNlJylcbnZhciBlb3MgPSByZXF1aXJlKCdlbmQtb2Ytc3RyZWFtJylcbnZhciBmc1xuXG50cnkge1xuICBmcyA9IHJlcXVpcmUoJ2ZzJykgLy8gd2Ugb25seSBuZWVkIGZzIHRvIGdldCB0aGUgUmVhZFN0cmVhbSBhbmQgV3JpdGVTdHJlYW0gcHJvdG90eXBlc1xufSBjYXRjaCAoZSkge31cblxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxudmFyIGFuY2llbnQgPSB0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgPyBmYWxzZSA6IC9edj9cXC4wLy50ZXN0KHByb2Nlc3MudmVyc2lvbilcblxudmFyIGlzRm4gPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG52YXIgaXNGUyA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgaWYgKCFhbmNpZW50KSByZXR1cm4gZmFsc2UgLy8gbmV3ZXIgbm9kZSB2ZXJzaW9uIGRvIG5vdCBuZWVkIHRvIGNhcmUgYWJvdXQgZnMgaXMgYSBzcGVjaWFsIHdheVxuICBpZiAoIWZzKSByZXR1cm4gZmFsc2UgLy8gYnJvd3NlclxuICByZXR1cm4gKHN0cmVhbSBpbnN0YW5jZW9mIChmcy5SZWFkU3RyZWFtIHx8IG5vb3ApIHx8IHN0cmVhbSBpbnN0YW5jZW9mIChmcy5Xcml0ZVN0cmVhbSB8fCBub29wKSkgJiYgaXNGbihzdHJlYW0uY2xvc2UpXG59XG5cbnZhciBpc1JlcXVlc3QgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIGlzRm4oc3RyZWFtLmFib3J0KVxufVxuXG52YXIgZGVzdHJveWVyID0gZnVuY3Rpb24gKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKVxuXG4gIHZhciBjbG9zZWQgPSBmYWxzZVxuICBzdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGNsb3NlZCA9IHRydWVcbiAgfSlcblxuICBlb3Moc3RyZWFtLCB7cmVhZGFibGU6IHJlYWRpbmcsIHdyaXRhYmxlOiB3cml0aW5nfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgY2xvc2VkID0gdHJ1ZVxuICAgIGNhbGxiYWNrKClcbiAgfSlcblxuICB2YXIgZGVzdHJveWVkID0gZmFsc2VcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoY2xvc2VkKSByZXR1cm5cbiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm5cbiAgICBkZXN0cm95ZWQgPSB0cnVlXG5cbiAgICBpZiAoaXNGUyhzdHJlYW0pKSByZXR1cm4gc3RyZWFtLmNsb3NlKG5vb3ApIC8vIHVzZSBjbG9zZSBmb3IgZnMgc3RyZWFtcyB0byBhdm9pZCBmZCBsZWFrc1xuICAgIGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkgcmV0dXJuIHN0cmVhbS5hYm9ydCgpIC8vIHJlcXVlc3QuZGVzdHJveSBqdXN0IGRvIC5lbmQgLSAuYWJvcnQgaXMgd2hhdCB3ZSB3YW50XG5cbiAgICBpZiAoaXNGbihzdHJlYW0uZGVzdHJveSkpIHJldHVybiBzdHJlYW0uZGVzdHJveSgpXG5cbiAgICBjYWxsYmFjayhlcnIgfHwgbmV3IEVycm9yKCdzdHJlYW0gd2FzIGRlc3Ryb3llZCcpKVxuICB9XG59XG5cbnZhciBjYWxsID0gZnVuY3Rpb24gKGZuKSB7XG4gIGZuKClcbn1cblxudmFyIHBpcGUgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgcmV0dXJuIGZyb20ucGlwZSh0bylcbn1cblxudmFyIHB1bXAgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdHJlYW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICB2YXIgY2FsbGJhY2sgPSBpc0ZuKHN0cmVhbXNbc3RyZWFtcy5sZW5ndGggLSAxXSB8fCBub29wKSAmJiBzdHJlYW1zLnBvcCgpIHx8IG5vb3BcblxuICBpZiAoQXJyYXkuaXNBcnJheShzdHJlYW1zWzBdKSkgc3RyZWFtcyA9IHN0cmVhbXNbMF1cbiAgaWYgKHN0cmVhbXMubGVuZ3RoIDwgMikgdGhyb3cgbmV3IEVycm9yKCdwdW1wIHJlcXVpcmVzIHR3byBzdHJlYW1zIHBlciBtaW5pbXVtJylcblxuICB2YXIgZXJyb3JcbiAgdmFyIGRlc3Ryb3lzID0gc3RyZWFtcy5tYXAoZnVuY3Rpb24gKHN0cmVhbSwgaSkge1xuICAgIHZhciByZWFkaW5nID0gaSA8IHN0cmVhbXMubGVuZ3RoIC0gMVxuICAgIHZhciB3cml0aW5nID0gaSA+IDBcbiAgICByZXR1cm4gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKCFlcnJvcikgZXJyb3IgPSBlcnJcbiAgICAgIGlmIChlcnIpIGRlc3Ryb3lzLmZvckVhY2goY2FsbClcbiAgICAgIGlmIChyZWFkaW5nKSByZXR1cm5cbiAgICAgIGRlc3Ryb3lzLmZvckVhY2goY2FsbClcbiAgICAgIGNhbGxiYWNrKGVycm9yKVxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIHN0cmVhbXMucmVkdWNlKHBpcGUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHVtcFxuIiwidmFyIGZzID0gcmVxdWlyZShcImZzXCIpO1xudmFyIHpsaWIgPSByZXF1aXJlKFwiemxpYlwiKTtcbnZhciBmZF9zbGljZXIgPSByZXF1aXJlKFwiZmQtc2xpY2VyXCIpO1xudmFyIGNyYzMyID0gcmVxdWlyZShcImJ1ZmZlci1jcmMzMlwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcImV2ZW50c1wiKS5FdmVudEVtaXR0ZXI7XG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZShcInN0cmVhbVwiKS5UcmFuc2Zvcm07XG52YXIgUGFzc1Rocm91Z2ggPSByZXF1aXJlKFwic3RyZWFtXCIpLlBhc3NUaHJvdWdoO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZShcInN0cmVhbVwiKS5Xcml0YWJsZTtcblxuZXhwb3J0cy5vcGVuID0gb3BlbjtcbmV4cG9ydHMuZnJvbUZkID0gZnJvbUZkO1xuZXhwb3J0cy5mcm9tQnVmZmVyID0gZnJvbUJ1ZmZlcjtcbmV4cG9ydHMuZnJvbVJhbmRvbUFjY2Vzc1JlYWRlciA9IGZyb21SYW5kb21BY2Nlc3NSZWFkZXI7XG5leHBvcnRzLmRvc0RhdGVUaW1lVG9EYXRlID0gZG9zRGF0ZVRpbWVUb0RhdGU7XG5leHBvcnRzLnZhbGlkYXRlRmlsZU5hbWUgPSB2YWxpZGF0ZUZpbGVOYW1lO1xuZXhwb3J0cy5aaXBGaWxlID0gWmlwRmlsZTtcbmV4cG9ydHMuRW50cnkgPSBFbnRyeTtcbmV4cG9ydHMuUmFuZG9tQWNjZXNzUmVhZGVyID0gUmFuZG9tQWNjZXNzUmVhZGVyO1xuXG5mdW5jdGlvbiBvcGVuKHBhdGgsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG4gIGlmIChvcHRpb25zID09IG51bGwpIG9wdGlvbnMgPSB7fTtcbiAgaWYgKG9wdGlvbnMuYXV0b0Nsb3NlID09IG51bGwpIG9wdGlvbnMuYXV0b0Nsb3NlID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMubGF6eUVudHJpZXMgPT0gbnVsbCkgb3B0aW9ucy5sYXp5RW50cmllcyA9IGZhbHNlO1xuICBpZiAob3B0aW9ucy5kZWNvZGVTdHJpbmdzID09IG51bGwpIG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9IHRydWU7XG4gIGlmIChvcHRpb25zLnZhbGlkYXRlRW50cnlTaXplcyA9PSBudWxsKSBvcHRpb25zLnZhbGlkYXRlRW50cnlTaXplcyA9IHRydWU7XG4gIGlmIChvcHRpb25zLnN0cmljdEZpbGVOYW1lcyA9PSBudWxsKSBvcHRpb25zLnN0cmljdEZpbGVOYW1lcyA9IGZhbHNlO1xuICBpZiAoY2FsbGJhY2sgPT0gbnVsbCkgY2FsbGJhY2sgPSBkZWZhdWx0Q2FsbGJhY2s7XG4gIGZzLm9wZW4ocGF0aCwgXCJyXCIsIGZ1bmN0aW9uKGVyciwgZmQpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICBmcm9tRmQoZmQsIG9wdGlvbnMsIGZ1bmN0aW9uKGVyciwgemlwZmlsZSkge1xuICAgICAgaWYgKGVycikgZnMuY2xvc2UoZmQsIGRlZmF1bHRDYWxsYmFjayk7XG4gICAgICBjYWxsYmFjayhlcnIsIHppcGZpbGUpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZnJvbUZkKGZkLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBpZiAob3B0aW9ucyA9PSBudWxsKSBvcHRpb25zID0ge307XG4gIGlmIChvcHRpb25zLmF1dG9DbG9zZSA9PSBudWxsKSBvcHRpb25zLmF1dG9DbG9zZSA9IGZhbHNlO1xuICBpZiAob3B0aW9ucy5sYXp5RW50cmllcyA9PSBudWxsKSBvcHRpb25zLmxhenlFbnRyaWVzID0gZmFsc2U7XG4gIGlmIChvcHRpb25zLmRlY29kZVN0cmluZ3MgPT0gbnVsbCkgb3B0aW9ucy5kZWNvZGVTdHJpbmdzID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMudmFsaWRhdGVFbnRyeVNpemVzID09IG51bGwpIG9wdGlvbnMudmFsaWRhdGVFbnRyeVNpemVzID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMuc3RyaWN0RmlsZU5hbWVzID09IG51bGwpIG9wdGlvbnMuc3RyaWN0RmlsZU5hbWVzID0gZmFsc2U7XG4gIGlmIChjYWxsYmFjayA9PSBudWxsKSBjYWxsYmFjayA9IGRlZmF1bHRDYWxsYmFjaztcbiAgZnMuZnN0YXQoZmQsIGZ1bmN0aW9uKGVyciwgc3RhdHMpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB2YXIgcmVhZGVyID0gZmRfc2xpY2VyLmNyZWF0ZUZyb21GZChmZCwge2F1dG9DbG9zZTogdHJ1ZX0pO1xuICAgIGZyb21SYW5kb21BY2Nlc3NSZWFkZXIocmVhZGVyLCBzdGF0cy5zaXplLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBmcm9tQnVmZmVyKGJ1ZmZlciwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCkgb3B0aW9ucyA9IHt9O1xuICBvcHRpb25zLmF1dG9DbG9zZSA9IGZhbHNlO1xuICBpZiAob3B0aW9ucy5sYXp5RW50cmllcyA9PSBudWxsKSBvcHRpb25zLmxhenlFbnRyaWVzID0gZmFsc2U7XG4gIGlmIChvcHRpb25zLmRlY29kZVN0cmluZ3MgPT0gbnVsbCkgb3B0aW9ucy5kZWNvZGVTdHJpbmdzID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMudmFsaWRhdGVFbnRyeVNpemVzID09IG51bGwpIG9wdGlvbnMudmFsaWRhdGVFbnRyeVNpemVzID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMuc3RyaWN0RmlsZU5hbWVzID09IG51bGwpIG9wdGlvbnMuc3RyaWN0RmlsZU5hbWVzID0gZmFsc2U7XG4gIC8vIGxpbWl0IHRoZSBtYXggY2h1bmsgc2l6ZS4gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVqb3Nod29sZmUveWF1emwvaXNzdWVzLzg3XG4gIHZhciByZWFkZXIgPSBmZF9zbGljZXIuY3JlYXRlRnJvbUJ1ZmZlcihidWZmZXIsIHttYXhDaHVua1NpemU6IDB4MTAwMDB9KTtcbiAgZnJvbVJhbmRvbUFjY2Vzc1JlYWRlcihyZWFkZXIsIGJ1ZmZlci5sZW5ndGgsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZnJvbVJhbmRvbUFjY2Vzc1JlYWRlcihyZWFkZXIsIHRvdGFsU2l6ZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCkgb3B0aW9ucyA9IHt9O1xuICBpZiAob3B0aW9ucy5hdXRvQ2xvc2UgPT0gbnVsbCkgb3B0aW9ucy5hdXRvQ2xvc2UgPSB0cnVlO1xuICBpZiAob3B0aW9ucy5sYXp5RW50cmllcyA9PSBudWxsKSBvcHRpb25zLmxhenlFbnRyaWVzID0gZmFsc2U7XG4gIGlmIChvcHRpb25zLmRlY29kZVN0cmluZ3MgPT0gbnVsbCkgb3B0aW9ucy5kZWNvZGVTdHJpbmdzID0gdHJ1ZTtcbiAgdmFyIGRlY29kZVN0cmluZ3MgPSAhIW9wdGlvbnMuZGVjb2RlU3RyaW5ncztcbiAgaWYgKG9wdGlvbnMudmFsaWRhdGVFbnRyeVNpemVzID09IG51bGwpIG9wdGlvbnMudmFsaWRhdGVFbnRyeVNpemVzID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMuc3RyaWN0RmlsZU5hbWVzID09IG51bGwpIG9wdGlvbnMuc3RyaWN0RmlsZU5hbWVzID0gZmFsc2U7XG4gIGlmIChjYWxsYmFjayA9PSBudWxsKSBjYWxsYmFjayA9IGRlZmF1bHRDYWxsYmFjaztcbiAgaWYgKHR5cGVvZiB0b3RhbFNpemUgIT09IFwibnVtYmVyXCIpIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIHRvdGFsU2l6ZSBwYXJhbWV0ZXIgdG8gYmUgYSBudW1iZXJcIik7XG4gIGlmICh0b3RhbFNpemUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgIHRocm93IG5ldyBFcnJvcihcInppcCBmaWxlIHRvbyBsYXJnZS4gb25seSBmaWxlIHNpemVzIHVwIHRvIDJeNTIgYXJlIHN1cHBvcnRlZCBkdWUgdG8gSmF2YVNjcmlwdCdzIE51bWJlciB0eXBlIGJlaW5nIGFuIElFRUUgNzU0IGRvdWJsZS5cIik7XG4gIH1cblxuICAvLyB0aGUgbWF0Y2hpbmcgdW5yZWYoKSBjYWxsIGlzIGluIHppcGZpbGUuY2xvc2UoKVxuICByZWFkZXIucmVmKCk7XG5cbiAgLy8gZW9jZHIgbWVhbnMgRW5kIG9mIENlbnRyYWwgRGlyZWN0b3J5IFJlY29yZC5cbiAgLy8gc2VhcmNoIGJhY2t3YXJkcyBmb3IgdGhlIGVvY2RyIHNpZ25hdHVyZS5cbiAgLy8gdGhlIGxhc3QgZmllbGQgb2YgdGhlIGVvY2RyIGlzIGEgdmFyaWFibGUtbGVuZ3RoIGNvbW1lbnQuXG4gIC8vIHRoZSBjb21tZW50IHNpemUgaXMgZW5jb2RlZCBpbiBhIDItYnl0ZSBmaWVsZCBpbiB0aGUgZW9jZHIsIHdoaWNoIHdlIGNhbid0IGZpbmQgd2l0aG91dCB0cnVkZ2luZyBiYWNrd2FyZHMgdGhyb3VnaCB0aGUgY29tbWVudCB0byBmaW5kIGl0LlxuICAvLyBhcyBhIGNvbnNlcXVlbmNlIG9mIHRoaXMgZGVzaWduIGRlY2lzaW9uLCBpdCdzIHBvc3NpYmxlIHRvIGhhdmUgYW1iaWd1b3VzIHppcCBmaWxlIG1ldGFkYXRhIGlmIGEgY29oZXJlbnQgZW9jZHIgd2FzIGluIHRoZSBjb21tZW50LlxuICAvLyB3ZSBzZWFyY2ggYmFja3dhcmRzIGZvciBhIGVvY2RyIHNpZ25hdHVyZSwgYW5kIGhvcGUgdGhhdCB3aG9ldmVyIG1hZGUgdGhlIHppcCBmaWxlIHdhcyBzbWFydCBlbm91Z2ggdG8gZm9yYmlkIHRoZSBlb2NkciBzaWduYXR1cmUgaW4gdGhlIGNvbW1lbnQuXG4gIHZhciBlb2NkcldpdGhvdXRDb21tZW50U2l6ZSA9IDIyO1xuICB2YXIgbWF4Q29tbWVudFNpemUgPSAweGZmZmY7IC8vIDItYnl0ZSBzaXplXG4gIHZhciBidWZmZXJTaXplID0gTWF0aC5taW4oZW9jZHJXaXRob3V0Q29tbWVudFNpemUgKyBtYXhDb21tZW50U2l6ZSwgdG90YWxTaXplKTtcbiAgdmFyIGJ1ZmZlciA9IG5ld0J1ZmZlcihidWZmZXJTaXplKTtcbiAgdmFyIGJ1ZmZlclJlYWRTdGFydCA9IHRvdGFsU2l6ZSAtIGJ1ZmZlci5sZW5ndGg7XG4gIHJlYWRBbmRBc3NlcnROb0VvZihyZWFkZXIsIGJ1ZmZlciwgMCwgYnVmZmVyU2l6ZSwgYnVmZmVyUmVhZFN0YXJ0LCBmdW5jdGlvbihlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICBmb3IgKHZhciBpID0gYnVmZmVyU2l6ZSAtIGVvY2RyV2l0aG91dENvbW1lbnRTaXplOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKGJ1ZmZlci5yZWFkVUludDMyTEUoaSkgIT09IDB4MDYwNTRiNTApIGNvbnRpbnVlO1xuICAgICAgLy8gZm91bmQgZW9jZHJcbiAgICAgIHZhciBlb2NkckJ1ZmZlciA9IGJ1ZmZlci5zbGljZShpKTtcblxuICAgICAgLy8gMCAtIEVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSBzaWduYXR1cmUgPSAweDA2MDU0YjUwXG4gICAgICAvLyA0IC0gTnVtYmVyIG9mIHRoaXMgZGlza1xuICAgICAgdmFyIGRpc2tOdW1iZXIgPSBlb2NkckJ1ZmZlci5yZWFkVUludDE2TEUoNCk7XG4gICAgICBpZiAoZGlza051bWJlciAhPT0gMCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKFwibXVsdGktZGlzayB6aXAgZmlsZXMgYXJlIG5vdCBzdXBwb3J0ZWQ6IGZvdW5kIGRpc2sgbnVtYmVyOiBcIiArIGRpc2tOdW1iZXIpKTtcbiAgICAgIH1cbiAgICAgIC8vIDYgLSBEaXNrIHdoZXJlIGNlbnRyYWwgZGlyZWN0b3J5IHN0YXJ0c1xuICAgICAgLy8gOCAtIE51bWJlciBvZiBjZW50cmFsIGRpcmVjdG9yeSByZWNvcmRzIG9uIHRoaXMgZGlza1xuICAgICAgLy8gMTAgLSBUb3RhbCBudW1iZXIgb2YgY2VudHJhbCBkaXJlY3RvcnkgcmVjb3Jkc1xuICAgICAgdmFyIGVudHJ5Q291bnQgPSBlb2NkckJ1ZmZlci5yZWFkVUludDE2TEUoMTApO1xuICAgICAgLy8gMTIgLSBTaXplIG9mIGNlbnRyYWwgZGlyZWN0b3J5IChieXRlcylcbiAgICAgIC8vIDE2IC0gT2Zmc2V0IG9mIHN0YXJ0IG9mIGNlbnRyYWwgZGlyZWN0b3J5LCByZWxhdGl2ZSB0byBzdGFydCBvZiBhcmNoaXZlXG4gICAgICB2YXIgY2VudHJhbERpcmVjdG9yeU9mZnNldCA9IGVvY2RyQnVmZmVyLnJlYWRVSW50MzJMRSgxNik7XG4gICAgICAvLyAyMCAtIENvbW1lbnQgbGVuZ3RoXG4gICAgICB2YXIgY29tbWVudExlbmd0aCA9IGVvY2RyQnVmZmVyLnJlYWRVSW50MTZMRSgyMCk7XG4gICAgICB2YXIgZXhwZWN0ZWRDb21tZW50TGVuZ3RoID0gZW9jZHJCdWZmZXIubGVuZ3RoIC0gZW9jZHJXaXRob3V0Q29tbWVudFNpemU7XG4gICAgICBpZiAoY29tbWVudExlbmd0aCAhPT0gZXhwZWN0ZWRDb21tZW50TGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoXCJpbnZhbGlkIGNvbW1lbnQgbGVuZ3RoLiBleHBlY3RlZDogXCIgKyBleHBlY3RlZENvbW1lbnRMZW5ndGggKyBcIi4gZm91bmQ6IFwiICsgY29tbWVudExlbmd0aCkpO1xuICAgICAgfVxuICAgICAgLy8gMjIgLSBDb21tZW50XG4gICAgICAvLyB0aGUgZW5jb2RpbmcgaXMgYWx3YXlzIGNwNDM3LlxuICAgICAgdmFyIGNvbW1lbnQgPSBkZWNvZGVTdHJpbmdzID8gZGVjb2RlQnVmZmVyKGVvY2RyQnVmZmVyLCAyMiwgZW9jZHJCdWZmZXIubGVuZ3RoLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGVvY2RyQnVmZmVyLnNsaWNlKDIyKTtcblxuICAgICAgaWYgKCEoZW50cnlDb3VudCA9PT0gMHhmZmZmIHx8IGNlbnRyYWxEaXJlY3RvcnlPZmZzZXQgPT09IDB4ZmZmZmZmZmYpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBuZXcgWmlwRmlsZShyZWFkZXIsIGNlbnRyYWxEaXJlY3RvcnlPZmZzZXQsIHRvdGFsU2l6ZSwgZW50cnlDb3VudCwgY29tbWVudCwgb3B0aW9ucy5hdXRvQ2xvc2UsIG9wdGlvbnMubGF6eUVudHJpZXMsIGRlY29kZVN0cmluZ3MsIG9wdGlvbnMudmFsaWRhdGVFbnRyeVNpemVzLCBvcHRpb25zLnN0cmljdEZpbGVOYW1lcykpO1xuICAgICAgfVxuXG4gICAgICAvLyBaSVA2NCBmb3JtYXRcblxuICAgICAgLy8gWklQNjQgWmlwNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IGxvY2F0b3JcbiAgICAgIHZhciB6aXA2NEVvY2RsQnVmZmVyID0gbmV3QnVmZmVyKDIwKTtcbiAgICAgIHZhciB6aXA2NEVvY2RsT2Zmc2V0ID0gYnVmZmVyUmVhZFN0YXJ0ICsgaSAtIHppcDY0RW9jZGxCdWZmZXIubGVuZ3RoO1xuICAgICAgcmVhZEFuZEFzc2VydE5vRW9mKHJlYWRlciwgemlwNjRFb2NkbEJ1ZmZlciwgMCwgemlwNjRFb2NkbEJ1ZmZlci5sZW5ndGgsIHppcDY0RW9jZGxPZmZzZXQsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcblxuICAgICAgICAvLyAwIC0gemlwNjQgZW5kIG9mIGNlbnRyYWwgZGlyIGxvY2F0b3Igc2lnbmF0dXJlID0gMHgwNzA2NGI1MFxuICAgICAgICBpZiAoemlwNjRFb2NkbEJ1ZmZlci5yZWFkVUludDMyTEUoMCkgIT09IDB4MDcwNjRiNTApIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKFwiaW52YWxpZCB6aXA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgbG9jYXRvciBzaWduYXR1cmVcIikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDQgLSBudW1iZXIgb2YgdGhlIGRpc2sgd2l0aCB0aGUgc3RhcnQgb2YgdGhlIHppcDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeVxuICAgICAgICAvLyA4IC0gcmVsYXRpdmUgb2Zmc2V0IG9mIHRoZSB6aXA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgcmVjb3JkXG4gICAgICAgIHZhciB6aXA2NEVvY2RyT2Zmc2V0ID0gcmVhZFVJbnQ2NExFKHppcDY0RW9jZGxCdWZmZXIsIDgpO1xuICAgICAgICAvLyAxNiAtIHRvdGFsIG51bWJlciBvZiBkaXNrc1xuXG4gICAgICAgIC8vIFpJUDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSByZWNvcmRcbiAgICAgICAgdmFyIHppcDY0RW9jZHJCdWZmZXIgPSBuZXdCdWZmZXIoNTYpO1xuICAgICAgICByZWFkQW5kQXNzZXJ0Tm9Fb2YocmVhZGVyLCB6aXA2NEVvY2RyQnVmZmVyLCAwLCB6aXA2NEVvY2RyQnVmZmVyLmxlbmd0aCwgemlwNjRFb2Nkck9mZnNldCwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG5cbiAgICAgICAgICAvLyAwIC0gemlwNjQgZW5kIG9mIGNlbnRyYWwgZGlyIHNpZ25hdHVyZSAgICAgICAgICAgICAgICAgICAgICAgICAgIDQgYnl0ZXMgICgweDA2MDY0YjUwKVxuICAgICAgICAgIGlmICh6aXA2NEVvY2RyQnVmZmVyLnJlYWRVSW50MzJMRSgwKSAhPT0gMHgwNjA2NGI1MCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcImludmFsaWQgemlwNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IHJlY29yZCBzaWduYXR1cmVcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyA0IC0gc2l6ZSBvZiB6aXA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgcmVjb3JkICAgICAgICAgICAgICAgIDggYnl0ZXNcbiAgICAgICAgICAvLyAxMiAtIHZlcnNpb24gbWFkZSBieSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIgYnl0ZXNcbiAgICAgICAgICAvLyAxNCAtIHZlcnNpb24gbmVlZGVkIHRvIGV4dHJhY3QgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIgYnl0ZXNcbiAgICAgICAgICAvLyAxNiAtIG51bWJlciBvZiB0aGlzIGRpc2sgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAgICAgICAgICAvLyAyMCAtIG51bWJlciBvZiB0aGUgZGlzayB3aXRoIHRoZSBzdGFydCBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnkgIDQgYnl0ZXNcbiAgICAgICAgICAvLyAyNCAtIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBjZW50cmFsIGRpcmVjdG9yeSBvbiB0aGlzIGRpc2sgICAgICAgICA4IGJ5dGVzXG4gICAgICAgICAgLy8gMzIgLSB0b3RhbCBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgY2VudHJhbCBkaXJlY3RvcnkgICAgICAgICAgICA4IGJ5dGVzXG4gICAgICAgICAgZW50cnlDb3VudCA9IHJlYWRVSW50NjRMRSh6aXA2NEVvY2RyQnVmZmVyLCAzMik7XG4gICAgICAgICAgLy8gNDAgLSBzaXplIG9mIHRoZSBjZW50cmFsIGRpcmVjdG9yeSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA4IGJ5dGVzXG4gICAgICAgICAgLy8gNDggLSBvZmZzZXQgb2Ygc3RhcnQgb2YgY2VudHJhbCBkaXJlY3Rvcnkgd2l0aCByZXNwZWN0IHRvIHRoZSBzdGFydGluZyBkaXNrIG51bWJlciAgICAgOCBieXRlc1xuICAgICAgICAgIGNlbnRyYWxEaXJlY3RvcnlPZmZzZXQgPSByZWFkVUludDY0TEUoemlwNjRFb2NkckJ1ZmZlciwgNDgpO1xuICAgICAgICAgIC8vIDU2IC0gemlwNjQgZXh0ZW5zaWJsZSBkYXRhIHNlY3RvciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHZhcmlhYmxlIHNpemUpXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG5ldyBaaXBGaWxlKHJlYWRlciwgY2VudHJhbERpcmVjdG9yeU9mZnNldCwgdG90YWxTaXplLCBlbnRyeUNvdW50LCBjb21tZW50LCBvcHRpb25zLmF1dG9DbG9zZSwgb3B0aW9ucy5sYXp5RW50cmllcywgZGVjb2RlU3RyaW5ncywgb3B0aW9ucy52YWxpZGF0ZUVudHJ5U2l6ZXMsIG9wdGlvbnMuc3RyaWN0RmlsZU5hbWVzKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrKG5ldyBFcnJvcihcImVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSByZWNvcmQgc2lnbmF0dXJlIG5vdCBmb3VuZFwiKSk7XG4gIH0pO1xufVxuXG51dGlsLmluaGVyaXRzKFppcEZpbGUsIEV2ZW50RW1pdHRlcik7XG5mdW5jdGlvbiBaaXBGaWxlKHJlYWRlciwgY2VudHJhbERpcmVjdG9yeU9mZnNldCwgZmlsZVNpemUsIGVudHJ5Q291bnQsIGNvbW1lbnQsIGF1dG9DbG9zZSwgbGF6eUVudHJpZXMsIGRlY29kZVN0cmluZ3MsIHZhbGlkYXRlRW50cnlTaXplcywgc3RyaWN0RmlsZU5hbWVzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwoc2VsZik7XG4gIHNlbGYucmVhZGVyID0gcmVhZGVyO1xuICAvLyBmb3J3YXJkIGNsb3NlIGV2ZW50c1xuICBzZWxmLnJlYWRlci5vbihcImVycm9yXCIsIGZ1bmN0aW9uKGVycikge1xuICAgIC8vIGVycm9yIGNsb3NpbmcgdGhlIGZkXG4gICAgZW1pdEVycm9yKHNlbGYsIGVycik7XG4gIH0pO1xuICBzZWxmLnJlYWRlci5vbmNlKFwiY2xvc2VcIiwgZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbWl0KFwiY2xvc2VcIik7XG4gIH0pO1xuICBzZWxmLnJlYWRFbnRyeUN1cnNvciA9IGNlbnRyYWxEaXJlY3RvcnlPZmZzZXQ7XG4gIHNlbGYuZmlsZVNpemUgPSBmaWxlU2l6ZTtcbiAgc2VsZi5lbnRyeUNvdW50ID0gZW50cnlDb3VudDtcbiAgc2VsZi5jb21tZW50ID0gY29tbWVudDtcbiAgc2VsZi5lbnRyaWVzUmVhZCA9IDA7XG4gIHNlbGYuYXV0b0Nsb3NlID0gISFhdXRvQ2xvc2U7XG4gIHNlbGYubGF6eUVudHJpZXMgPSAhIWxhenlFbnRyaWVzO1xuICBzZWxmLmRlY29kZVN0cmluZ3MgPSAhIWRlY29kZVN0cmluZ3M7XG4gIHNlbGYudmFsaWRhdGVFbnRyeVNpemVzID0gISF2YWxpZGF0ZUVudHJ5U2l6ZXM7XG4gIHNlbGYuc3RyaWN0RmlsZU5hbWVzID0gISFzdHJpY3RGaWxlTmFtZXM7XG4gIHNlbGYuaXNPcGVuID0gdHJ1ZTtcbiAgc2VsZi5lbWl0dGVkRXJyb3IgPSBmYWxzZTtcblxuICBpZiAoIXNlbGYubGF6eUVudHJpZXMpIHNlbGYuX3JlYWRFbnRyeSgpO1xufVxuWmlwRmlsZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmlzT3BlbikgcmV0dXJuO1xuICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICB0aGlzLnJlYWRlci51bnJlZigpO1xufTtcblxuZnVuY3Rpb24gZW1pdEVycm9yQW5kQXV0b0Nsb3NlKHNlbGYsIGVycikge1xuICBpZiAoc2VsZi5hdXRvQ2xvc2UpIHNlbGYuY2xvc2UoKTtcbiAgZW1pdEVycm9yKHNlbGYsIGVycik7XG59XG5mdW5jdGlvbiBlbWl0RXJyb3Ioc2VsZiwgZXJyKSB7XG4gIGlmIChzZWxmLmVtaXR0ZWRFcnJvcikgcmV0dXJuO1xuICBzZWxmLmVtaXR0ZWRFcnJvciA9IHRydWU7XG4gIHNlbGYuZW1pdChcImVycm9yXCIsIGVycik7XG59XG5cblppcEZpbGUucHJvdG90eXBlLnJlYWRFbnRyeSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMubGF6eUVudHJpZXMpIHRocm93IG5ldyBFcnJvcihcInJlYWRFbnRyeSgpIGNhbGxlZCB3aXRob3V0IGxhenlFbnRyaWVzOnRydWVcIik7XG4gIHRoaXMuX3JlYWRFbnRyeSgpO1xufTtcblppcEZpbGUucHJvdG90eXBlLl9yZWFkRW50cnkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoc2VsZi5lbnRyeUNvdW50ID09PSBzZWxmLmVudHJpZXNSZWFkKSB7XG4gICAgLy8gZG9uZSB3aXRoIG1ldGFkYXRhXG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHNlbGYuYXV0b0Nsb3NlKSBzZWxmLmNsb3NlKCk7XG4gICAgICBpZiAoc2VsZi5lbWl0dGVkRXJyb3IpIHJldHVybjtcbiAgICAgIHNlbGYuZW1pdChcImVuZFwiKTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNlbGYuZW1pdHRlZEVycm9yKSByZXR1cm47XG4gIHZhciBidWZmZXIgPSBuZXdCdWZmZXIoNDYpO1xuICByZWFkQW5kQXNzZXJ0Tm9Fb2Yoc2VsZi5yZWFkZXIsIGJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCwgc2VsZi5yZWFkRW50cnlDdXJzb3IsIGZ1bmN0aW9uKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBlbWl0RXJyb3JBbmRBdXRvQ2xvc2Uoc2VsZiwgZXJyKTtcbiAgICBpZiAoc2VsZi5lbWl0dGVkRXJyb3IpIHJldHVybjtcbiAgICB2YXIgZW50cnkgPSBuZXcgRW50cnkoKTtcbiAgICAvLyAwIC0gQ2VudHJhbCBkaXJlY3RvcnkgZmlsZSBoZWFkZXIgc2lnbmF0dXJlXG4gICAgdmFyIHNpZ25hdHVyZSA9IGJ1ZmZlci5yZWFkVUludDMyTEUoMCk7XG4gICAgaWYgKHNpZ25hdHVyZSAhPT0gMHgwMjAxNGI1MCkgcmV0dXJuIGVtaXRFcnJvckFuZEF1dG9DbG9zZShzZWxmLCBuZXcgRXJyb3IoXCJpbnZhbGlkIGNlbnRyYWwgZGlyZWN0b3J5IGZpbGUgaGVhZGVyIHNpZ25hdHVyZTogMHhcIiArIHNpZ25hdHVyZS50b1N0cmluZygxNikpKTtcbiAgICAvLyA0IC0gVmVyc2lvbiBtYWRlIGJ5XG4gICAgZW50cnkudmVyc2lvbk1hZGVCeSA9IGJ1ZmZlci5yZWFkVUludDE2TEUoNCk7XG4gICAgLy8gNiAtIFZlcnNpb24gbmVlZGVkIHRvIGV4dHJhY3QgKG1pbmltdW0pXG4gICAgZW50cnkudmVyc2lvbk5lZWRlZFRvRXh0cmFjdCA9IGJ1ZmZlci5yZWFkVUludDE2TEUoNik7XG4gICAgLy8gOCAtIEdlbmVyYWwgcHVycG9zZSBiaXQgZmxhZ1xuICAgIGVudHJ5LmdlbmVyYWxQdXJwb3NlQml0RmxhZyA9IGJ1ZmZlci5yZWFkVUludDE2TEUoOCk7XG4gICAgLy8gMTAgLSBDb21wcmVzc2lvbiBtZXRob2RcbiAgICBlbnRyeS5jb21wcmVzc2lvbk1ldGhvZCA9IGJ1ZmZlci5yZWFkVUludDE2TEUoMTApO1xuICAgIC8vIDEyIC0gRmlsZSBsYXN0IG1vZGlmaWNhdGlvbiB0aW1lXG4gICAgZW50cnkubGFzdE1vZEZpbGVUaW1lID0gYnVmZmVyLnJlYWRVSW50MTZMRSgxMik7XG4gICAgLy8gMTQgLSBGaWxlIGxhc3QgbW9kaWZpY2F0aW9uIGRhdGVcbiAgICBlbnRyeS5sYXN0TW9kRmlsZURhdGUgPSBidWZmZXIucmVhZFVJbnQxNkxFKDE0KTtcbiAgICAvLyAxNiAtIENSQy0zMlxuICAgIGVudHJ5LmNyYzMyID0gYnVmZmVyLnJlYWRVSW50MzJMRSgxNik7XG4gICAgLy8gMjAgLSBDb21wcmVzc2VkIHNpemVcbiAgICBlbnRyeS5jb21wcmVzc2VkU2l6ZSA9IGJ1ZmZlci5yZWFkVUludDMyTEUoMjApO1xuICAgIC8vIDI0IC0gVW5jb21wcmVzc2VkIHNpemVcbiAgICBlbnRyeS51bmNvbXByZXNzZWRTaXplID0gYnVmZmVyLnJlYWRVSW50MzJMRSgyNCk7XG4gICAgLy8gMjggLSBGaWxlIG5hbWUgbGVuZ3RoIChuKVxuICAgIGVudHJ5LmZpbGVOYW1lTGVuZ3RoID0gYnVmZmVyLnJlYWRVSW50MTZMRSgyOCk7XG4gICAgLy8gMzAgLSBFeHRyYSBmaWVsZCBsZW5ndGggKG0pXG4gICAgZW50cnkuZXh0cmFGaWVsZExlbmd0aCA9IGJ1ZmZlci5yZWFkVUludDE2TEUoMzApO1xuICAgIC8vIDMyIC0gRmlsZSBjb21tZW50IGxlbmd0aCAoaylcbiAgICBlbnRyeS5maWxlQ29tbWVudExlbmd0aCA9IGJ1ZmZlci5yZWFkVUludDE2TEUoMzIpO1xuICAgIC8vIDM0IC0gRGlzayBudW1iZXIgd2hlcmUgZmlsZSBzdGFydHNcbiAgICAvLyAzNiAtIEludGVybmFsIGZpbGUgYXR0cmlidXRlc1xuICAgIGVudHJ5LmludGVybmFsRmlsZUF0dHJpYnV0ZXMgPSBidWZmZXIucmVhZFVJbnQxNkxFKDM2KTtcbiAgICAvLyAzOCAtIEV4dGVybmFsIGZpbGUgYXR0cmlidXRlc1xuICAgIGVudHJ5LmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgPSBidWZmZXIucmVhZFVJbnQzMkxFKDM4KTtcbiAgICAvLyA0MiAtIFJlbGF0aXZlIG9mZnNldCBvZiBsb2NhbCBmaWxlIGhlYWRlclxuICAgIGVudHJ5LnJlbGF0aXZlT2Zmc2V0T2ZMb2NhbEhlYWRlciA9IGJ1ZmZlci5yZWFkVUludDMyTEUoNDIpO1xuXG4gICAgaWYgKGVudHJ5LmdlbmVyYWxQdXJwb3NlQml0RmxhZyAmIDB4NDApIHJldHVybiBlbWl0RXJyb3JBbmRBdXRvQ2xvc2Uoc2VsZiwgbmV3IEVycm9yKFwic3Ryb25nIGVuY3J5cHRpb24gaXMgbm90IHN1cHBvcnRlZFwiKSk7XG5cbiAgICBzZWxmLnJlYWRFbnRyeUN1cnNvciArPSA0NjtcblxuICAgIGJ1ZmZlciA9IG5ld0J1ZmZlcihlbnRyeS5maWxlTmFtZUxlbmd0aCArIGVudHJ5LmV4dHJhRmllbGRMZW5ndGggKyBlbnRyeS5maWxlQ29tbWVudExlbmd0aCk7XG4gICAgcmVhZEFuZEFzc2VydE5vRW9mKHNlbGYucmVhZGVyLCBidWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGgsIHNlbGYucmVhZEVudHJ5Q3Vyc29yLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBlbWl0RXJyb3JBbmRBdXRvQ2xvc2Uoc2VsZiwgZXJyKTtcbiAgICAgIGlmIChzZWxmLmVtaXR0ZWRFcnJvcikgcmV0dXJuO1xuICAgICAgLy8gNDYgLSBGaWxlIG5hbWVcbiAgICAgIHZhciBpc1V0ZjggPSAoZW50cnkuZ2VuZXJhbFB1cnBvc2VCaXRGbGFnICYgMHg4MDApICE9PSAwO1xuICAgICAgZW50cnkuZmlsZU5hbWUgPSBzZWxmLmRlY29kZVN0cmluZ3MgPyBkZWNvZGVCdWZmZXIoYnVmZmVyLCAwLCBlbnRyeS5maWxlTmFtZUxlbmd0aCwgaXNVdGY4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBidWZmZXIuc2xpY2UoMCwgZW50cnkuZmlsZU5hbWVMZW5ndGgpO1xuXG4gICAgICAvLyA0NituIC0gRXh0cmEgZmllbGRcbiAgICAgIHZhciBmaWxlQ29tbWVudFN0YXJ0ID0gZW50cnkuZmlsZU5hbWVMZW5ndGggKyBlbnRyeS5leHRyYUZpZWxkTGVuZ3RoO1xuICAgICAgdmFyIGV4dHJhRmllbGRCdWZmZXIgPSBidWZmZXIuc2xpY2UoZW50cnkuZmlsZU5hbWVMZW5ndGgsIGZpbGVDb21tZW50U3RhcnQpO1xuICAgICAgZW50cnkuZXh0cmFGaWVsZHMgPSBbXTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgZXh0cmFGaWVsZEJ1ZmZlci5sZW5ndGggLSAzKSB7XG4gICAgICAgIHZhciBoZWFkZXJJZCA9IGV4dHJhRmllbGRCdWZmZXIucmVhZFVJbnQxNkxFKGkgKyAwKTtcbiAgICAgICAgdmFyIGRhdGFTaXplID0gZXh0cmFGaWVsZEJ1ZmZlci5yZWFkVUludDE2TEUoaSArIDIpO1xuICAgICAgICB2YXIgZGF0YVN0YXJ0ID0gaSArIDQ7XG4gICAgICAgIHZhciBkYXRhRW5kID0gZGF0YVN0YXJ0ICsgZGF0YVNpemU7XG4gICAgICAgIGlmIChkYXRhRW5kID4gZXh0cmFGaWVsZEJ1ZmZlci5sZW5ndGgpIHJldHVybiBlbWl0RXJyb3JBbmRBdXRvQ2xvc2Uoc2VsZiwgbmV3IEVycm9yKFwiZXh0cmEgZmllbGQgbGVuZ3RoIGV4Y2VlZHMgZXh0cmEgZmllbGQgYnVmZmVyIHNpemVcIikpO1xuICAgICAgICB2YXIgZGF0YUJ1ZmZlciA9IG5ld0J1ZmZlcihkYXRhU2l6ZSk7XG4gICAgICAgIGV4dHJhRmllbGRCdWZmZXIuY29weShkYXRhQnVmZmVyLCAwLCBkYXRhU3RhcnQsIGRhdGFFbmQpO1xuICAgICAgICBlbnRyeS5leHRyYUZpZWxkcy5wdXNoKHtcbiAgICAgICAgICBpZDogaGVhZGVySWQsXG4gICAgICAgICAgZGF0YTogZGF0YUJ1ZmZlcixcbiAgICAgICAgfSk7XG4gICAgICAgIGkgPSBkYXRhRW5kO1xuICAgICAgfVxuXG4gICAgICAvLyA0NituK20gLSBGaWxlIGNvbW1lbnRcbiAgICAgIGVudHJ5LmZpbGVDb21tZW50ID0gc2VsZi5kZWNvZGVTdHJpbmdzID8gZGVjb2RlQnVmZmVyKGJ1ZmZlciwgZmlsZUNvbW1lbnRTdGFydCwgZmlsZUNvbW1lbnRTdGFydCArIGVudHJ5LmZpbGVDb21tZW50TGVuZ3RoLCBpc1V0ZjgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGJ1ZmZlci5zbGljZShmaWxlQ29tbWVudFN0YXJ0LCBmaWxlQ29tbWVudFN0YXJ0ICsgZW50cnkuZmlsZUNvbW1lbnRMZW5ndGgpO1xuICAgICAgLy8gY29tcGF0aWJpbGl0eSBoYWNrIGZvciBodHRwczovL2dpdGh1Yi5jb20vdGhlam9zaHdvbGZlL3lhdXpsL2lzc3Vlcy80N1xuICAgICAgZW50cnkuY29tbWVudCA9IGVudHJ5LmZpbGVDb21tZW50O1xuXG4gICAgICBzZWxmLnJlYWRFbnRyeUN1cnNvciArPSBidWZmZXIubGVuZ3RoO1xuICAgICAgc2VsZi5lbnRyaWVzUmVhZCArPSAxO1xuXG4gICAgICBpZiAoZW50cnkudW5jb21wcmVzc2VkU2l6ZSAgICAgICAgICAgID09PSAweGZmZmZmZmZmIHx8XG4gICAgICAgICAgZW50cnkuY29tcHJlc3NlZFNpemUgICAgICAgICAgICAgID09PSAweGZmZmZmZmZmIHx8XG4gICAgICAgICAgZW50cnkucmVsYXRpdmVPZmZzZXRPZkxvY2FsSGVhZGVyID09PSAweGZmZmZmZmZmKSB7XG4gICAgICAgIC8vIFpJUDY0IGZvcm1hdFxuICAgICAgICAvLyBmaW5kIHRoZSBaaXA2NCBFeHRlbmRlZCBJbmZvcm1hdGlvbiBFeHRyYSBGaWVsZFxuICAgICAgICB2YXIgemlwNjRFaWVmQnVmZmVyID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyeS5leHRyYUZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBleHRyYUZpZWxkID0gZW50cnkuZXh0cmFGaWVsZHNbaV07XG4gICAgICAgICAgaWYgKGV4dHJhRmllbGQuaWQgPT09IDB4MDAwMSkge1xuICAgICAgICAgICAgemlwNjRFaWVmQnVmZmVyID0gZXh0cmFGaWVsZC5kYXRhO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh6aXA2NEVpZWZCdWZmZXIgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBlbWl0RXJyb3JBbmRBdXRvQ2xvc2Uoc2VsZiwgbmV3IEVycm9yKFwiZXhwZWN0ZWQgemlwNjQgZXh0ZW5kZWQgaW5mb3JtYXRpb24gZXh0cmEgZmllbGRcIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIC8vIDAgLSBPcmlnaW5hbCBTaXplICAgICAgICAgIDggYnl0ZXNcbiAgICAgICAgaWYgKGVudHJ5LnVuY29tcHJlc3NlZFNpemUgPT09IDB4ZmZmZmZmZmYpIHtcbiAgICAgICAgICBpZiAoaW5kZXggKyA4ID4gemlwNjRFaWVmQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGVtaXRFcnJvckFuZEF1dG9DbG9zZShzZWxmLCBuZXcgRXJyb3IoXCJ6aXA2NCBleHRlbmRlZCBpbmZvcm1hdGlvbiBleHRyYSBmaWVsZCBkb2VzIG5vdCBpbmNsdWRlIHVuY29tcHJlc3NlZCBzaXplXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZW50cnkudW5jb21wcmVzc2VkU2l6ZSA9IHJlYWRVSW50NjRMRSh6aXA2NEVpZWZCdWZmZXIsIGluZGV4KTtcbiAgICAgICAgICBpbmRleCArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vIDggLSBDb21wcmVzc2VkIFNpemUgICAgICAgIDggYnl0ZXNcbiAgICAgICAgaWYgKGVudHJ5LmNvbXByZXNzZWRTaXplID09PSAweGZmZmZmZmZmKSB7XG4gICAgICAgICAgaWYgKGluZGV4ICsgOCA+IHppcDY0RWllZkJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBlbWl0RXJyb3JBbmRBdXRvQ2xvc2Uoc2VsZiwgbmV3IEVycm9yKFwiemlwNjQgZXh0ZW5kZWQgaW5mb3JtYXRpb24gZXh0cmEgZmllbGQgZG9lcyBub3QgaW5jbHVkZSBjb21wcmVzc2VkIHNpemVcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbnRyeS5jb21wcmVzc2VkU2l6ZSA9IHJlYWRVSW50NjRMRSh6aXA2NEVpZWZCdWZmZXIsIGluZGV4KTtcbiAgICAgICAgICBpbmRleCArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vIDE2IC0gUmVsYXRpdmUgSGVhZGVyIE9mZnNldCA4IGJ5dGVzXG4gICAgICAgIGlmIChlbnRyeS5yZWxhdGl2ZU9mZnNldE9mTG9jYWxIZWFkZXIgPT09IDB4ZmZmZmZmZmYpIHtcbiAgICAgICAgICBpZiAoaW5kZXggKyA4ID4gemlwNjRFaWVmQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGVtaXRFcnJvckFuZEF1dG9DbG9zZShzZWxmLCBuZXcgRXJyb3IoXCJ6aXA2NCBleHRlbmRlZCBpbmZvcm1hdGlvbiBleHRyYSBmaWVsZCBkb2VzIG5vdCBpbmNsdWRlIHJlbGF0aXZlIGhlYWRlciBvZmZzZXRcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbnRyeS5yZWxhdGl2ZU9mZnNldE9mTG9jYWxIZWFkZXIgPSByZWFkVUludDY0TEUoemlwNjRFaWVmQnVmZmVyLCBpbmRleCk7XG4gICAgICAgICAgaW5kZXggKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLyAyNCAtIERpc2sgU3RhcnQgTnVtYmVyICAgICAgNCBieXRlc1xuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBmb3IgSW5mby1aSVAgVW5pY29kZSBQYXRoIEV4dHJhIEZpZWxkICgweDcwNzUpXG4gICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3RoZWpvc2h3b2xmZS95YXV6bC9pc3N1ZXMvMzNcbiAgICAgIGlmIChzZWxmLmRlY29kZVN0cmluZ3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyeS5leHRyYUZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBleHRyYUZpZWxkID0gZW50cnkuZXh0cmFGaWVsZHNbaV07XG4gICAgICAgICAgaWYgKGV4dHJhRmllbGQuaWQgPT09IDB4NzA3NSkge1xuICAgICAgICAgICAgaWYgKGV4dHJhRmllbGQuZGF0YS5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgICAgIC8vIHRvbyBzaG9ydCB0byBiZSBtZWFuaW5nZnVsXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVmVyc2lvbiAgICAgICAxIGJ5dGUgICAgICB2ZXJzaW9uIG9mIHRoaXMgZXh0cmEgZmllbGQsIGN1cnJlbnRseSAxXG4gICAgICAgICAgICBpZiAoZXh0cmFGaWVsZC5kYXRhLnJlYWRVSW50OCgwKSAhPT0gMSkge1xuICAgICAgICAgICAgICAvLyA+IENoYW5nZXMgbWF5IG5vdCBiZSBiYWNrd2FyZCBjb21wYXRpYmxlIHNvIHRoaXMgZXh0cmFcbiAgICAgICAgICAgICAgLy8gPiBmaWVsZCBzaG91bGQgbm90IGJlIHVzZWQgaWYgdGhlIHZlcnNpb24gaXMgbm90IHJlY29nbml6ZWQuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTmFtZUNSQzMyICAgICA0IGJ5dGVzICAgICBGaWxlIE5hbWUgRmllbGQgQ1JDMzIgQ2hlY2tzdW1cbiAgICAgICAgICAgIHZhciBvbGROYW1lQ3JjMzIgPSBleHRyYUZpZWxkLmRhdGEucmVhZFVJbnQzMkxFKDEpO1xuICAgICAgICAgICAgaWYgKGNyYzMyLnVuc2lnbmVkKGJ1ZmZlci5zbGljZSgwLCBlbnRyeS5maWxlTmFtZUxlbmd0aCkpICE9PSBvbGROYW1lQ3JjMzIpIHtcbiAgICAgICAgICAgICAgLy8gPiBJZiB0aGUgQ1JDIGNoZWNrIGZhaWxzLCB0aGlzIFVURi04IFBhdGggRXh0cmEgRmllbGQgc2hvdWxkIGJlXG4gICAgICAgICAgICAgIC8vID4gaWdub3JlZCBhbmQgdGhlIEZpbGUgTmFtZSBmaWVsZCBpbiB0aGUgaGVhZGVyIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVW5pY29kZU5hbWUgICBWYXJpYWJsZSAgICBVVEYtOCB2ZXJzaW9uIG9mIHRoZSBlbnRyeSBGaWxlIE5hbWVcbiAgICAgICAgICAgIGVudHJ5LmZpbGVOYW1lID0gZGVjb2RlQnVmZmVyKGV4dHJhRmllbGQuZGF0YSwgNSwgZXh0cmFGaWVsZC5kYXRhLmxlbmd0aCwgdHJ1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWRhdGUgZmlsZSBzaXplXG4gICAgICBpZiAoc2VsZi52YWxpZGF0ZUVudHJ5U2l6ZXMgJiYgZW50cnkuY29tcHJlc3Npb25NZXRob2QgPT09IDApIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ29tcHJlc3NlZFNpemUgPSBlbnRyeS51bmNvbXByZXNzZWRTaXplO1xuICAgICAgICBpZiAoZW50cnkuaXNFbmNyeXB0ZWQoKSkge1xuICAgICAgICAgIC8vIHRyYWRpdGlvbmFsIGVuY3J5cHRpb24gcHJlZml4ZXMgdGhlIGZpbGUgZGF0YSB3aXRoIGEgaGVhZGVyXG4gICAgICAgICAgZXhwZWN0ZWRDb21wcmVzc2VkU2l6ZSArPSAxMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW50cnkuY29tcHJlc3NlZFNpemUgIT09IGV4cGVjdGVkQ29tcHJlc3NlZFNpemUpIHtcbiAgICAgICAgICB2YXIgbXNnID0gXCJjb21wcmVzc2VkL3VuY29tcHJlc3NlZCBzaXplIG1pc21hdGNoIGZvciBzdG9yZWQgZmlsZTogXCIgKyBlbnRyeS5jb21wcmVzc2VkU2l6ZSArIFwiICE9IFwiICsgZW50cnkudW5jb21wcmVzc2VkU2l6ZTtcbiAgICAgICAgICByZXR1cm4gZW1pdEVycm9yQW5kQXV0b0Nsb3NlKHNlbGYsIG5ldyBFcnJvcihtc2cpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5kZWNvZGVTdHJpbmdzKSB7XG4gICAgICAgIGlmICghc2VsZi5zdHJpY3RGaWxlTmFtZXMpIHtcbiAgICAgICAgICAvLyBhbGxvdyBiYWNrc2xhc2hcbiAgICAgICAgICBlbnRyeS5maWxlTmFtZSA9IGVudHJ5LmZpbGVOYW1lLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSB2YWxpZGF0ZUZpbGVOYW1lKGVudHJ5LmZpbGVOYW1lLCBzZWxmLnZhbGlkYXRlRmlsZU5hbWVPcHRpb25zKTtcbiAgICAgICAgaWYgKGVycm9yTWVzc2FnZSAhPSBudWxsKSByZXR1cm4gZW1pdEVycm9yQW5kQXV0b0Nsb3NlKHNlbGYsIG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZW1pdChcImVudHJ5XCIsIGVudHJ5KTtcblxuICAgICAgaWYgKCFzZWxmLmxhenlFbnRyaWVzKSBzZWxmLl9yZWFkRW50cnkoKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5aaXBGaWxlLnByb3RvdHlwZS5vcGVuUmVhZFN0cmVhbSA9IGZ1bmN0aW9uKGVudHJ5LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIC8vIHBhcmFtZXRlciB2YWxpZGF0aW9uXG4gIHZhciByZWxhdGl2ZVN0YXJ0ID0gMDtcbiAgdmFyIHJlbGF0aXZlRW5kID0gZW50cnkuY29tcHJlc3NlZFNpemU7XG4gIGlmIChjYWxsYmFjayA9PSBudWxsKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICAvLyB2YWxpZGF0ZSBvcHRpb25zIHRoYXQgdGhlIGNhbGxlciBoYXMgbm8gZXhjdXNlIHRvIGdldCB3cm9uZ1xuICAgIGlmIChvcHRpb25zLmRlY3J5cHQgIT0gbnVsbCkge1xuICAgICAgaWYgKCFlbnRyeS5pc0VuY3J5cHRlZCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9wdGlvbnMuZGVjcnlwdCBjYW4gb25seSBiZSBzcGVjaWZpZWQgZm9yIGVuY3J5cHRlZCBlbnRyaWVzXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZGVjcnlwdCAhPT0gZmFsc2UpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgb3B0aW9ucy5kZWNyeXB0IHZhbHVlOiBcIiArIG9wdGlvbnMuZGVjcnlwdCk7XG4gICAgICBpZiAoZW50cnkuaXNDb21wcmVzc2VkKCkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVjb21wcmVzcyAhPT0gZmFsc2UpIHRocm93IG5ldyBFcnJvcihcImVudHJ5IGlzIGVuY3J5cHRlZCBhbmQgY29tcHJlc3NlZCwgYW5kIG9wdGlvbnMuZGVjb21wcmVzcyAhPT0gZmFsc2VcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRlY29tcHJlc3MgIT0gbnVsbCkge1xuICAgICAgaWYgKCFlbnRyeS5pc0NvbXByZXNzZWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLmRlY29tcHJlc3MgY2FuIG9ubHkgYmUgc3BlY2lmaWVkIGZvciBjb21wcmVzc2VkIGVudHJpZXNcIik7XG4gICAgICB9XG4gICAgICBpZiAoIShvcHRpb25zLmRlY29tcHJlc3MgPT09IGZhbHNlIHx8IG9wdGlvbnMuZGVjb21wcmVzcyA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBvcHRpb25zLmRlY29tcHJlc3MgdmFsdWU6IFwiICsgb3B0aW9ucy5kZWNvbXByZXNzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3RhcnQgIT0gbnVsbCB8fCBvcHRpb25zLmVuZCAhPSBudWxsKSB7XG4gICAgICBpZiAoZW50cnkuaXNDb21wcmVzc2VkKCkgJiYgb3B0aW9ucy5kZWNvbXByZXNzICE9PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdGFydC9lbmQgcmFuZ2Ugbm90IGFsbG93ZWQgZm9yIGNvbXByZXNzZWQgZW50cnkgd2l0aG91dCBvcHRpb25zLmRlY29tcHJlc3MgPT09IGZhbHNlXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGVudHJ5LmlzRW5jcnlwdGVkKCkgJiYgb3B0aW9ucy5kZWNyeXB0ICE9PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdGFydC9lbmQgcmFuZ2Ugbm90IGFsbG93ZWQgZm9yIGVuY3J5cHRlZCBlbnRyeSB3aXRob3V0IG9wdGlvbnMuZGVjcnlwdCA9PT0gZmFsc2VcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgIHJlbGF0aXZlU3RhcnQgPSBvcHRpb25zLnN0YXJ0O1xuICAgICAgaWYgKHJlbGF0aXZlU3RhcnQgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLnN0YXJ0IDwgMFwiKTtcbiAgICAgIGlmIChyZWxhdGl2ZVN0YXJ0ID4gZW50cnkuY29tcHJlc3NlZFNpemUpIHRocm93IG5ldyBFcnJvcihcIm9wdGlvbnMuc3RhcnQgPiBlbnRyeS5jb21wcmVzc2VkU2l6ZVwiKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZW5kICE9IG51bGwpIHtcbiAgICAgIHJlbGF0aXZlRW5kID0gb3B0aW9ucy5lbmQ7XG4gICAgICBpZiAocmVsYXRpdmVFbmQgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLmVuZCA8IDBcIik7XG4gICAgICBpZiAocmVsYXRpdmVFbmQgPiBlbnRyeS5jb21wcmVzc2VkU2l6ZSkgdGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucy5lbmQgPiBlbnRyeS5jb21wcmVzc2VkU2l6ZVwiKTtcbiAgICAgIGlmIChyZWxhdGl2ZUVuZCA8IHJlbGF0aXZlU3RhcnQpIHRocm93IG5ldyBFcnJvcihcIm9wdGlvbnMuZW5kIDwgb3B0aW9ucy5zdGFydFwiKTtcbiAgICB9XG4gIH1cbiAgLy8gYW55IGZ1cnRoZXIgZXJyb3JzIGNhbiBlaXRoZXIgYmUgY2F1c2VkIGJ5IHRoZSB6aXBmaWxlLFxuICAvLyBvciB3ZXJlIGludHJvZHVjZWQgaW4gYSBtaW5vciB2ZXJzaW9uIG9mIHlhdXpsLFxuICAvLyBzbyBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSBjbGllbnQgcmF0aGVyIHRoYW4gdGhyb3duLlxuICBpZiAoIXNlbGYuaXNPcGVuKSByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKFwiY2xvc2VkXCIpKTtcbiAgaWYgKGVudHJ5LmlzRW5jcnlwdGVkKCkpIHtcbiAgICBpZiAob3B0aW9ucy5kZWNyeXB0ICE9PSBmYWxzZSkgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcImVudHJ5IGlzIGVuY3J5cHRlZCwgYW5kIG9wdGlvbnMuZGVjcnlwdCAhPT0gZmFsc2VcIikpO1xuICB9XG4gIC8vIG1ha2Ugc3VyZSB3ZSBkb24ndCBsb3NlIHRoZSBmZCBiZWZvcmUgd2Ugb3BlbiB0aGUgYWN0dWFsIHJlYWQgc3RyZWFtXG4gIHNlbGYucmVhZGVyLnJlZigpO1xuICB2YXIgYnVmZmVyID0gbmV3QnVmZmVyKDMwKTtcbiAgcmVhZEFuZEFzc2VydE5vRW9mKHNlbGYucmVhZGVyLCBidWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGgsIGVudHJ5LnJlbGF0aXZlT2Zmc2V0T2ZMb2NhbEhlYWRlciwgZnVuY3Rpb24oZXJyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgLy8gMCAtIExvY2FsIGZpbGUgaGVhZGVyIHNpZ25hdHVyZSA9IDB4MDQwMzRiNTBcbiAgICAgIHZhciBzaWduYXR1cmUgPSBidWZmZXIucmVhZFVJbnQzMkxFKDApO1xuICAgICAgaWYgKHNpZ25hdHVyZSAhPT0gMHgwNDAzNGI1MCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKFwiaW52YWxpZCBsb2NhbCBmaWxlIGhlYWRlciBzaWduYXR1cmU6IDB4XCIgKyBzaWduYXR1cmUudG9TdHJpbmcoMTYpKSk7XG4gICAgICB9XG4gICAgICAvLyBhbGwgdGhpcyBzaG91bGQgYmUgcmVkdW5kYW50XG4gICAgICAvLyA0IC0gVmVyc2lvbiBuZWVkZWQgdG8gZXh0cmFjdCAobWluaW11bSlcbiAgICAgIC8vIDYgLSBHZW5lcmFsIHB1cnBvc2UgYml0IGZsYWdcbiAgICAgIC8vIDggLSBDb21wcmVzc2lvbiBtZXRob2RcbiAgICAgIC8vIDEwIC0gRmlsZSBsYXN0IG1vZGlmaWNhdGlvbiB0aW1lXG4gICAgICAvLyAxMiAtIEZpbGUgbGFzdCBtb2RpZmljYXRpb24gZGF0ZVxuICAgICAgLy8gMTQgLSBDUkMtMzJcbiAgICAgIC8vIDE4IC0gQ29tcHJlc3NlZCBzaXplXG4gICAgICAvLyAyMiAtIFVuY29tcHJlc3NlZCBzaXplXG4gICAgICAvLyAyNiAtIEZpbGUgbmFtZSBsZW5ndGggKG4pXG4gICAgICB2YXIgZmlsZU5hbWVMZW5ndGggPSBidWZmZXIucmVhZFVJbnQxNkxFKDI2KTtcbiAgICAgIC8vIDI4IC0gRXh0cmEgZmllbGQgbGVuZ3RoIChtKVxuICAgICAgdmFyIGV4dHJhRmllbGRMZW5ndGggPSBidWZmZXIucmVhZFVJbnQxNkxFKDI4KTtcbiAgICAgIC8vIDMwIC0gRmlsZSBuYW1lXG4gICAgICAvLyAzMCtuIC0gRXh0cmEgZmllbGRcbiAgICAgIHZhciBsb2NhbEZpbGVIZWFkZXJFbmQgPSBlbnRyeS5yZWxhdGl2ZU9mZnNldE9mTG9jYWxIZWFkZXIgKyBidWZmZXIubGVuZ3RoICsgZmlsZU5hbWVMZW5ndGggKyBleHRyYUZpZWxkTGVuZ3RoO1xuICAgICAgdmFyIGRlY29tcHJlc3M7XG4gICAgICBpZiAoZW50cnkuY29tcHJlc3Npb25NZXRob2QgPT09IDApIHtcbiAgICAgICAgLy8gMCAtIFRoZSBmaWxlIGlzIHN0b3JlZCAobm8gY29tcHJlc3Npb24pXG4gICAgICAgIGRlY29tcHJlc3MgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoZW50cnkuY29tcHJlc3Npb25NZXRob2QgPT09IDgpIHtcbiAgICAgICAgLy8gOCAtIFRoZSBmaWxlIGlzIERlZmxhdGVkXG4gICAgICAgIGRlY29tcHJlc3MgPSBvcHRpb25zLmRlY29tcHJlc3MgIT0gbnVsbCA/IG9wdGlvbnMuZGVjb21wcmVzcyA6IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgY29tcHJlc3Npb24gbWV0aG9kOiBcIiArIGVudHJ5LmNvbXByZXNzaW9uTWV0aG9kKSk7XG4gICAgICB9XG4gICAgICB2YXIgZmlsZURhdGFTdGFydCA9IGxvY2FsRmlsZUhlYWRlckVuZDtcbiAgICAgIHZhciBmaWxlRGF0YUVuZCA9IGZpbGVEYXRhU3RhcnQgKyBlbnRyeS5jb21wcmVzc2VkU2l6ZTtcbiAgICAgIGlmIChlbnRyeS5jb21wcmVzc2VkU2l6ZSAhPT0gMCkge1xuICAgICAgICAvLyBib3VuZHMgY2hlY2sgbm93LCBiZWNhdXNlIHRoZSByZWFkIHN0cmVhbXMgd2lsbCBwcm9iYWJseSBub3QgY29tcGxhaW4gbG91ZCBlbm91Z2guXG4gICAgICAgIC8vIHNpbmNlIHdlJ3JlIGRlYWxpbmcgd2l0aCBhbiB1bnNpZ25lZCBvZmZzZXQgcGx1cyBhbiB1bnNpZ25lZCBzaXplLFxuICAgICAgICAvLyB3ZSBvbmx5IGhhdmUgMSB0aGluZyB0byBjaGVjayBmb3IuXG4gICAgICAgIGlmIChmaWxlRGF0YUVuZCA+IHNlbGYuZmlsZVNpemUpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKFwiZmlsZSBkYXRhIG92ZXJmbG93cyBmaWxlIGJvdW5kczogXCIgK1xuICAgICAgICAgICAgICBmaWxlRGF0YVN0YXJ0ICsgXCIgKyBcIiArIGVudHJ5LmNvbXByZXNzZWRTaXplICsgXCIgPiBcIiArIHNlbGYuZmlsZVNpemUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHJlYWRTdHJlYW0gPSBzZWxmLnJlYWRlci5jcmVhdGVSZWFkU3RyZWFtKHtcbiAgICAgICAgc3RhcnQ6IGZpbGVEYXRhU3RhcnQgKyByZWxhdGl2ZVN0YXJ0LFxuICAgICAgICBlbmQ6IGZpbGVEYXRhU3RhcnQgKyByZWxhdGl2ZUVuZCxcbiAgICAgIH0pO1xuICAgICAgdmFyIGVuZHBvaW50U3RyZWFtID0gcmVhZFN0cmVhbTtcbiAgICAgIGlmIChkZWNvbXByZXNzKSB7XG4gICAgICAgIHZhciBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGluZmxhdGVGaWx0ZXIgPSB6bGliLmNyZWF0ZUluZmxhdGVSYXcoKTtcbiAgICAgICAgcmVhZFN0cmVhbS5vbihcImVycm9yXCIsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIC8vIHNldEltbWVkaWF0ZSBoZXJlIGJlY2F1c2UgZXJyb3JzIGNhbiBiZSBlbWl0dGVkIGR1cmluZyB0aGUgZmlyc3QgY2FsbCB0byBwaXBlKClcbiAgICAgICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIWRlc3Ryb3llZCkgaW5mbGF0ZUZpbHRlci5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlYWRTdHJlYW0ucGlwZShpbmZsYXRlRmlsdGVyKTtcblxuICAgICAgICBpZiAoc2VsZi52YWxpZGF0ZUVudHJ5U2l6ZXMpIHtcbiAgICAgICAgICBlbmRwb2ludFN0cmVhbSA9IG5ldyBBc3NlcnRCeXRlQ291bnRTdHJlYW0oZW50cnkudW5jb21wcmVzc2VkU2l6ZSk7XG4gICAgICAgICAgaW5mbGF0ZUZpbHRlci5vbihcImVycm9yXCIsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgLy8gZm9yd2FyZCB6bGliIGVycm9ycyB0byB0aGUgY2xpZW50LXZpc2libGUgc3RyZWFtXG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmICghZGVzdHJveWVkKSBlbmRwb2ludFN0cmVhbS5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGluZmxhdGVGaWx0ZXIucGlwZShlbmRwb2ludFN0cmVhbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGhlIHpsaWIgZmlsdGVyIGlzIHRoZSBjbGllbnQtdmlzaWJsZSBzdHJlYW1cbiAgICAgICAgICBlbmRwb2ludFN0cmVhbSA9IGluZmxhdGVGaWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBpcyBwYXJ0IG9mIHlhdXpsJ3MgQVBJLCBzbyBpbXBsZW1lbnQgdGhpcyBmdW5jdGlvbiBvbiB0aGUgY2xpZW50LXZpc2libGUgc3RyZWFtXG4gICAgICAgIGVuZHBvaW50U3RyZWFtLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBkZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICAgIGlmIChpbmZsYXRlRmlsdGVyICE9PSBlbmRwb2ludFN0cmVhbSkgaW5mbGF0ZUZpbHRlci51bnBpcGUoZW5kcG9pbnRTdHJlYW0pO1xuICAgICAgICAgIHJlYWRTdHJlYW0udW5waXBlKGluZmxhdGVGaWx0ZXIpO1xuICAgICAgICAgIC8vIFRPRE86IHRoZSBpbmZsYXRlRmlsdGVyIG1heSBjYXVzZSBhIG1lbW9yeSBsZWFrLiBzZWUgSXNzdWUgIzI3LlxuICAgICAgICAgIHJlYWRTdHJlYW0uZGVzdHJveSgpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgZW5kcG9pbnRTdHJlYW0pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZWxmLnJlYWRlci51bnJlZigpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBFbnRyeSgpIHtcbn1cbkVudHJ5LnByb3RvdHlwZS5nZXRMYXN0TW9kRGF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZG9zRGF0ZVRpbWVUb0RhdGUodGhpcy5sYXN0TW9kRmlsZURhdGUsIHRoaXMubGFzdE1vZEZpbGVUaW1lKTtcbn07XG5FbnRyeS5wcm90b3R5cGUuaXNFbmNyeXB0ZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICh0aGlzLmdlbmVyYWxQdXJwb3NlQml0RmxhZyAmIDB4MSkgIT09IDA7XG59O1xuRW50cnkucHJvdG90eXBlLmlzQ29tcHJlc3NlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jb21wcmVzc2lvbk1ldGhvZCA9PT0gODtcbn07XG5cbmZ1bmN0aW9uIGRvc0RhdGVUaW1lVG9EYXRlKGRhdGUsIHRpbWUpIHtcbiAgdmFyIGRheSA9IGRhdGUgJiAweDFmOyAvLyAxLTMxXG4gIHZhciBtb250aCA9IChkYXRlID4+IDUgJiAweGYpIC0gMTsgLy8gMS0xMiwgMC0xMVxuICB2YXIgeWVhciA9IChkYXRlID4+IDkgJiAweDdmKSArIDE5ODA7IC8vIDAtMTI4LCAxOTgwLTIxMDhcblxuICB2YXIgbWlsbGlzZWNvbmQgPSAwO1xuICB2YXIgc2Vjb25kID0gKHRpbWUgJiAweDFmKSAqIDI7IC8vIDAtMjksIDAtNTggKGV2ZW4gbnVtYmVycylcbiAgdmFyIG1pbnV0ZSA9IHRpbWUgPj4gNSAmIDB4M2Y7IC8vIDAtNTlcbiAgdmFyIGhvdXIgPSB0aW1lID4+IDExICYgMHgxZjsgLy8gMC0yM1xuXG4gIHJldHVybiBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZpbGVOYW1lKGZpbGVOYW1lKSB7XG4gIGlmIChmaWxlTmFtZS5pbmRleE9mKFwiXFxcXFwiKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gXCJpbnZhbGlkIGNoYXJhY3RlcnMgaW4gZmlsZU5hbWU6IFwiICsgZmlsZU5hbWU7XG4gIH1cbiAgaWYgKC9eW2EtekEtWl06Ly50ZXN0KGZpbGVOYW1lKSB8fCAvXlxcLy8udGVzdChmaWxlTmFtZSkpIHtcbiAgICByZXR1cm4gXCJhYnNvbHV0ZSBwYXRoOiBcIiArIGZpbGVOYW1lO1xuICB9XG4gIGlmIChmaWxlTmFtZS5zcGxpdChcIi9cIikuaW5kZXhPZihcIi4uXCIpICE9PSAtMSkge1xuICAgIHJldHVybiBcImludmFsaWQgcmVsYXRpdmUgcGF0aDogXCIgKyBmaWxlTmFtZTtcbiAgfVxuICAvLyBhbGwgZ29vZFxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVhZEFuZEFzc2VydE5vRW9mKHJlYWRlciwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKSB7XG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAvLyBmcy5yZWFkIHdpbGwgdGhyb3cgYW4gb3V0LW9mLWJvdW5kcyBlcnJvciBpZiB5b3UgdHJ5IHRvIHJlYWQgMCBieXRlcyBmcm9tIGEgMCBieXRlIGZpbGVcbiAgICByZXR1cm4gc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhudWxsLCBuZXdCdWZmZXIoMCkpOyB9KTtcbiAgfVxuICByZWFkZXIucmVhZChidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgZnVuY3Rpb24oZXJyLCBieXRlc1JlYWQpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICBpZiAoYnl0ZXNSZWFkIDwgbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKFwidW5leHBlY3RlZCBFT0ZcIikpO1xuICAgIH1cbiAgICBjYWxsYmFjaygpO1xuICB9KTtcbn1cblxudXRpbC5pbmhlcml0cyhBc3NlcnRCeXRlQ291bnRTdHJlYW0sIFRyYW5zZm9ybSk7XG5mdW5jdGlvbiBBc3NlcnRCeXRlQ291bnRTdHJlYW0oYnl0ZUNvdW50KSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpO1xuICB0aGlzLmFjdHVhbEJ5dGVDb3VudCA9IDA7XG4gIHRoaXMuZXhwZWN0ZWRCeXRlQ291bnQgPSBieXRlQ291bnQ7XG59XG5Bc3NlcnRCeXRlQ291bnRTdHJlYW0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuYWN0dWFsQnl0ZUNvdW50ICs9IGNodW5rLmxlbmd0aDtcbiAgaWYgKHRoaXMuYWN0dWFsQnl0ZUNvdW50ID4gdGhpcy5leHBlY3RlZEJ5dGVDb3VudCkge1xuICAgIHZhciBtc2cgPSBcInRvbyBtYW55IGJ5dGVzIGluIHRoZSBzdHJlYW0uIGV4cGVjdGVkIFwiICsgdGhpcy5leHBlY3RlZEJ5dGVDb3VudCArIFwiLiBnb3QgYXQgbGVhc3QgXCIgKyB0aGlzLmFjdHVhbEJ5dGVDb3VudDtcbiAgICByZXR1cm4gY2IobmV3IEVycm9yKG1zZykpO1xuICB9XG4gIGNiKG51bGwsIGNodW5rKTtcbn07XG5Bc3NlcnRCeXRlQ291bnRTdHJlYW0ucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uKGNiKSB7XG4gIGlmICh0aGlzLmFjdHVhbEJ5dGVDb3VudCA8IHRoaXMuZXhwZWN0ZWRCeXRlQ291bnQpIHtcbiAgICB2YXIgbXNnID0gXCJub3QgZW5vdWdoIGJ5dGVzIGluIHRoZSBzdHJlYW0uIGV4cGVjdGVkIFwiICsgdGhpcy5leHBlY3RlZEJ5dGVDb3VudCArIFwiLiBnb3Qgb25seSBcIiArIHRoaXMuYWN0dWFsQnl0ZUNvdW50O1xuICAgIHJldHVybiBjYihuZXcgRXJyb3IobXNnKSk7XG4gIH1cbiAgY2IoKTtcbn07XG5cbnV0aWwuaW5oZXJpdHMoUmFuZG9tQWNjZXNzUmVhZGVyLCBFdmVudEVtaXR0ZXIpO1xuZnVuY3Rpb24gUmFuZG9tQWNjZXNzUmVhZGVyKCkge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdGhpcy5yZWZDb3VudCA9IDA7XG59XG5SYW5kb21BY2Nlc3NSZWFkZXIucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlZkNvdW50ICs9IDE7XG59O1xuUmFuZG9tQWNjZXNzUmVhZGVyLnByb3RvdHlwZS51bnJlZiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYucmVmQ291bnQgLT0gMTtcblxuICBpZiAoc2VsZi5yZWZDb3VudCA+IDApIHJldHVybjtcbiAgaWYgKHNlbGYucmVmQ291bnQgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHVucmVmXCIpO1xuXG4gIHNlbGYuY2xvc2Uob25DbG9zZURvbmUpO1xuXG4gIGZ1bmN0aW9uIG9uQ2xvc2VEb25lKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJyk7XG4gIH1cbn07XG5SYW5kb21BY2Nlc3NSZWFkZXIucHJvdG90eXBlLmNyZWF0ZVJlYWRTdHJlYW0gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciBzdGFydCA9IG9wdGlvbnMuc3RhcnQ7XG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZDtcbiAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICB2YXIgZW1wdHlTdHJlYW0gPSBuZXcgUGFzc1Rocm91Z2goKTtcbiAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBlbXB0eVN0cmVhbS5lbmQoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZW1wdHlTdHJlYW07XG4gIH1cbiAgdmFyIHN0cmVhbSA9IHRoaXMuX3JlYWRTdHJlYW1Gb3JSYW5nZShzdGFydCwgZW5kKTtcblxuICB2YXIgZGVzdHJveWVkID0gZmFsc2U7XG4gIHZhciByZWZVbnJlZkZpbHRlciA9IG5ldyBSZWZVbnJlZkZpbHRlcih0aGlzKTtcbiAgc3RyZWFtLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24oZXJyKSB7XG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFkZXN0cm95ZWQpIHJlZlVucmVmRmlsdGVyLmVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICAgIH0pO1xuICB9KTtcbiAgcmVmVW5yZWZGaWx0ZXIuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHN0cmVhbS51bnBpcGUocmVmVW5yZWZGaWx0ZXIpO1xuICAgIHJlZlVucmVmRmlsdGVyLnVucmVmKCk7XG4gICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgfTtcblxuICB2YXIgYnl0ZUNvdW50ZXIgPSBuZXcgQXNzZXJ0Qnl0ZUNvdW50U3RyZWFtKGVuZCAtIHN0YXJ0KTtcbiAgcmVmVW5yZWZGaWx0ZXIub24oXCJlcnJvclwiLCBmdW5jdGlvbihlcnIpIHtcbiAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWRlc3Ryb3llZCkgYnl0ZUNvdW50ZXIuZW1pdChcImVycm9yXCIsIGVycik7XG4gICAgfSk7XG4gIH0pO1xuICBieXRlQ291bnRlci5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgICByZWZVbnJlZkZpbHRlci51bnBpcGUoYnl0ZUNvdW50ZXIpO1xuICAgIHJlZlVucmVmRmlsdGVyLmRlc3Ryb3koKTtcbiAgfTtcblxuICByZXR1cm4gc3RyZWFtLnBpcGUocmVmVW5yZWZGaWx0ZXIpLnBpcGUoYnl0ZUNvdW50ZXIpO1xufTtcblJhbmRvbUFjY2Vzc1JlYWRlci5wcm90b3R5cGUuX3JlYWRTdHJlYW1Gb3JSYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufTtcblJhbmRvbUFjY2Vzc1JlYWRlci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaykge1xuICB2YXIgcmVhZFN0cmVhbSA9IHRoaXMuY3JlYXRlUmVhZFN0cmVhbSh7c3RhcnQ6IHBvc2l0aW9uLCBlbmQ6IHBvc2l0aW9uICsgbGVuZ3RofSk7XG4gIHZhciB3cml0ZVN0cmVhbSA9IG5ldyBXcml0YWJsZSgpO1xuICB2YXIgd3JpdHRlbiA9IDA7XG4gIHdyaXRlU3RyZWFtLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICBjaHVuay5jb3B5KGJ1ZmZlciwgb2Zmc2V0ICsgd3JpdHRlbiwgMCwgY2h1bmsubGVuZ3RoKTtcbiAgICB3cml0dGVuICs9IGNodW5rLmxlbmd0aDtcbiAgICBjYigpO1xuICB9O1xuICB3cml0ZVN0cmVhbS5vbihcImZpbmlzaFwiLCBjYWxsYmFjayk7XG4gIHJlYWRTdHJlYW0ub24oXCJlcnJvclwiLCBmdW5jdGlvbihlcnJvcikge1xuICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgfSk7XG4gIHJlYWRTdHJlYW0ucGlwZSh3cml0ZVN0cmVhbSk7XG59O1xuUmFuZG9tQWNjZXNzUmVhZGVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG59O1xuXG51dGlsLmluaGVyaXRzKFJlZlVucmVmRmlsdGVyLCBQYXNzVGhyb3VnaCk7XG5mdW5jdGlvbiBSZWZVbnJlZkZpbHRlcihjb250ZXh0KSB7XG4gIFBhc3NUaHJvdWdoLmNhbGwodGhpcyk7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuY29udGV4dC5yZWYoKTtcbiAgdGhpcy51bnJlZmZlZFlldCA9IGZhbHNlO1xufVxuUmVmVW5yZWZGaWx0ZXIucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uKGNiKSB7XG4gIHRoaXMudW5yZWYoKTtcbiAgY2IoKTtcbn07XG5SZWZVbnJlZkZpbHRlci5wcm90b3R5cGUudW5yZWYgPSBmdW5jdGlvbihjYikge1xuICBpZiAodGhpcy51bnJlZmZlZFlldCkgcmV0dXJuO1xuICB0aGlzLnVucmVmZmVkWWV0ID0gdHJ1ZTtcbiAgdGhpcy5jb250ZXh0LnVucmVmKCk7XG59O1xuXG52YXIgY3A0MzcgPSAnXFx1MDAwMOKYuuKYu+KZpeKZpuKZo+KZoOKAouKXmOKXi+KXmeKZguKZgOKZquKZq+KYvOKWuuKXhOKGleKAvMK2wqfilqzihqjihpHihpPihpLihpDiiJ/ihpTilrLilrwgIVwiIyQlJlxcJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXFxcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fuKMgsOHw7zDqcOiw6TDoMOlw6fDqsOrw6jDr8Ouw6zDhMOFw4nDpsOGw7TDtsOyw7vDucO/w5bDnMKiwqPCpeKCp8aSw6HDrcOzw7rDscORwqrCusK/4oyQwqzCvcK8wqHCq8K74paR4paS4paT4pSC4pSk4pWh4pWi4pWW4pWV4pWj4pWR4pWX4pWd4pWc4pWb4pSQ4pSU4pS04pSs4pSc4pSA4pS84pWe4pWf4pWa4pWU4pWp4pWm4pWg4pWQ4pWs4pWn4pWo4pWk4pWl4pWZ4pWY4pWS4pWT4pWr4pWq4pSY4pSM4paI4paE4paM4paQ4paAzrHDn86Tz4DOo8+DwrXPhM6mzpjOqc604oiez4bOteKIqeKJocKx4oml4omk4oyg4oyhw7fiiYjCsOKImcK34oia4oG/wrLilqDCoCc7XG5mdW5jdGlvbiBkZWNvZGVCdWZmZXIoYnVmZmVyLCBzdGFydCwgZW5kLCBpc1V0ZjgpIHtcbiAgaWYgKGlzVXRmOCkge1xuICAgIHJldHVybiBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIHN0YXJ0LCBlbmQpO1xuICB9IGVsc2Uge1xuICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICByZXN1bHQgKz0gY3A0MzdbYnVmZmVyW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWFkVUludDY0TEUoYnVmZmVyLCBvZmZzZXQpIHtcbiAgLy8gdGhlcmUgaXMgbm8gbmF0aXZlIGZ1bmN0aW9uIGZvciB0aGlzLCBiZWNhdXNlIHdlIGNhbid0IGFjdHVhbGx5IHN0b3JlIDY0LWJpdCBpbnRlZ2VycyBwcmVjaXNlbHkuXG4gIC8vIGFmdGVyIDUzIGJpdHMsIEphdmFTY3JpcHQncyBOdW1iZXIgdHlwZSAoSUVFRSA3NTQgZG91YmxlKSBjYW4ndCBzdG9yZSBpbmRpdmlkdWFsIGludGVnZXJzIGFueW1vcmUuXG4gIC8vIGJ1dCBzaW5jZSA1MyBiaXRzIGlzIGEgd2hvbGUgbG90IG1vcmUgdGhhbiAzMiBiaXRzLCB3ZSBkbyBvdXIgYmVzdCBhbnl3YXkuXG4gIHZhciBsb3dlcjMyID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQpO1xuICB2YXIgdXBwZXIzMiA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0ICsgNCk7XG4gIC8vIHdlIGNhbid0IHVzZSBiaXRzaGlmdGluZyBoZXJlLCBiZWNhdXNlIEphdmFTY3JpcHQgYml0c2hpZnRpbmcgb25seSB3b3JrcyBvbiAzMi1iaXQgaW50ZWdlcnMuXG4gIHJldHVybiB1cHBlcjMyICogMHgxMDAwMDAwMDAgKyBsb3dlcjMyO1xuICAvLyBhcyBsb25nIGFzIHdlJ3JlIGJvdW5kcyBjaGVja2luZyB0aGUgcmVzdWx0IG9mIHRoaXMgZnVuY3Rpb24gYWdhaW5zdCB0aGUgdG90YWwgZmlsZSBzaXplLFxuICAvLyB3ZSdsbCBjYXRjaCBhbnkgb3ZlcmZsb3cgZXJyb3JzLCBiZWNhdXNlIHdlIGFscmVhZHkgbWFkZSBzdXJlIHRoZSB0b3RhbCBmaWxlIHNpemUgd2FzIHdpdGhpbiByZWFzb24uXG59XG5cbi8vIE5vZGUgMTAgZGVwcmVjYXRlZCBuZXcgQnVmZmVyKCkuXG52YXIgbmV3QnVmZmVyO1xuaWYgKHR5cGVvZiBCdWZmZXIuYWxsb2NVbnNhZmUgPT09IFwiZnVuY3Rpb25cIikge1xuICBuZXdCdWZmZXIgPSBmdW5jdGlvbihsZW4pIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbik7XG4gIH07XG59IGVsc2Uge1xuICBuZXdCdWZmZXIgPSBmdW5jdGlvbihsZW4pIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihsZW4pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q2FsbGJhY2soZXJyKSB7XG4gIGlmIChlcnIpIHRocm93IGVycjtcbn1cbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBDUkNfVEFCTEUgPSBbXG4gIDB4MDAwMDAwMDAsIDB4NzcwNzMwOTYsIDB4ZWUwZTYxMmMsIDB4OTkwOTUxYmEsIDB4MDc2ZGM0MTksXG4gIDB4NzA2YWY0OGYsIDB4ZTk2M2E1MzUsIDB4OWU2NDk1YTMsIDB4MGVkYjg4MzIsIDB4NzlkY2I4YTQsXG4gIDB4ZTBkNWU5MWUsIDB4OTdkMmQ5ODgsIDB4MDliNjRjMmIsIDB4N2ViMTdjYmQsIDB4ZTdiODJkMDcsXG4gIDB4OTBiZjFkOTEsIDB4MWRiNzEwNjQsIDB4NmFiMDIwZjIsIDB4ZjNiOTcxNDgsIDB4ODRiZTQxZGUsXG4gIDB4MWFkYWQ0N2QsIDB4NmRkZGU0ZWIsIDB4ZjRkNGI1NTEsIDB4ODNkMzg1YzcsIDB4MTM2Yzk4NTYsXG4gIDB4NjQ2YmE4YzAsIDB4ZmQ2MmY5N2EsIDB4OGE2NWM5ZWMsIDB4MTQwMTVjNGYsIDB4NjMwNjZjZDksXG4gIDB4ZmEwZjNkNjMsIDB4OGQwODBkZjUsIDB4M2I2ZTIwYzgsIDB4NGM2OTEwNWUsIDB4ZDU2MDQxZTQsXG4gIDB4YTI2NzcxNzIsIDB4M2MwM2U0ZDEsIDB4NGIwNGQ0NDcsIDB4ZDIwZDg1ZmQsIDB4YTUwYWI1NmIsXG4gIDB4MzViNWE4ZmEsIDB4NDJiMjk4NmMsIDB4ZGJiYmM5ZDYsIDB4YWNiY2Y5NDAsIDB4MzJkODZjZTMsXG4gIDB4NDVkZjVjNzUsIDB4ZGNkNjBkY2YsIDB4YWJkMTNkNTksIDB4MjZkOTMwYWMsIDB4NTFkZTAwM2EsXG4gIDB4YzhkNzUxODAsIDB4YmZkMDYxMTYsIDB4MjFiNGY0YjUsIDB4NTZiM2M0MjMsIDB4Y2ZiYTk1OTksXG4gIDB4YjhiZGE1MGYsIDB4MjgwMmI4OWUsIDB4NWYwNTg4MDgsIDB4YzYwY2Q5YjIsIDB4YjEwYmU5MjQsXG4gIDB4MmY2ZjdjODcsIDB4NTg2ODRjMTEsIDB4YzE2MTFkYWIsIDB4YjY2NjJkM2QsIDB4NzZkYzQxOTAsXG4gIDB4MDFkYjcxMDYsIDB4OThkMjIwYmMsIDB4ZWZkNTEwMmEsIDB4NzFiMTg1ODksIDB4MDZiNmI1MWYsXG4gIDB4OWZiZmU0YTUsIDB4ZThiOGQ0MzMsIDB4NzgwN2M5YTIsIDB4MGYwMGY5MzQsIDB4OTYwOWE4OGUsXG4gIDB4ZTEwZTk4MTgsIDB4N2Y2YTBkYmIsIDB4MDg2ZDNkMmQsIDB4OTE2NDZjOTcsIDB4ZTY2MzVjMDEsXG4gIDB4NmI2YjUxZjQsIDB4MWM2YzYxNjIsIDB4ODU2NTMwZDgsIDB4ZjI2MjAwNGUsIDB4NmMwNjk1ZWQsXG4gIDB4MWIwMWE1N2IsIDB4ODIwOGY0YzEsIDB4ZjUwZmM0NTcsIDB4NjViMGQ5YzYsIDB4MTJiN2U5NTAsXG4gIDB4OGJiZWI4ZWEsIDB4ZmNiOTg4N2MsIDB4NjJkZDFkZGYsIDB4MTVkYTJkNDksIDB4OGNkMzdjZjMsXG4gIDB4ZmJkNDRjNjUsIDB4NGRiMjYxNTgsIDB4M2FiNTUxY2UsIDB4YTNiYzAwNzQsIDB4ZDRiYjMwZTIsXG4gIDB4NGFkZmE1NDEsIDB4M2RkODk1ZDcsIDB4YTRkMWM0NmQsIDB4ZDNkNmY0ZmIsIDB4NDM2OWU5NmEsXG4gIDB4MzQ2ZWQ5ZmMsIDB4YWQ2Nzg4NDYsIDB4ZGE2MGI4ZDAsIDB4NDQwNDJkNzMsIDB4MzMwMzFkZTUsXG4gIDB4YWEwYTRjNWYsIDB4ZGQwZDdjYzksIDB4NTAwNTcxM2MsIDB4MjcwMjQxYWEsIDB4YmUwYjEwMTAsXG4gIDB4YzkwYzIwODYsIDB4NTc2OGI1MjUsIDB4MjA2Zjg1YjMsIDB4Yjk2NmQ0MDksIDB4Y2U2MWU0OWYsXG4gIDB4NWVkZWY5MGUsIDB4MjlkOWM5OTgsIDB4YjBkMDk4MjIsIDB4YzdkN2E4YjQsIDB4NTliMzNkMTcsXG4gIDB4MmViNDBkODEsIDB4YjdiZDVjM2IsIDB4YzBiYTZjYWQsIDB4ZWRiODgzMjAsIDB4OWFiZmIzYjYsXG4gIDB4MDNiNmUyMGMsIDB4NzRiMWQyOWEsIDB4ZWFkNTQ3MzksIDB4OWRkMjc3YWYsIDB4MDRkYjI2MTUsXG4gIDB4NzNkYzE2ODMsIDB4ZTM2MzBiMTIsIDB4OTQ2NDNiODQsIDB4MGQ2ZDZhM2UsIDB4N2E2YTVhYTgsXG4gIDB4ZTQwZWNmMGIsIDB4OTMwOWZmOWQsIDB4MGEwMGFlMjcsIDB4N2QwNzllYjEsIDB4ZjAwZjkzNDQsXG4gIDB4ODcwOGEzZDIsIDB4MWUwMWYyNjgsIDB4NjkwNmMyZmUsIDB4Zjc2MjU3NWQsIDB4ODA2NTY3Y2IsXG4gIDB4MTk2YzM2NzEsIDB4NmU2YjA2ZTcsIDB4ZmVkNDFiNzYsIDB4ODlkMzJiZTAsIDB4MTBkYTdhNWEsXG4gIDB4NjdkZDRhY2MsIDB4ZjliOWRmNmYsIDB4OGViZWVmZjksIDB4MTdiN2JlNDMsIDB4NjBiMDhlZDUsXG4gIDB4ZDZkNmEzZTgsIDB4YTFkMTkzN2UsIDB4MzhkOGMyYzQsIDB4NGZkZmYyNTIsIDB4ZDFiYjY3ZjEsXG4gIDB4YTZiYzU3NjcsIDB4M2ZiNTA2ZGQsIDB4NDhiMjM2NGIsIDB4ZDgwZDJiZGEsIDB4YWYwYTFiNGMsXG4gIDB4MzYwMzRhZjYsIDB4NDEwNDdhNjAsIDB4ZGY2MGVmYzMsIDB4YTg2N2RmNTUsIDB4MzE2ZThlZWYsXG4gIDB4NDY2OWJlNzksIDB4Y2I2MWIzOGMsIDB4YmM2NjgzMWEsIDB4MjU2ZmQyYTAsIDB4NTI2OGUyMzYsXG4gIDB4Y2MwYzc3OTUsIDB4YmIwYjQ3MDMsIDB4MjIwMjE2YjksIDB4NTUwNTI2MmYsIDB4YzViYTNiYmUsXG4gIDB4YjJiZDBiMjgsIDB4MmJiNDVhOTIsIDB4NWNiMzZhMDQsIDB4YzJkN2ZmYTcsIDB4YjVkMGNmMzEsXG4gIDB4MmNkOTllOGIsIDB4NWJkZWFlMWQsIDB4OWI2NGMyYjAsIDB4ZWM2M2YyMjYsIDB4NzU2YWEzOWMsXG4gIDB4MDI2ZDkzMGEsIDB4OWMwOTA2YTksIDB4ZWIwZTM2M2YsIDB4NzIwNzY3ODUsIDB4MDUwMDU3MTMsXG4gIDB4OTViZjRhODIsIDB4ZTJiODdhMTQsIDB4N2JiMTJiYWUsIDB4MGNiNjFiMzgsIDB4OTJkMjhlOWIsXG4gIDB4ZTVkNWJlMGQsIDB4N2NkY2VmYjcsIDB4MGJkYmRmMjEsIDB4ODZkM2QyZDQsIDB4ZjFkNGUyNDIsXG4gIDB4NjhkZGIzZjgsIDB4MWZkYTgzNmUsIDB4ODFiZTE2Y2QsIDB4ZjZiOTI2NWIsIDB4NmZiMDc3ZTEsXG4gIDB4MThiNzQ3NzcsIDB4ODgwODVhZTYsIDB4ZmYwZjZhNzAsIDB4NjYwNjNiY2EsIDB4MTEwMTBiNWMsXG4gIDB4OGY2NTllZmYsIDB4Zjg2MmFlNjksIDB4NjE2YmZmZDMsIDB4MTY2Y2NmNDUsIDB4YTAwYWUyNzgsXG4gIDB4ZDcwZGQyZWUsIDB4NGUwNDgzNTQsIDB4MzkwM2IzYzIsIDB4YTc2NzI2NjEsIDB4ZDA2MDE2ZjcsXG4gIDB4NDk2OTQ3NGQsIDB4M2U2ZTc3ZGIsIDB4YWVkMTZhNGEsIDB4ZDlkNjVhZGMsIDB4NDBkZjBiNjYsXG4gIDB4MzdkODNiZjAsIDB4YTliY2FlNTMsIDB4ZGViYjllYzUsIDB4NDdiMmNmN2YsIDB4MzBiNWZmZTksXG4gIDB4YmRiZGYyMWMsIDB4Y2FiYWMyOGEsIDB4NTNiMzkzMzAsIDB4MjRiNGEzYTYsIDB4YmFkMDM2MDUsXG4gIDB4Y2RkNzA2OTMsIDB4NTRkZTU3MjksIDB4MjNkOTY3YmYsIDB4YjM2NjdhMmUsIDB4YzQ2MTRhYjgsXG4gIDB4NWQ2ODFiMDIsIDB4MmE2ZjJiOTQsIDB4YjQwYmJlMzcsIDB4YzMwYzhlYTEsIDB4NWEwNWRmMWIsXG4gIDB4MmQwMmVmOGRcbl07XG5cbmlmICh0eXBlb2YgSW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgQ1JDX1RBQkxFID0gbmV3IEludDMyQXJyYXkoQ1JDX1RBQkxFKTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlQnVmZmVyKGlucHV0KSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG5cbiAgdmFyIGhhc05ld0J1ZmZlckFQSSA9XG4gICAgICB0eXBlb2YgQnVmZmVyLmFsbG9jID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgIHR5cGVvZiBCdWZmZXIuZnJvbSA9PT0gXCJmdW5jdGlvblwiO1xuXG4gIGlmICh0eXBlb2YgaW5wdXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gaGFzTmV3QnVmZmVyQVBJID8gQnVmZmVyLmFsbG9jKGlucHV0KSA6IG5ldyBCdWZmZXIoaW5wdXQpO1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBoYXNOZXdCdWZmZXJBUEkgPyBCdWZmZXIuZnJvbShpbnB1dCkgOiBuZXcgQnVmZmVyKGlucHV0KTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBtdXN0IGJlIGJ1ZmZlciwgbnVtYmVyLCBvciBzdHJpbmcsIHJlY2VpdmVkIFwiICtcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGlucHV0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBidWZmZXJpemVJbnQobnVtKSB7XG4gIHZhciB0bXAgPSBlbnN1cmVCdWZmZXIoNCk7XG4gIHRtcC53cml0ZUludDMyQkUobnVtLCAwKTtcbiAgcmV0dXJuIHRtcDtcbn1cblxuZnVuY3Rpb24gX2NyYzMyKGJ1ZiwgcHJldmlvdXMpIHtcbiAgYnVmID0gZW5zdXJlQnVmZmVyKGJ1Zik7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIocHJldmlvdXMpKSB7XG4gICAgcHJldmlvdXMgPSBwcmV2aW91cy5yZWFkVUludDMyQkUoMCk7XG4gIH1cbiAgdmFyIGNyYyA9IH5+cHJldmlvdXMgXiAtMTtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBidWYubGVuZ3RoOyBuKyspIHtcbiAgICBjcmMgPSBDUkNfVEFCTEVbKGNyYyBeIGJ1ZltuXSkgJiAweGZmXSBeIChjcmMgPj4+IDgpO1xuICB9XG4gIHJldHVybiAoY3JjIF4gLTEpO1xufVxuXG5mdW5jdGlvbiBjcmMzMigpIHtcbiAgcmV0dXJuIGJ1ZmZlcml6ZUludChfY3JjMzIuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG59XG5jcmMzMi5zaWduZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfY3JjMzIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5jcmMzMi51bnNpZ25lZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9jcmMzMi5hcHBseShudWxsLCBhcmd1bWVudHMpID4+PiAwO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmMzMjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==