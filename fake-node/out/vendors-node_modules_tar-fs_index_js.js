exports.id = "vendors-node_modules_tar-fs_index_js";
exports.ids = ["vendors-node_modules_tar-fs_index_js"];
exports.modules = {

/***/ "./node_modules/b4a/index.js":
/*!***********************************!*\
  !*** ./node_modules/b4a/index.js ***!
  \***********************************/
/***/ ((module) => {

function isBuffer(value) {
  return Buffer.isBuffer(value) || value instanceof Uint8Array
}

function isEncoding(encoding) {
  return Buffer.isEncoding(encoding)
}

function alloc(size, fill, encoding) {
  return Buffer.alloc(size, fill, encoding)
}

function allocUnsafe(size) {
  return Buffer.allocUnsafe(size)
}

function allocUnsafeSlow(size) {
  return Buffer.allocUnsafeSlow(size)
}

function byteLength(string, encoding) {
  return Buffer.byteLength(string, encoding)
}

function compare(a, b) {
  return Buffer.compare(a, b)
}

function concat(buffers, totalLength) {
  return Buffer.concat(buffers, totalLength)
}

function copy(source, target, targetStart, start, end) {
  return toBuffer(source).copy(target, targetStart, start, end)
}

function equals(a, b) {
  return toBuffer(a).equals(b)
}

function fill(buffer, value, offset, end, encoding) {
  return toBuffer(buffer).fill(value, offset, end, encoding)
}

function from(value, encodingOrOffset, length) {
  return Buffer.from(value, encodingOrOffset, length)
}

function includes(buffer, value, byteOffset, encoding) {
  return toBuffer(buffer).includes(value, byteOffset, encoding)
}

function indexOf(buffer, value, byfeOffset, encoding) {
  return toBuffer(buffer).indexOf(value, byfeOffset, encoding)
}

function lastIndexOf(buffer, value, byteOffset, encoding) {
  return toBuffer(buffer).lastIndexOf(value, byteOffset, encoding)
}

function swap16(buffer) {
  return toBuffer(buffer).swap16()
}

function swap32(buffer) {
  return toBuffer(buffer).swap32()
}

function swap64(buffer) {
  return toBuffer(buffer).swap64()
}

function toBuffer(buffer) {
  if (Buffer.isBuffer(buffer)) return buffer
  return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength)
}

function toString(buffer, encoding, start, end) {
  return toBuffer(buffer).toString(encoding, start, end)
}

function write(buffer, string, offset, length, encoding) {
  return toBuffer(buffer).write(string, offset, length, encoding)
}

function readDoubleBE(buffer, offset) {
  return toBuffer(buffer).readDoubleBE(offset)
}

function readDoubleLE(buffer, offset) {
  return toBuffer(buffer).readDoubleLE(offset)
}

function readFloatBE(buffer, offset) {
  return toBuffer(buffer).readFloatBE(offset)
}

function readFloatLE(buffer, offset) {
  return toBuffer(buffer).readFloatLE(offset)
}

function readInt32BE(buffer, offset) {
  return toBuffer(buffer).readInt32BE(offset)
}

function readInt32LE(buffer, offset) {
  return toBuffer(buffer).readInt32LE(offset)
}

function readUInt32BE(buffer, offset) {
  return toBuffer(buffer).readUInt32BE(offset)
}

function readUInt32LE(buffer, offset) {
  return toBuffer(buffer).readUInt32LE(offset)
}

function writeDoubleBE(buffer, value, offset) {
  return toBuffer(buffer).writeDoubleBE(value, offset)
}

function writeDoubleLE(buffer, value, offset) {
  return toBuffer(buffer).writeDoubleLE(value, offset)
}

function writeFloatBE(buffer, value, offset) {
  return toBuffer(buffer).writeFloatBE(value, offset)
}

function writeFloatLE(buffer, value, offset) {
  return toBuffer(buffer).writeFloatLE(value, offset)
}

function writeInt32BE(buffer, value, offset) {
  return toBuffer(buffer).writeInt32BE(value, offset)
}

function writeInt32LE(buffer, value, offset) {
  return toBuffer(buffer).writeInt32LE(value, offset)
}

function writeUInt32BE(buffer, value, offset) {
  return toBuffer(buffer).writeUInt32BE(value, offset)
}

function writeUInt32LE(buffer, value, offset) {
  return toBuffer(buffer).writeUInt32LE(value, offset)
}

module.exports = {
  isBuffer,
  isEncoding,
  alloc,
  allocUnsafe,
  allocUnsafeSlow,
  byteLength,
  compare,
  concat,
  copy,
  equals,
  fill,
  from,
  includes,
  indexOf,
  lastIndexOf,
  swap16,
  swap32,
  swap64,
  toBuffer,
  toString,
  write,
  readDoubleBE,
  readDoubleLE,
  readFloatBE,
  readFloatLE,
  readInt32BE,
  readInt32LE,
  readUInt32BE,
  readUInt32LE,
  writeDoubleBE,
  writeDoubleLE,
  writeFloatBE,
  writeFloatLE,
  writeInt32BE,
  writeInt32LE,
  writeUInt32BE,
  writeUInt32LE
}


/***/ }),

/***/ "./node_modules/fast-fifo/fixed-size.js":
/*!**********************************************!*\
  !*** ./node_modules/fast-fifo/fixed-size.js ***!
  \**********************************************/
/***/ ((module) => {

module.exports = class FixedFIFO {
  constructor (hwm) {
    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) throw new Error('Max size for a FixedFIFO should be a power of two')
    this.buffer = new Array(hwm)
    this.mask = hwm - 1
    this.top = 0
    this.btm = 0
    this.next = null
  }

  clear () {
    this.top = this.btm = 0
    this.next = null
    this.buffer.fill(undefined)
  }

  push (data) {
    if (this.buffer[this.top] !== undefined) return false
    this.buffer[this.top] = data
    this.top = (this.top + 1) & this.mask
    return true
  }

  shift () {
    const last = this.buffer[this.btm]
    if (last === undefined) return undefined
    this.buffer[this.btm] = undefined
    this.btm = (this.btm + 1) & this.mask
    return last
  }

  peek () {
    return this.buffer[this.btm]
  }

  isEmpty () {
    return this.buffer[this.btm] === undefined
  }
}


/***/ }),

/***/ "./node_modules/fast-fifo/index.js":
/*!*****************************************!*\
  !*** ./node_modules/fast-fifo/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const FixedFIFO = __webpack_require__(/*! ./fixed-size */ "./node_modules/fast-fifo/fixed-size.js")

module.exports = class FastFIFO {
  constructor (hwm) {
    this.hwm = hwm || 16
    this.head = new FixedFIFO(this.hwm)
    this.tail = this.head
    this.length = 0
  }

  clear () {
    this.head = this.tail
    this.head.clear()
    this.length = 0
  }

  push (val) {
    this.length++
    if (!this.head.push(val)) {
      const prev = this.head
      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length)
      this.head.push(val)
    }
  }

  shift () {
    if (this.length !== 0) this.length--
    const val = this.tail.shift()
    if (val === undefined && this.tail.next) {
      const next = this.tail.next
      this.tail.next = null
      this.tail = next
      return this.tail.shift()
    }

    return val
  }

  peek () {
    const val = this.tail.peek()
    if (val === undefined && this.tail.next) return this.tail.next.peek()
    return val
  }

  isEmpty () {
    return this.length === 0
  }
}


/***/ }),

/***/ "./node_modules/pump/index.js":
/*!************************************!*\
  !*** ./node_modules/pump/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var once = __webpack_require__(/*! once */ "./node_modules/once/once.js")
var eos = __webpack_require__(/*! end-of-stream */ "./node_modules/end-of-stream/index.js")
var fs

try {
  fs = __webpack_require__(/*! fs */ "fs") // we only need fs to get the ReadStream and WriteStream prototypes
} catch (e) {}

var noop = function () {}
var ancient = typeof process === 'undefined' ? false : /^v?\.0/.test(process.version)

var isFn = function (fn) {
  return typeof fn === 'function'
}

var isFS = function (stream) {
  if (!ancient) return false // newer node version do not need to care about fs is a special way
  if (!fs) return false // browser
  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)
}

var isRequest = function (stream) {
  return stream.setHeader && isFn(stream.abort)
}

var destroyer = function (stream, reading, writing, callback) {
  callback = once(callback)

  var closed = false
  stream.on('close', function () {
    closed = true
  })

  eos(stream, {readable: reading, writable: writing}, function (err) {
    if (err) return callback(err)
    closed = true
    callback()
  })

  var destroyed = false
  return function (err) {
    if (closed) return
    if (destroyed) return
    destroyed = true

    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks
    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy()

    callback(err || new Error('stream was destroyed'))
  }
}

var call = function (fn) {
  fn()
}

var pipe = function (from, to) {
  return from.pipe(to)
}

var pump = function () {
  var streams = Array.prototype.slice.call(arguments)
  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop

  if (Array.isArray(streams[0])) streams = streams[0]
  if (streams.length < 2) throw new Error('pump requires two streams per minimum')

  var error
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1
    var writing = i > 0
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err
      if (err) destroys.forEach(call)
      if (reading) return
      destroys.forEach(call)
      callback(error)
    })
  })

  return streams.reduce(pipe)
}

module.exports = pump


/***/ }),

/***/ "./node_modules/streamx/index.js":
/*!***************************************!*\
  !*** ./node_modules/streamx/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { EventEmitter } = __webpack_require__(/*! events */ "events")
const STREAM_DESTROYED = new Error('Stream was destroyed')
const PREMATURE_CLOSE = new Error('Premature close')

const FIFO = __webpack_require__(/*! fast-fifo */ "./node_modules/fast-fifo/index.js")
const TextDecoder = __webpack_require__(/*! text-decoder */ "./node_modules/text-decoder/index.js")

// if we do a future major, expect queue microtask to be there always, for now a bit defensive
const qmt = typeof queueMicrotask === 'undefined' ? fn => global.process.nextTick(fn) : queueMicrotask

/* eslint-disable no-multi-spaces */

// 29 bits used total (4 from shared, 14 from read, and 11 from write)
const MAX = ((1 << 29) - 1)

// Shared state
const OPENING       = 0b0001
const PREDESTROYING = 0b0010
const DESTROYING    = 0b0100
const DESTROYED     = 0b1000

const NOT_OPENING = MAX ^ OPENING
const NOT_PREDESTROYING = MAX ^ PREDESTROYING

// Read state (4 bit offset from shared state)
const READ_ACTIVE           = 0b00000000000001 << 4
const READ_UPDATING         = 0b00000000000010 << 4
const READ_PRIMARY          = 0b00000000000100 << 4
const READ_QUEUED           = 0b00000000001000 << 4
const READ_RESUMED          = 0b00000000010000 << 4
const READ_PIPE_DRAINED     = 0b00000000100000 << 4
const READ_ENDING           = 0b00000001000000 << 4
const READ_EMIT_DATA        = 0b00000010000000 << 4
const READ_EMIT_READABLE    = 0b00000100000000 << 4
const READ_EMITTED_READABLE = 0b00001000000000 << 4
const READ_DONE             = 0b00010000000000 << 4
const READ_NEXT_TICK        = 0b00100000000000 << 4
const READ_NEEDS_PUSH       = 0b01000000000000 << 4
const READ_READ_AHEAD       = 0b10000000000000 << 4

// Combined read state
const READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED
const READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH
const READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE
const READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED
const READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD

const READ_NOT_ACTIVE             = MAX ^ READ_ACTIVE
const READ_NON_PRIMARY            = MAX ^ READ_PRIMARY
const READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH)
const READ_PUSHED                 = MAX ^ READ_NEEDS_PUSH
const READ_PAUSED                 = MAX ^ READ_RESUMED
const READ_NOT_QUEUED             = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE)
const READ_NOT_ENDING             = MAX ^ READ_ENDING
const READ_PIPE_NOT_DRAINED       = MAX ^ READ_FLOWING
const READ_NOT_NEXT_TICK          = MAX ^ READ_NEXT_TICK
const READ_NOT_UPDATING           = MAX ^ READ_UPDATING
const READ_NO_READ_AHEAD          = MAX ^ READ_READ_AHEAD
const READ_PAUSED_NO_READ_AHEAD   = MAX ^ READ_RESUMED_READ_AHEAD

// Write state (18 bit offset, 4 bit offset from shared state and 14 from read state)
const WRITE_ACTIVE     = 0b00000000001 << 18
const WRITE_UPDATING   = 0b00000000010 << 18
const WRITE_PRIMARY    = 0b00000000100 << 18
const WRITE_QUEUED     = 0b00000001000 << 18
const WRITE_UNDRAINED  = 0b00000010000 << 18
const WRITE_DONE       = 0b00000100000 << 18
const WRITE_EMIT_DRAIN = 0b00001000000 << 18
const WRITE_NEXT_TICK  = 0b00010000000 << 18
const WRITE_WRITING    = 0b00100000000 << 18
const WRITE_FINISHING  = 0b01000000000 << 18
const WRITE_CORKED     = 0b10000000000 << 18

const WRITE_NOT_ACTIVE    = MAX ^ (WRITE_ACTIVE | WRITE_WRITING)
const WRITE_NON_PRIMARY   = MAX ^ WRITE_PRIMARY
const WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING)
const WRITE_DRAINED       = MAX ^ WRITE_UNDRAINED
const WRITE_NOT_QUEUED    = MAX ^ WRITE_QUEUED
const WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK
const WRITE_NOT_UPDATING  = MAX ^ WRITE_UPDATING
const WRITE_NOT_CORKED    = MAX ^ WRITE_CORKED

// Combined shared state
const ACTIVE = READ_ACTIVE | WRITE_ACTIVE
const NOT_ACTIVE = MAX ^ ACTIVE
const DONE = READ_DONE | WRITE_DONE
const DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING
const OPEN_STATUS = DESTROY_STATUS | OPENING
const AUTO_DESTROY = DESTROY_STATUS | DONE
const NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY
const ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK
const TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE
const IS_OPENING = OPEN_STATUS | TICKING

// Combined shared state and read state
const READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE
const READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED
const READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED
const READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE
const SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD
const READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE
const READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY
const READ_NEXT_TICK_OR_OPENING = READ_NEXT_TICK | OPENING

// Combined write state
const WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE
const WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED
const WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE
const WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE
const WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED
const WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE
const WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING
const WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE
const WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE
const WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY
const WRITE_DROP_DATA = WRITE_FINISHING | WRITE_DONE | DESTROY_STATUS

const asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator')

class WritableState {
  constructor (stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {
    this.stream = stream
    this.queue = new FIFO()
    this.highWaterMark = highWaterMark
    this.buffered = 0
    this.error = null
    this.pipeline = null
    this.drains = null // if we add more seldomly used helpers we might them into a subobject so its a single ptr
    this.byteLength = byteLengthWritable || byteLength || defaultByteLength
    this.map = mapWritable || map
    this.afterWrite = afterWrite.bind(this)
    this.afterUpdateNextTick = updateWriteNT.bind(this)
  }

  get ended () {
    return (this.stream._duplexState & WRITE_DONE) !== 0
  }

  push (data) {
    if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0) return false
    if (this.map !== null) data = this.map(data)

    this.buffered += this.byteLength(data)
    this.queue.push(data)

    if (this.buffered < this.highWaterMark) {
      this.stream._duplexState |= WRITE_QUEUED
      return true
    }

    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED
    return false
  }

  shift () {
    const data = this.queue.shift()

    this.buffered -= this.byteLength(data)
    if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED

    return data
  }

  end (data) {
    if (typeof data === 'function') this.stream.once('finish', data)
    else if (data !== undefined && data !== null) this.push(data)
    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY
  }

  autoBatch (data, cb) {
    const buffer = []
    const stream = this.stream

    buffer.push(data)
    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {
      buffer.push(stream._writableState.shift())
    }

    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null)
    stream._writev(buffer, cb)
  }

  update () {
    const stream = this.stream

    stream._duplexState |= WRITE_UPDATING

    do {
      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {
        const data = this.shift()
        stream._duplexState |= WRITE_ACTIVE_AND_WRITING
        stream._write(data, this.afterWrite)
      }

      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()
    } while (this.continueUpdate() === true)

    stream._duplexState &= WRITE_NOT_UPDATING
  }

  updateNonPrimary () {
    const stream = this.stream

    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {
      stream._duplexState = stream._duplexState | WRITE_ACTIVE
      stream._final(afterFinal.bind(this))
      return
    }

    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
        stream._duplexState |= ACTIVE
        stream._destroy(afterDestroy.bind(this))
      }
      return
    }

    if ((stream._duplexState & IS_OPENING) === OPENING) {
      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING
      stream._open(afterOpen.bind(this))
    }
  }

  continueUpdate () {
    if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false
    this.stream._duplexState &= WRITE_NOT_NEXT_TICK
    return true
  }

  updateCallback () {
    if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update()
    else this.updateNextTick()
  }

  updateNextTick () {
    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return
    this.stream._duplexState |= WRITE_NEXT_TICK
    if ((this.stream._duplexState & WRITE_UPDATING) === 0) qmt(this.afterUpdateNextTick)
  }
}

class ReadableState {
  constructor (stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {
    this.stream = stream
    this.queue = new FIFO()
    this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark
    this.buffered = 0
    this.readAhead = highWaterMark > 0
    this.error = null
    this.pipeline = null
    this.byteLength = byteLengthReadable || byteLength || defaultByteLength
    this.map = mapReadable || map
    this.pipeTo = null
    this.afterRead = afterRead.bind(this)
    this.afterUpdateNextTick = updateReadNT.bind(this)
  }

  get ended () {
    return (this.stream._duplexState & READ_DONE) !== 0
  }

  pipe (pipeTo, cb) {
    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination')
    if (typeof cb !== 'function') cb = null

    this.stream._duplexState |= READ_PIPE_DRAINED
    this.pipeTo = pipeTo
    this.pipeline = new Pipeline(this.stream, pipeTo, cb)

    if (cb) this.stream.on('error', noop) // We already error handle this so supress crashes

    if (isStreamx(pipeTo)) {
      pipeTo._writableState.pipeline = this.pipeline
      if (cb) pipeTo.on('error', noop) // We already error handle this so supress crashes
      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)) // TODO: just call finished from pipeTo itself
    } else {
      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo)
      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null) // onclose has a weird bool arg
      pipeTo.on('error', onerror)
      pipeTo.on('close', onclose)
      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline))
    }

    pipeTo.on('drain', afterDrain.bind(this))
    this.stream.emit('piping', pipeTo)
    pipeTo.emit('pipe', this.stream)
  }

  push (data) {
    const stream = this.stream

    if (data === null) {
      this.highWaterMark = 0
      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED
      return false
    }

    if (this.map !== null) {
      data = this.map(data)
      if (data === null) {
        stream._duplexState &= READ_PUSHED
        return this.buffered < this.highWaterMark
      }
    }

    this.buffered += this.byteLength(data)
    this.queue.push(data)

    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED

    return this.buffered < this.highWaterMark
  }

  shift () {
    const data = this.queue.shift()

    this.buffered -= this.byteLength(data)
    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED
    return data
  }

  unshift (data) {
    const pending = [this.map !== null ? this.map(data) : data]
    while (this.buffered > 0) pending.push(this.shift())

    for (let i = 0; i < pending.length - 1; i++) {
      const data = pending[i]
      this.buffered += this.byteLength(data)
      this.queue.push(data)
    }

    this.push(pending[pending.length - 1])
  }

  read () {
    const stream = this.stream

    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {
      const data = this.shift()
      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED
      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)
      return data
    }

    if (this.readAhead === false) {
      stream._duplexState |= READ_READ_AHEAD
      this.updateNextTick()
    }

    return null
  }

  drain () {
    const stream = this.stream

    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {
      const data = this.shift()
      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED
      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)
    }
  }

  update () {
    const stream = this.stream

    stream._duplexState |= READ_UPDATING

    do {
      this.drain()

      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {
        stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH
        stream._read(this.afterRead)
        this.drain()
      }

      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {
        stream._duplexState |= READ_EMITTED_READABLE
        stream.emit('readable')
      }

      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()
    } while (this.continueUpdate() === true)

    stream._duplexState &= READ_NOT_UPDATING
  }

  updateNonPrimary () {
    const stream = this.stream

    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {
      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING
      stream.emit('end')
      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING
      if (this.pipeTo !== null) this.pipeTo.end()
    }

    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
        stream._duplexState |= ACTIVE
        stream._destroy(afterDestroy.bind(this))
      }
      return
    }

    if ((stream._duplexState & IS_OPENING) === OPENING) {
      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING
      stream._open(afterOpen.bind(this))
    }
  }

  continueUpdate () {
    if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false
    this.stream._duplexState &= READ_NOT_NEXT_TICK
    return true
  }

  updateCallback () {
    if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update()
    else this.updateNextTick()
  }

  updateNextTickIfOpen () {
    if ((this.stream._duplexState & READ_NEXT_TICK_OR_OPENING) !== 0) return
    this.stream._duplexState |= READ_NEXT_TICK
    if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick)
  }

  updateNextTick () {
    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return
    this.stream._duplexState |= READ_NEXT_TICK
    if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick)
  }
}

class TransformState {
  constructor (stream) {
    this.data = null
    this.afterTransform = afterTransform.bind(stream)
    this.afterFinal = null
  }
}

class Pipeline {
  constructor (src, dst, cb) {
    this.from = src
    this.to = dst
    this.afterPipe = cb
    this.error = null
    this.pipeToFinished = false
  }

  finished () {
    this.pipeToFinished = true
  }

  done (stream, err) {
    if (err) this.error = err

    if (stream === this.to) {
      this.to = null

      if (this.from !== null) {
        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {
          this.from.destroy(this.error || new Error('Writable stream closed prematurely'))
        }
        return
      }
    }

    if (stream === this.from) {
      this.from = null

      if (this.to !== null) {
        if ((stream._duplexState & READ_DONE) === 0) {
          this.to.destroy(this.error || new Error('Readable stream closed before ending'))
        }
        return
      }
    }

    if (this.afterPipe !== null) this.afterPipe(this.error)
    this.to = this.from = this.afterPipe = null
  }
}

function afterDrain () {
  this.stream._duplexState |= READ_PIPE_DRAINED
  this.updateCallback()
}

function afterFinal (err) {
  const stream = this.stream
  if (err) stream.destroy(err)
  if ((stream._duplexState & DESTROY_STATUS) === 0) {
    stream._duplexState |= WRITE_DONE
    stream.emit('finish')
  }
  if ((stream._duplexState & AUTO_DESTROY) === DONE) {
    stream._duplexState |= DESTROYING
  }

  stream._duplexState &= WRITE_NOT_FINISHING

  // no need to wait the extra tick here, so we short circuit that
  if ((stream._duplexState & WRITE_UPDATING) === 0) this.update()
  else this.updateNextTick()
}

function afterDestroy (err) {
  const stream = this.stream

  if (!err && this.error !== STREAM_DESTROYED) err = this.error
  if (err) stream.emit('error', err)
  stream._duplexState |= DESTROYED
  stream.emit('close')

  const rs = stream._readableState
  const ws = stream._writableState

  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err)

  if (ws !== null) {
    while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false)
    if (ws.pipeline !== null) ws.pipeline.done(stream, err)
  }
}

function afterWrite (err) {
  const stream = this.stream

  if (err) stream.destroy(err)
  stream._duplexState &= WRITE_NOT_ACTIVE

  if (this.drains !== null) tickDrains(this.drains)

  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {
    stream._duplexState &= WRITE_DRAINED
    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {
      stream.emit('drain')
    }
  }

  this.updateCallback()
}

function afterRead (err) {
  if (err) this.stream.destroy(err)
  this.stream._duplexState &= READ_NOT_ACTIVE
  if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD
  this.updateCallback()
}

function updateReadNT () {
  if ((this.stream._duplexState & READ_UPDATING) === 0) {
    this.stream._duplexState &= READ_NOT_NEXT_TICK
    this.update()
  }
}

function updateWriteNT () {
  if ((this.stream._duplexState & WRITE_UPDATING) === 0) {
    this.stream._duplexState &= WRITE_NOT_NEXT_TICK
    this.update()
  }
}

function tickDrains (drains) {
  for (let i = 0; i < drains.length; i++) {
    // drains.writes are monotonic, so if one is 0 its always the first one
    if (--drains[i].writes === 0) {
      drains.shift().resolve(true)
      i--
    }
  }
}

function afterOpen (err) {
  const stream = this.stream

  if (err) stream.destroy(err)

  if ((stream._duplexState & DESTROYING) === 0) {
    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY
    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY
    stream.emit('open')
  }

  stream._duplexState &= NOT_ACTIVE

  if (stream._writableState !== null) {
    stream._writableState.updateCallback()
  }

  if (stream._readableState !== null) {
    stream._readableState.updateCallback()
  }
}

function afterTransform (err, data) {
  if (data !== undefined && data !== null) this.push(data)
  this._writableState.afterWrite(err)
}

function newListener (name) {
  if (this._readableState !== null) {
    if (name === 'data') {
      this._duplexState |= (READ_EMIT_DATA | READ_RESUMED_READ_AHEAD)
      this._readableState.updateNextTick()
    }
    if (name === 'readable') {
      this._duplexState |= READ_EMIT_READABLE
      this._readableState.updateNextTick()
    }
  }

  if (this._writableState !== null) {
    if (name === 'drain') {
      this._duplexState |= WRITE_EMIT_DRAIN
      this._writableState.updateNextTick()
    }
  }
}

class Stream extends EventEmitter {
  constructor (opts) {
    super()

    this._duplexState = 0
    this._readableState = null
    this._writableState = null

    if (opts) {
      if (opts.open) this._open = opts.open
      if (opts.destroy) this._destroy = opts.destroy
      if (opts.predestroy) this._predestroy = opts.predestroy
      if (opts.signal) {
        opts.signal.addEventListener('abort', abort.bind(this))
      }
    }

    this.on('newListener', newListener)
  }

  _open (cb) {
    cb(null)
  }

  _destroy (cb) {
    cb(null)
  }

  _predestroy () {
    // does nothing
  }

  get readable () {
    return this._readableState !== null ? true : undefined
  }

  get writable () {
    return this._writableState !== null ? true : undefined
  }

  get destroyed () {
    return (this._duplexState & DESTROYED) !== 0
  }

  get destroying () {
    return (this._duplexState & DESTROY_STATUS) !== 0
  }

  destroy (err) {
    if ((this._duplexState & DESTROY_STATUS) === 0) {
      if (!err) err = STREAM_DESTROYED
      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY

      if (this._readableState !== null) {
        this._readableState.highWaterMark = 0
        this._readableState.error = err
      }
      if (this._writableState !== null) {
        this._writableState.highWaterMark = 0
        this._writableState.error = err
      }

      this._duplexState |= PREDESTROYING
      this._predestroy()
      this._duplexState &= NOT_PREDESTROYING

      if (this._readableState !== null) this._readableState.updateNextTick()
      if (this._writableState !== null) this._writableState.updateNextTick()
    }
  }
}

class Readable extends Stream {
  constructor (opts) {
    super(opts)

    this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD
    this._readableState = new ReadableState(this, opts)

    if (opts) {
      if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD
      if (opts.read) this._read = opts.read
      if (opts.eagerOpen) this._readableState.updateNextTick()
      if (opts.encoding) this.setEncoding(opts.encoding)
    }
  }

  setEncoding (encoding) {
    const dec = new TextDecoder(encoding)
    const map = this._readableState.map || echo
    this._readableState.map = mapOrSkip
    return this

    function mapOrSkip (data) {
      const next = dec.push(data)
      return next === '' && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next)
    }
  }

  _read (cb) {
    cb(null)
  }

  pipe (dest, cb) {
    this._readableState.updateNextTick()
    this._readableState.pipe(dest, cb)
    return dest
  }

  read () {
    this._readableState.updateNextTick()
    return this._readableState.read()
  }

  push (data) {
    this._readableState.updateNextTickIfOpen()
    return this._readableState.push(data)
  }

  unshift (data) {
    this._readableState.updateNextTickIfOpen()
    return this._readableState.unshift(data)
  }

  resume () {
    this._duplexState |= READ_RESUMED_READ_AHEAD
    this._readableState.updateNextTick()
    return this
  }

  pause () {
    this._duplexState &= (this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED)
    return this
  }

  static _fromAsyncIterator (ite, opts) {
    let destroy

    const rs = new Readable({
      ...opts,
      read (cb) {
        ite.next().then(push).then(cb.bind(null, null)).catch(cb)
      },
      predestroy () {
        destroy = ite.return()
      },
      destroy (cb) {
        if (!destroy) return cb(null)
        destroy.then(cb.bind(null, null)).catch(cb)
      }
    })

    return rs

    function push (data) {
      if (data.done) rs.push(null)
      else rs.push(data.value)
    }
  }

  static from (data, opts) {
    if (isReadStreamx(data)) return data
    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts)
    if (!Array.isArray(data)) data = data === undefined ? [] : [data]

    let i = 0
    return new Readable({
      ...opts,
      read (cb) {
        this.push(i === data.length ? null : data[i++])
        cb(null)
      }
    })
  }

  static isBackpressured (rs) {
    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark
  }

  static isPaused (rs) {
    return (rs._duplexState & READ_RESUMED) === 0
  }

  [asyncIterator] () {
    const stream = this

    let error = null
    let promiseResolve = null
    let promiseReject = null

    this.on('error', (err) => { error = err })
    this.on('readable', onreadable)
    this.on('close', onclose)

    return {
      [asyncIterator] () {
        return this
      },
      next () {
        return new Promise(function (resolve, reject) {
          promiseResolve = resolve
          promiseReject = reject
          const data = stream.read()
          if (data !== null) ondata(data)
          else if ((stream._duplexState & DESTROYED) !== 0) ondata(null)
        })
      },
      return () {
        return destroy(null)
      },
      throw (err) {
        return destroy(err)
      }
    }

    function onreadable () {
      if (promiseResolve !== null) ondata(stream.read())
    }

    function onclose () {
      if (promiseResolve !== null) ondata(null)
    }

    function ondata (data) {
      if (promiseReject === null) return
      if (error) promiseReject(error)
      else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED)
      else promiseResolve({ value: data, done: data === null })
      promiseReject = promiseResolve = null
    }

    function destroy (err) {
      stream.destroy(err)
      return new Promise((resolve, reject) => {
        if (stream._duplexState & DESTROYED) return resolve({ value: undefined, done: true })
        stream.once('close', function () {
          if (err) reject(err)
          else resolve({ value: undefined, done: true })
        })
      })
    }
  }
}

class Writable extends Stream {
  constructor (opts) {
    super(opts)

    this._duplexState |= OPENING | READ_DONE
    this._writableState = new WritableState(this, opts)

    if (opts) {
      if (opts.writev) this._writev = opts.writev
      if (opts.write) this._write = opts.write
      if (opts.final) this._final = opts.final
      if (opts.eagerOpen) this._writableState.updateNextTick()
    }
  }

  cork () {
    this._duplexState |= WRITE_CORKED
  }

  uncork () {
    this._duplexState &= WRITE_NOT_CORKED
    this._writableState.updateNextTick()
  }

  _writev (batch, cb) {
    cb(null)
  }

  _write (data, cb) {
    this._writableState.autoBatch(data, cb)
  }

  _final (cb) {
    cb(null)
  }

  static isBackpressured (ws) {
    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0
  }

  static drained (ws) {
    if (ws.destroyed) return Promise.resolve(false)
    const state = ws._writableState
    const pending = (isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length)
    const writes = pending + ((ws._duplexState & WRITE_WRITING) ? 1 : 0)
    if (writes === 0) return Promise.resolve(true)
    if (state.drains === null) state.drains = []
    return new Promise((resolve) => {
      state.drains.push({ writes, resolve })
    })
  }

  write (data) {
    this._writableState.updateNextTick()
    return this._writableState.push(data)
  }

  end (data) {
    this._writableState.updateNextTick()
    this._writableState.end(data)
    return this
  }
}

class Duplex extends Readable { // and Writable
  constructor (opts) {
    super(opts)

    this._duplexState = OPENING | (this._duplexState & READ_READ_AHEAD)
    this._writableState = new WritableState(this, opts)

    if (opts) {
      if (opts.writev) this._writev = opts.writev
      if (opts.write) this._write = opts.write
      if (opts.final) this._final = opts.final
    }
  }

  cork () {
    this._duplexState |= WRITE_CORKED
  }

  uncork () {
    this._duplexState &= WRITE_NOT_CORKED
    this._writableState.updateNextTick()
  }

  _writev (batch, cb) {
    cb(null)
  }

  _write (data, cb) {
    this._writableState.autoBatch(data, cb)
  }

  _final (cb) {
    cb(null)
  }

  write (data) {
    this._writableState.updateNextTick()
    return this._writableState.push(data)
  }

  end (data) {
    this._writableState.updateNextTick()
    this._writableState.end(data)
    return this
  }
}

class Transform extends Duplex {
  constructor (opts) {
    super(opts)
    this._transformState = new TransformState(this)

    if (opts) {
      if (opts.transform) this._transform = opts.transform
      if (opts.flush) this._flush = opts.flush
    }
  }

  _write (data, cb) {
    if (this._readableState.buffered >= this._readableState.highWaterMark) {
      this._transformState.data = data
    } else {
      this._transform(data, this._transformState.afterTransform)
    }
  }

  _read (cb) {
    if (this._transformState.data !== null) {
      const data = this._transformState.data
      this._transformState.data = null
      cb(null)
      this._transform(data, this._transformState.afterTransform)
    } else {
      cb(null)
    }
  }

  destroy (err) {
    super.destroy(err)
    if (this._transformState.data !== null) {
      this._transformState.data = null
      this._transformState.afterTransform()
    }
  }

  _transform (data, cb) {
    cb(null, data)
  }

  _flush (cb) {
    cb(null)
  }

  _final (cb) {
    this._transformState.afterFinal = cb
    this._flush(transformAfterFlush.bind(this))
  }
}

class PassThrough extends Transform {}

function transformAfterFlush (err, data) {
  const cb = this._transformState.afterFinal
  if (err) return cb(err)
  if (data !== null && data !== undefined) this.push(data)
  this.push(null)
  cb(null)
}

function pipelinePromise (...streams) {
  return new Promise((resolve, reject) => {
    return pipeline(...streams, (err) => {
      if (err) return reject(err)
      resolve()
    })
  })
}

function pipeline (stream, ...streams) {
  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams]
  const done = (all.length && typeof all[all.length - 1] === 'function') ? all.pop() : null

  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams')

  let src = all[0]
  let dest = null
  let error = null

  for (let i = 1; i < all.length; i++) {
    dest = all[i]

    if (isStreamx(src)) {
      src.pipe(dest, onerror)
    } else {
      errorHandle(src, true, i > 1, onerror)
      src.pipe(dest)
    }

    src = dest
  }

  if (done) {
    let fin = false

    const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy)

    dest.on('error', (err) => {
      if (error === null) error = err
    })

    dest.on('finish', () => {
      fin = true
      if (!autoDestroy) done(error)
    })

    if (autoDestroy) {
      dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)))
    }
  }

  return dest

  function errorHandle (s, rd, wr, onerror) {
    s.on('error', onerror)
    s.on('close', onclose)

    function onclose () {
      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE)
      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE)
    }
  }

  function onerror (err) {
    if (!err || error) return
    error = err

    for (const s of all) {
      s.destroy(err)
    }
  }
}

function echo (s) {
  return s
}

function isStream (stream) {
  return !!stream._readableState || !!stream._writableState
}

function isStreamx (stream) {
  return typeof stream._duplexState === 'number' && isStream(stream)
}

function isEnded (stream) {
  return !!stream._readableState && stream._readableState.ended
}

function isFinished (stream) {
  return !!stream._writableState && stream._writableState.ended
}

function getStreamError (stream, opts = {}) {
  const err = (stream._readableState && stream._readableState.error) || (stream._writableState && stream._writableState.error)

  // avoid implicit errors by default
  return (!opts.all && err === STREAM_DESTROYED) ? null : err
}

function isReadStreamx (stream) {
  return isStreamx(stream) && stream.readable
}

function isDisturbed (stream) {
  return (stream._duplexState & OPENING) !== OPENING || (stream._duplexState & ACTIVE_OR_TICKING) !== 0
}

function isTypedArray (data) {
  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number'
}

function defaultByteLength (data) {
  return isTypedArray(data) ? data.byteLength : 1024
}

function noop () {}

function abort () {
  this.destroy(new Error('Stream aborted.'))
}

function isWritev (s) {
  return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev
}

module.exports = {
  pipeline,
  pipelinePromise,
  isStream,
  isStreamx,
  isEnded,
  isFinished,
  isDisturbed,
  getStreamError,
  Stream,
  Writable,
  Readable,
  Duplex,
  Transform,
  // Export PassThrough for compatibility with Node.js core's stream module
  PassThrough
}


/***/ }),

/***/ "./node_modules/tar-fs/index.js":
/*!**************************************!*\
  !*** ./node_modules/tar-fs/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const tar = __webpack_require__(/*! tar-stream */ "./node_modules/tar-stream/index.js")
const pump = __webpack_require__(/*! pump */ "./node_modules/pump/index.js")
const fs = __webpack_require__(/*! fs */ "fs")
const path = __webpack_require__(/*! path */ "path")

const win32 = (global.Bare ? global.Bare.platform : process.platform) === 'win32'

exports.pack = function pack (cwd, opts) {
  if (!cwd) cwd = '.'
  if (!opts) opts = {}

  const xfs = opts.fs || fs
  const ignore = opts.ignore || opts.filter || noop
  const mapStream = opts.mapStream || echo
  const statNext = statAll(xfs, opts.dereference ? xfs.stat : xfs.lstat, cwd, ignore, opts.entries, opts.sort)
  const strict = opts.strict !== false
  const umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask()
  const pack = opts.pack || tar.pack()
  const finish = opts.finish || noop

  let map = opts.map || noop
  let dmode = typeof opts.dmode === 'number' ? opts.dmode : 0
  let fmode = typeof opts.fmode === 'number' ? opts.fmode : 0

  if (opts.strip) map = strip(map, opts.strip)

  if (opts.readable) {
    dmode |= parseInt(555, 8)
    fmode |= parseInt(444, 8)
  }
  if (opts.writable) {
    dmode |= parseInt(333, 8)
    fmode |= parseInt(222, 8)
  }

  onnextentry()

  function onsymlink (filename, header) {
    xfs.readlink(path.join(cwd, filename), function (err, linkname) {
      if (err) return pack.destroy(err)
      header.linkname = normalize(linkname)
      pack.entry(header, onnextentry)
    })
  }

  function onstat (err, filename, stat) {
    if (pack.destroyed) return
    if (err) return pack.destroy(err)
    if (!filename) {
      if (opts.finalize !== false) pack.finalize()
      return finish(pack)
    }

    if (stat.isSocket()) return onnextentry() // tar does not support sockets...

    let header = {
      name: normalize(filename),
      mode: (stat.mode | (stat.isDirectory() ? dmode : fmode)) & umask,
      mtime: stat.mtime,
      size: stat.size,
      type: 'file',
      uid: stat.uid,
      gid: stat.gid
    }

    if (stat.isDirectory()) {
      header.size = 0
      header.type = 'directory'
      header = map(header) || header
      return pack.entry(header, onnextentry)
    }

    if (stat.isSymbolicLink()) {
      header.size = 0
      header.type = 'symlink'
      header = map(header) || header
      return onsymlink(filename, header)
    }

    // TODO: add fifo etc...

    header = map(header) || header

    if (!stat.isFile()) {
      if (strict) return pack.destroy(new Error('unsupported type for ' + filename))
      return onnextentry()
    }

    const entry = pack.entry(header, onnextentry)
    const rs = mapStream(xfs.createReadStream(path.join(cwd, filename), { start: 0, end: header.size > 0 ? header.size - 1 : header.size }), header)

    rs.on('error', function (err) { // always forward errors on destroy
      entry.destroy(err)
    })

    pump(rs, entry)
  }

  function onnextentry (err) {
    if (err) return pack.destroy(err)
    statNext(onstat)
  }

  return pack
}

function head (list) {
  return list.length ? list[list.length - 1] : null
}

function processGetuid () {
  return (!global.Bare && process.getuid) ? process.getuid() : -1
}

function processUmask () {
  return (!global.Bare && process.umask) ? process.umask() : 0
}

exports.extract = function extract (cwd, opts) {
  if (!cwd) cwd = '.'
  if (!opts) opts = {}

  cwd = path.resolve(cwd)

  const xfs = opts.fs || fs
  const ignore = opts.ignore || opts.filter || noop
  const mapStream = opts.mapStream || echo
  const own = opts.chown !== false && !win32 && processGetuid() === 0
  const extract = opts.extract || tar.extract()
  const stack = []
  const now = new Date()
  const umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask()
  const strict = opts.strict !== false
  const validateSymLinks = opts.validateSymlinks !== false

  let map = opts.map || noop
  let dmode = typeof opts.dmode === 'number' ? opts.dmode : 0
  let fmode = typeof opts.fmode === 'number' ? opts.fmode : 0

  if (opts.strip) map = strip(map, opts.strip)

  if (opts.readable) {
    dmode |= parseInt(555, 8)
    fmode |= parseInt(444, 8)
  }
  if (opts.writable) {
    dmode |= parseInt(333, 8)
    fmode |= parseInt(222, 8)
  }

  extract.on('entry', onentry)

  if (opts.finish) extract.on('finish', opts.finish)

  return extract

  function onentry (header, stream, next) {
    header = map(header) || header
    header.name = normalize(header.name)

    const name = path.join(cwd, path.join('/', header.name))

    if (ignore(name, header)) {
      stream.resume()
      return next()
    }

    const dir = path.join(name, '.') === path.join(cwd, '.') ? cwd : path.dirname(name)

    validate(xfs, dir, path.join(cwd, '.'), function (err, valid) {
      if (err) return next(err)
      if (!valid) return next(new Error(dir + ' is not a valid path'))

      if (header.type === 'directory') {
        stack.push([name, header.mtime])
        return mkdirfix(name, {
          fs: xfs,
          own,
          uid: header.uid,
          gid: header.gid,
          mode: header.mode
        }, stat)
      }

      mkdirfix(dir, {
        fs: xfs,
        own,
        uid: header.uid,
        gid: header.gid,
        // normally, the folders with rights and owner should be part of the TAR file
        // if this is not the case, create folder for same user as file and with
        // standard permissions of 0o755 (rwxr-xr-x)
        mode: 0o755
      }, function (err) {
        if (err) return next(err)

        switch (header.type) {
          case 'file': return onfile()
          case 'link': return onlink()
          case 'symlink': return onsymlink()
        }

        if (strict) return next(new Error('unsupported type for ' + name + ' (' + header.type + ')'))

        stream.resume()
        next()
      })
    })

    function stat (err) {
      if (err) return next(err)
      utimes(name, header, function (err) {
        if (err) return next(err)
        if (win32) return next()
        chperm(name, header, next)
      })
    }

    function onsymlink () {
      if (win32) return next() // skip symlinks on win for now before it can be tested
      xfs.unlink(name, function () {
        const dst = path.resolve(path.dirname(name), header.linkname)
        if (!inCwd(dst) && validateSymLinks) return next(new Error(name + ' is not a valid symlink'))

        xfs.symlink(header.linkname, name, stat)
      })
    }

    function onlink () {
      if (win32) return next() // skip links on win for now before it can be tested
      xfs.unlink(name, function () {
        const link = path.join(cwd, path.join('/', header.linkname))

        fs.realpath(link, function (err, dst) {
          if (err || !inCwd(dst)) return next(new Error(name + ' is not a valid hardlink'))

          xfs.link(dst, name, function (err) {
            if (err && err.code === 'EPERM' && opts.hardlinkAsFilesFallback) {
              stream = xfs.createReadStream(dst)
              return onfile()
            }

            stat(err)
          })
        })
      })
    }

    function inCwd (dst) {
      return dst === cwd || dst.startsWith(cwd + path.sep)
    }

    function onfile () {
      const ws = xfs.createWriteStream(name)
      const rs = mapStream(stream, header)

      ws.on('error', function (err) { // always forward errors on destroy
        rs.destroy(err)
      })

      pump(rs, ws, function (err) {
        if (err) return next(err)
        ws.on('close', stat)
      })
    }
  }

  function utimesParent (name, cb) { // we just set the mtime on the parent dir again everytime we write an entry
    let top
    while ((top = head(stack)) && name.slice(0, top[0].length) !== top[0]) stack.pop()
    if (!top) return cb()
    xfs.utimes(top[0], now, top[1], cb)
  }

  function utimes (name, header, cb) {
    if (opts.utimes === false) return cb()

    if (header.type === 'directory') return xfs.utimes(name, now, header.mtime, cb)
    if (header.type === 'symlink') return utimesParent(name, cb) // TODO: how to set mtime on link?

    xfs.utimes(name, now, header.mtime, function (err) {
      if (err) return cb(err)
      utimesParent(name, cb)
    })
  }

  function chperm (name, header, cb) {
    const link = header.type === 'symlink'

    /* eslint-disable n/no-deprecated-api */
    const chmod = link ? xfs.lchmod : xfs.chmod
    const chown = link ? xfs.lchown : xfs.chown
    /* eslint-enable n/no-deprecated-api */

    if (!chmod) return cb()

    const mode = (header.mode | (header.type === 'directory' ? dmode : fmode)) & umask

    if (chown && own) chown.call(xfs, name, header.uid, header.gid, onchown)
    else onchown(null)

    function onchown (err) {
      if (err) return cb(err)
      if (!chmod) return cb()
      chmod.call(xfs, name, mode, cb)
    }
  }

  function mkdirfix (name, opts, cb) {
    // when mkdir is called on an existing directory, the permissions
    // will be overwritten (?), to avoid this we check for its existance first
    xfs.stat(name, function (err) {
      if (!err) return cb(null)
      if (err.code !== 'ENOENT') return cb(err)
      xfs.mkdir(name, { mode: opts.mode, recursive: true }, function (err, made) {
        if (err) return cb(err)
        chperm(name, opts, cb)
      })
    })
  }
}

function validate (fs, name, root, cb) {
  if (name === root) return cb(null, true)

  fs.lstat(name, function (err, st) {
    if (err && err.code !== 'ENOENT' && err.code !== 'EPERM') return cb(err)
    if (err || st.isDirectory()) return validate(fs, path.join(name, '..'), root, cb)
    cb(null, false)
  })
}

function noop () {}

function echo (name) {
  return name
}

function normalize (name) {
  return win32 ? name.replace(/\\/g, '/').replace(/[:?<>|]/g, '_') : name
}

function statAll (fs, stat, cwd, ignore, entries, sort) {
  if (!entries) entries = ['.']
  const queue = entries.slice(0)

  return function loop (callback) {
    if (!queue.length) return callback(null)

    const next = queue.shift()
    const nextAbs = path.join(cwd, next)

    stat.call(fs, nextAbs, function (err, stat) {
      // ignore errors if the files were deleted while buffering
      if (err) return callback(entries.indexOf(next) === -1 && err.code === 'ENOENT' ? null : err)

      if (!stat.isDirectory()) return callback(null, next, stat)

      fs.readdir(nextAbs, function (err, files) {
        if (err) return callback(err)

        if (sort) files.sort()

        for (let i = 0; i < files.length; i++) {
          if (!ignore(path.join(cwd, next, files[i]))) queue.push(path.join(next, files[i]))
        }

        callback(null, next, stat)
      })
    })
  }
}

function strip (map, level) {
  return function (header) {
    header.name = header.name.split('/').slice(level).join('/')

    const linkname = header.linkname
    if (linkname && (header.type === 'link' || path.isAbsolute(linkname))) {
      header.linkname = linkname.split('/').slice(level).join('/')
    }

    return map(header)
  }
}


/***/ }),

/***/ "./node_modules/tar-stream/constants.js":
/*!**********************************************!*\
  !*** ./node_modules/tar-stream/constants.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const constants = { // just for envs without fs
  S_IFMT: 61440,
  S_IFDIR: 16384,
  S_IFCHR: 8192,
  S_IFBLK: 24576,
  S_IFIFO: 4096,
  S_IFLNK: 40960
}

try {
  module.exports = (__webpack_require__(/*! fs */ "fs").constants) || constants
} catch {
  module.exports = constants
}


/***/ }),

/***/ "./node_modules/tar-stream/extract.js":
/*!********************************************!*\
  !*** ./node_modules/tar-stream/extract.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { Writable, Readable, getStreamError } = __webpack_require__(/*! streamx */ "./node_modules/streamx/index.js")
const FIFO = __webpack_require__(/*! fast-fifo */ "./node_modules/fast-fifo/index.js")
const b4a = __webpack_require__(/*! b4a */ "./node_modules/b4a/index.js")
const headers = __webpack_require__(/*! ./headers */ "./node_modules/tar-stream/headers.js")

const EMPTY = b4a.alloc(0)

class BufferList {
  constructor () {
    this.buffered = 0
    this.shifted = 0
    this.queue = new FIFO()

    this._offset = 0
  }

  push (buffer) {
    this.buffered += buffer.byteLength
    this.queue.push(buffer)
  }

  shiftFirst (size) {
    return this._buffered === 0 ? null : this._next(size)
  }

  shift (size) {
    if (size > this.buffered) return null
    if (size === 0) return EMPTY

    let chunk = this._next(size)

    if (size === chunk.byteLength) return chunk // likely case

    const chunks = [chunk]

    while ((size -= chunk.byteLength) > 0) {
      chunk = this._next(size)
      chunks.push(chunk)
    }

    return b4a.concat(chunks)
  }

  _next (size) {
    const buf = this.queue.peek()
    const rem = buf.byteLength - this._offset

    if (size >= rem) {
      const sub = this._offset ? buf.subarray(this._offset, buf.byteLength) : buf
      this.queue.shift()
      this._offset = 0
      this.buffered -= rem
      this.shifted += rem
      return sub
    }

    this.buffered -= size
    this.shifted += size

    return buf.subarray(this._offset, (this._offset += size))
  }
}

class Source extends Readable {
  constructor (self, header, offset) {
    super()

    this.header = header
    this.offset = offset

    this._parent = self
  }

  _read (cb) {
    if (this.header.size === 0) {
      this.push(null)
    }
    if (this._parent._stream === this) {
      this._parent._update()
    }
    cb(null)
  }

  _predestroy () {
    this._parent.destroy(getStreamError(this))
  }

  _detach () {
    if (this._parent._stream === this) {
      this._parent._stream = null
      this._parent._missing = overflow(this.header.size)
      this._parent._update()
    }
  }

  _destroy (cb) {
    this._detach()
    cb(null)
  }
}

class Extract extends Writable {
  constructor (opts) {
    super(opts)

    if (!opts) opts = {}

    this._buffer = new BufferList()
    this._offset = 0
    this._header = null
    this._stream = null
    this._missing = 0
    this._longHeader = false
    this._callback = noop
    this._locked = false
    this._finished = false
    this._pax = null
    this._paxGlobal = null
    this._gnuLongPath = null
    this._gnuLongLinkPath = null
    this._filenameEncoding = opts.filenameEncoding || 'utf-8'
    this._allowUnknownFormat = !!opts.allowUnknownFormat
    this._unlockBound = this._unlock.bind(this)
  }

  _unlock (err) {
    this._locked = false

    if (err) {
      this.destroy(err)
      this._continueWrite(err)
      return
    }

    this._update()
  }

  _consumeHeader () {
    if (this._locked) return false

    this._offset = this._buffer.shifted

    try {
      this._header = headers.decode(this._buffer.shift(512), this._filenameEncoding, this._allowUnknownFormat)
    } catch (err) {
      this._continueWrite(err)
      return false
    }

    if (!this._header) return true

    switch (this._header.type) {
      case 'gnu-long-path':
      case 'gnu-long-link-path':
      case 'pax-global-header':
      case 'pax-header':
        this._longHeader = true
        this._missing = this._header.size
        return true
    }

    this._locked = true
    this._applyLongHeaders()

    if (this._header.size === 0 || this._header.type === 'directory') {
      this.emit('entry', this._header, this._createStream(), this._unlockBound)
      return true
    }

    this._stream = this._createStream()
    this._missing = this._header.size

    this.emit('entry', this._header, this._stream, this._unlockBound)
    return true
  }

  _applyLongHeaders () {
    if (this._gnuLongPath) {
      this._header.name = this._gnuLongPath
      this._gnuLongPath = null
    }

    if (this._gnuLongLinkPath) {
      this._header.linkname = this._gnuLongLinkPath
      this._gnuLongLinkPath = null
    }

    if (this._pax) {
      if (this._pax.path) this._header.name = this._pax.path
      if (this._pax.linkpath) this._header.linkname = this._pax.linkpath
      if (this._pax.size) this._header.size = parseInt(this._pax.size, 10)
      this._header.pax = this._pax
      this._pax = null
    }
  }

  _decodeLongHeader (buf) {
    switch (this._header.type) {
      case 'gnu-long-path':
        this._gnuLongPath = headers.decodeLongPath(buf, this._filenameEncoding)
        break
      case 'gnu-long-link-path':
        this._gnuLongLinkPath = headers.decodeLongPath(buf, this._filenameEncoding)
        break
      case 'pax-global-header':
        this._paxGlobal = headers.decodePax(buf)
        break
      case 'pax-header':
        this._pax = this._paxGlobal === null
          ? headers.decodePax(buf)
          : Object.assign({}, this._paxGlobal, headers.decodePax(buf))
        break
    }
  }

  _consumeLongHeader () {
    this._longHeader = false
    this._missing = overflow(this._header.size)

    const buf = this._buffer.shift(this._header.size)

    try {
      this._decodeLongHeader(buf)
    } catch (err) {
      this._continueWrite(err)
      return false
    }

    return true
  }

  _consumeStream () {
    const buf = this._buffer.shiftFirst(this._missing)
    if (buf === null) return false

    this._missing -= buf.byteLength
    const drained = this._stream.push(buf)

    if (this._missing === 0) {
      this._stream.push(null)
      if (drained) this._stream._detach()
      return drained && this._locked === false
    }

    return drained
  }

  _createStream () {
    return new Source(this, this._header, this._offset)
  }

  _update () {
    while (this._buffer.buffered > 0 && !this.destroying) {
      if (this._missing > 0) {
        if (this._stream !== null) {
          if (this._consumeStream() === false) return
          continue
        }

        if (this._longHeader === true) {
          if (this._missing > this._buffer.buffered) break
          if (this._consumeLongHeader() === false) return false
          continue
        }

        const ignore = this._buffer.shiftFirst(this._missing)
        if (ignore !== null) this._missing -= ignore.byteLength
        continue
      }

      if (this._buffer.buffered < 512) break
      if (this._stream !== null || this._consumeHeader() === false) return
    }

    this._continueWrite(null)
  }

  _continueWrite (err) {
    const cb = this._callback
    this._callback = noop
    cb(err)
  }

  _write (data, cb) {
    this._callback = cb
    this._buffer.push(data)
    this._update()
  }

  _final (cb) {
    this._finished = this._missing === 0 && this._buffer.buffered === 0
    cb(this._finished ? null : new Error('Unexpected end of data'))
  }

  _predestroy () {
    this._continueWrite(null)
  }

  _destroy (cb) {
    if (this._stream) this._stream.destroy(getStreamError(this))
    cb(null)
  }

  [Symbol.asyncIterator] () {
    let error = null

    let promiseResolve = null
    let promiseReject = null

    let entryStream = null
    let entryCallback = null

    const extract = this

    this.on('entry', onentry)
    this.on('error', (err) => { error = err })
    this.on('close', onclose)

    return {
      [Symbol.asyncIterator] () {
        return this
      },
      next () {
        return new Promise(onnext)
      },
      return () {
        return destroy(null)
      },
      throw (err) {
        return destroy(err)
      }
    }

    function consumeCallback (err) {
      if (!entryCallback) return
      const cb = entryCallback
      entryCallback = null
      cb(err)
    }

    function onnext (resolve, reject) {
      if (error) {
        return reject(error)
      }

      if (entryStream) {
        resolve({ value: entryStream, done: false })
        entryStream = null
        return
      }

      promiseResolve = resolve
      promiseReject = reject

      consumeCallback(null)

      if (extract._finished && promiseResolve) {
        promiseResolve({ value: undefined, done: true })
        promiseResolve = promiseReject = null
      }
    }

    function onentry (header, stream, callback) {
      entryCallback = callback
      stream.on('error', noop) // no way around this due to tick sillyness

      if (promiseResolve) {
        promiseResolve({ value: stream, done: false })
        promiseResolve = promiseReject = null
      } else {
        entryStream = stream
      }
    }

    function onclose () {
      consumeCallback(error)
      if (!promiseResolve) return
      if (error) promiseReject(error)
      else promiseResolve({ value: undefined, done: true })
      promiseResolve = promiseReject = null
    }

    function destroy (err) {
      extract.destroy(err)
      consumeCallback(err)
      return new Promise((resolve, reject) => {
        if (extract.destroyed) return resolve({ value: undefined, done: true })
        extract.once('close', function () {
          if (err) reject(err)
          else resolve({ value: undefined, done: true })
        })
      })
    }
  }
}

module.exports = function extract (opts) {
  return new Extract(opts)
}

function noop () {}

function overflow (size) {
  size &= 511
  return size && 512 - size
}


/***/ }),

/***/ "./node_modules/tar-stream/headers.js":
/*!********************************************!*\
  !*** ./node_modules/tar-stream/headers.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const b4a = __webpack_require__(/*! b4a */ "./node_modules/b4a/index.js")

const ZEROS = '0000000000000000000'
const SEVENS = '7777777777777777777'
const ZERO_OFFSET = '0'.charCodeAt(0)
const USTAR_MAGIC = b4a.from([0x75, 0x73, 0x74, 0x61, 0x72, 0x00]) // ustar\x00
const USTAR_VER = b4a.from([ZERO_OFFSET, ZERO_OFFSET])
const GNU_MAGIC = b4a.from([0x75, 0x73, 0x74, 0x61, 0x72, 0x20]) // ustar\x20
const GNU_VER = b4a.from([0x20, 0x00])
const MASK = 0o7777
const MAGIC_OFFSET = 257
const VERSION_OFFSET = 263

exports.decodeLongPath = function decodeLongPath (buf, encoding) {
  return decodeStr(buf, 0, buf.length, encoding)
}

exports.encodePax = function encodePax (opts) { // TODO: encode more stuff in pax
  let result = ''
  if (opts.name) result += addLength(' path=' + opts.name + '\n')
  if (opts.linkname) result += addLength(' linkpath=' + opts.linkname + '\n')
  const pax = opts.pax
  if (pax) {
    for (const key in pax) {
      result += addLength(' ' + key + '=' + pax[key] + '\n')
    }
  }
  return b4a.from(result)
}

exports.decodePax = function decodePax (buf) {
  const result = {}

  while (buf.length) {
    let i = 0
    while (i < buf.length && buf[i] !== 32) i++
    const len = parseInt(b4a.toString(buf.subarray(0, i)), 10)
    if (!len) return result

    const b = b4a.toString(buf.subarray(i + 1, len - 1))
    const keyIndex = b.indexOf('=')
    if (keyIndex === -1) return result
    result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1)

    buf = buf.subarray(len)
  }

  return result
}

exports.encode = function encode (opts) {
  const buf = b4a.alloc(512)
  let name = opts.name
  let prefix = ''

  if (opts.typeflag === 5 && name[name.length - 1] !== '/') name += '/'
  if (b4a.byteLength(name) !== name.length) return null // utf-8

  while (b4a.byteLength(name) > 100) {
    const i = name.indexOf('/')
    if (i === -1) return null
    prefix += prefix ? '/' + name.slice(0, i) : name.slice(0, i)
    name = name.slice(i + 1)
  }

  if (b4a.byteLength(name) > 100 || b4a.byteLength(prefix) > 155) return null
  if (opts.linkname && b4a.byteLength(opts.linkname) > 100) return null

  b4a.write(buf, name)
  b4a.write(buf, encodeOct(opts.mode & MASK, 6), 100)
  b4a.write(buf, encodeOct(opts.uid, 6), 108)
  b4a.write(buf, encodeOct(opts.gid, 6), 116)
  encodeSize(opts.size, buf, 124)
  b4a.write(buf, encodeOct((opts.mtime.getTime() / 1000) | 0, 11), 136)

  buf[156] = ZERO_OFFSET + toTypeflag(opts.type)

  if (opts.linkname) b4a.write(buf, opts.linkname, 157)

  b4a.copy(USTAR_MAGIC, buf, MAGIC_OFFSET)
  b4a.copy(USTAR_VER, buf, VERSION_OFFSET)
  if (opts.uname) b4a.write(buf, opts.uname, 265)
  if (opts.gname) b4a.write(buf, opts.gname, 297)
  b4a.write(buf, encodeOct(opts.devmajor || 0, 6), 329)
  b4a.write(buf, encodeOct(opts.devminor || 0, 6), 337)

  if (prefix) b4a.write(buf, prefix, 345)

  b4a.write(buf, encodeOct(cksum(buf), 6), 148)

  return buf
}

exports.decode = function decode (buf, filenameEncoding, allowUnknownFormat) {
  let typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET

  let name = decodeStr(buf, 0, 100, filenameEncoding)
  const mode = decodeOct(buf, 100, 8)
  const uid = decodeOct(buf, 108, 8)
  const gid = decodeOct(buf, 116, 8)
  const size = decodeOct(buf, 124, 12)
  const mtime = decodeOct(buf, 136, 12)
  const type = toType(typeflag)
  const linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding)
  const uname = decodeStr(buf, 265, 32)
  const gname = decodeStr(buf, 297, 32)
  const devmajor = decodeOct(buf, 329, 8)
  const devminor = decodeOct(buf, 337, 8)

  const c = cksum(buf)

  // checksum is still initial value if header was null.
  if (c === 8 * 32) return null

  // valid checksum
  if (c !== decodeOct(buf, 148, 8)) throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?')

  if (isUSTAR(buf)) {
    // ustar (posix) format.
    // prepend prefix, if present.
    if (buf[345]) name = decodeStr(buf, 345, 155, filenameEncoding) + '/' + name
  } else if (isGNU(buf)) {
    // 'gnu'/'oldgnu' format. Similar to ustar, but has support for incremental and
    // multi-volume tarballs.
  } else {
    if (!allowUnknownFormat) {
      throw new Error('Invalid tar header: unknown format.')
    }
  }

  // to support old tar versions that use trailing / to indicate dirs
  if (typeflag === 0 && name && name[name.length - 1] === '/') typeflag = 5

  return {
    name,
    mode,
    uid,
    gid,
    size,
    mtime: new Date(1000 * mtime),
    type,
    linkname,
    uname,
    gname,
    devmajor,
    devminor,
    pax: null
  }
}

function isUSTAR (buf) {
  return b4a.equals(USTAR_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6))
}

function isGNU (buf) {
  return b4a.equals(GNU_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6)) &&
    b4a.equals(GNU_VER, buf.subarray(VERSION_OFFSET, VERSION_OFFSET + 2))
}

function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function toType (flag) {
  switch (flag) {
    case 0:
      return 'file'
    case 1:
      return 'link'
    case 2:
      return 'symlink'
    case 3:
      return 'character-device'
    case 4:
      return 'block-device'
    case 5:
      return 'directory'
    case 6:
      return 'fifo'
    case 7:
      return 'contiguous-file'
    case 72:
      return 'pax-header'
    case 55:
      return 'pax-global-header'
    case 27:
      return 'gnu-long-link-path'
    case 28:
    case 30:
      return 'gnu-long-path'
  }

  return null
}

function toTypeflag (flag) {
  switch (flag) {
    case 'file':
      return 0
    case 'link':
      return 1
    case 'symlink':
      return 2
    case 'character-device':
      return 3
    case 'block-device':
      return 4
    case 'directory':
      return 5
    case 'fifo':
      return 6
    case 'contiguous-file':
      return 7
    case 'pax-header':
      return 72
  }

  return 0
}

function indexOf (block, num, offset, end) {
  for (; offset < end; offset++) {
    if (block[offset] === num) return offset
  }
  return end
}

function cksum (block) {
  let sum = 8 * 32
  for (let i = 0; i < 148; i++) sum += block[i]
  for (let j = 156; j < 512; j++) sum += block[j]
  return sum
}

function encodeOct (val, n) {
  val = val.toString(8)
  if (val.length > n) return SEVENS.slice(0, n) + ' '
  return ZEROS.slice(0, n - val.length) + val + ' '
}

function encodeSizeBin (num, buf, off) {
  buf[off] = 0x80
  for (let i = 11; i > 0; i--) {
    buf[off + i] = num & 0xff
    num = Math.floor(num / 0x100)
  }
}

function encodeSize (num, buf, off) {
  if (num.toString(8).length > 11) {
    encodeSizeBin(num, buf, off)
  } else {
    b4a.write(buf, encodeOct(num, 11), off)
  }
}

/* Copied from the node-tar repo and modified to meet
 * tar-stream coding standard.
 *
 * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349
 */
function parse256 (buf) {
  // first byte MUST be either 80 or FF
  // 80 for positive, FF for 2's comp
  let positive
  if (buf[0] === 0x80) positive = true
  else if (buf[0] === 0xFF) positive = false
  else return null

  // build up a base-256 tuple from the least sig to the highest
  const tuple = []
  let i
  for (i = buf.length - 1; i > 0; i--) {
    const byte = buf[i]
    if (positive) tuple.push(byte)
    else tuple.push(0xFF - byte)
  }

  let sum = 0
  const l = tuple.length
  for (i = 0; i < l; i++) {
    sum += tuple[i] * Math.pow(256, i)
  }

  return positive ? sum : -1 * sum
}

function decodeOct (val, offset, length) {
  val = val.subarray(offset, offset + length)
  offset = 0

  // If prefixed with 0x80 then parse as a base-256 integer
  if (val[offset] & 0x80) {
    return parse256(val)
  } else {
    // Older versions of tar can prefix with spaces
    while (offset < val.length && val[offset] === 32) offset++
    const end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length)
    while (offset < end && val[offset] === 0) offset++
    if (end === offset) return 0
    return parseInt(b4a.toString(val.subarray(offset, end)), 8)
  }
}

function decodeStr (val, offset, length, encoding) {
  return b4a.toString(val.subarray(offset, indexOf(val, 0, offset, offset + length)), encoding)
}

function addLength (str) {
  const len = b4a.byteLength(str)
  let digits = Math.floor(Math.log(len) / Math.log(10)) + 1
  if (len + digits >= Math.pow(10, digits)) digits++

  return (len + digits) + str
}


/***/ }),

/***/ "./node_modules/tar-stream/index.js":
/*!******************************************!*\
  !*** ./node_modules/tar-stream/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.extract = __webpack_require__(/*! ./extract */ "./node_modules/tar-stream/extract.js")
exports.pack = __webpack_require__(/*! ./pack */ "./node_modules/tar-stream/pack.js")


/***/ }),

/***/ "./node_modules/tar-stream/pack.js":
/*!*****************************************!*\
  !*** ./node_modules/tar-stream/pack.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { Readable, Writable, getStreamError } = __webpack_require__(/*! streamx */ "./node_modules/streamx/index.js")
const b4a = __webpack_require__(/*! b4a */ "./node_modules/b4a/index.js")

const constants = __webpack_require__(/*! ./constants */ "./node_modules/tar-stream/constants.js")
const headers = __webpack_require__(/*! ./headers */ "./node_modules/tar-stream/headers.js")

const DMODE = 0o755
const FMODE = 0o644

const END_OF_TAR = b4a.alloc(1024)

class Sink extends Writable {
  constructor (pack, header, callback) {
    super({ mapWritable, eagerOpen: true })

    this.written = 0
    this.header = header

    this._callback = callback
    this._linkname = null
    this._isLinkname = header.type === 'symlink' && !header.linkname
    this._isVoid = header.type !== 'file' && header.type !== 'contiguous-file'
    this._finished = false
    this._pack = pack
    this._openCallback = null

    if (this._pack._stream === null) this._pack._stream = this
    else this._pack._pending.push(this)
  }

  _open (cb) {
    this._openCallback = cb
    if (this._pack._stream === this) this._continueOpen()
  }

  _continuePack (err) {
    if (this._callback === null) return

    const callback = this._callback
    this._callback = null

    callback(err)
  }

  _continueOpen () {
    if (this._pack._stream === null) this._pack._stream = this

    const cb = this._openCallback
    this._openCallback = null
    if (cb === null) return

    if (this._pack.destroying) return cb(new Error('pack stream destroyed'))
    if (this._pack._finalized) return cb(new Error('pack stream is already finalized'))

    this._pack._stream = this

    if (!this._isLinkname) {
      this._pack._encode(this.header)
    }

    if (this._isVoid) {
      this._finish()
      this._continuePack(null)
    }

    cb(null)
  }

  _write (data, cb) {
    if (this._isLinkname) {
      this._linkname = this._linkname ? b4a.concat([this._linkname, data]) : data
      return cb(null)
    }

    if (this._isVoid) {
      if (data.byteLength > 0) {
        return cb(new Error('No body allowed for this entry'))
      }
      return cb()
    }

    this.written += data.byteLength
    if (this._pack.push(data)) return cb()
    this._pack._drain = cb
  }

  _finish () {
    if (this._finished) return
    this._finished = true

    if (this._isLinkname) {
      this.header.linkname = this._linkname ? b4a.toString(this._linkname, 'utf-8') : ''
      this._pack._encode(this.header)
    }

    overflow(this._pack, this.header.size)

    this._pack._done(this)
  }

  _final (cb) {
    if (this.written !== this.header.size) { // corrupting tar
      return cb(new Error('Size mismatch'))
    }

    this._finish()
    cb(null)
  }

  _getError () {
    return getStreamError(this) || new Error('tar entry destroyed')
  }

  _predestroy () {
    this._pack.destroy(this._getError())
  }

  _destroy (cb) {
    this._pack._done(this)

    this._continuePack(this._finished ? null : this._getError())

    cb()
  }
}

class Pack extends Readable {
  constructor (opts) {
    super(opts)
    this._drain = noop
    this._finalized = false
    this._finalizing = false
    this._pending = []
    this._stream = null
  }

  entry (header, buffer, callback) {
    if (this._finalized || this.destroying) throw new Error('already finalized or destroyed')

    if (typeof buffer === 'function') {
      callback = buffer
      buffer = null
    }

    if (!callback) callback = noop

    if (!header.size || header.type === 'symlink') header.size = 0
    if (!header.type) header.type = modeToType(header.mode)
    if (!header.mode) header.mode = header.type === 'directory' ? DMODE : FMODE
    if (!header.uid) header.uid = 0
    if (!header.gid) header.gid = 0
    if (!header.mtime) header.mtime = new Date()

    if (typeof buffer === 'string') buffer = b4a.from(buffer)

    const sink = new Sink(this, header, callback)

    if (b4a.isBuffer(buffer)) {
      header.size = buffer.byteLength
      sink.write(buffer)
      sink.end()
      return sink
    }

    if (sink._isVoid) {
      return sink
    }

    return sink
  }

  finalize () {
    if (this._stream || this._pending.length > 0) {
      this._finalizing = true
      return
    }

    if (this._finalized) return
    this._finalized = true

    this.push(END_OF_TAR)
    this.push(null)
  }

  _done (stream) {
    if (stream !== this._stream) return

    this._stream = null

    if (this._finalizing) this.finalize()
    if (this._pending.length) this._pending.shift()._continueOpen()
  }

  _encode (header) {
    if (!header.pax) {
      const buf = headers.encode(header)
      if (buf) {
        this.push(buf)
        return
      }
    }
    this._encodePax(header)
  }

  _encodePax (header) {
    const paxHeader = headers.encodePax({
      name: header.name,
      linkname: header.linkname,
      pax: header.pax
    })

    const newHeader = {
      name: 'PaxHeader',
      mode: header.mode,
      uid: header.uid,
      gid: header.gid,
      size: paxHeader.byteLength,
      mtime: header.mtime,
      type: 'pax-header',
      linkname: header.linkname && 'PaxHeader',
      uname: header.uname,
      gname: header.gname,
      devmajor: header.devmajor,
      devminor: header.devminor
    }

    this.push(headers.encode(newHeader))
    this.push(paxHeader)
    overflow(this, paxHeader.byteLength)

    newHeader.size = header.size
    newHeader.type = header.type
    this.push(headers.encode(newHeader))
  }

  _doDrain () {
    const drain = this._drain
    this._drain = noop
    drain()
  }

  _predestroy () {
    const err = getStreamError(this)

    if (this._stream) this._stream.destroy(err)

    while (this._pending.length) {
      const stream = this._pending.shift()
      stream.destroy(err)
      stream._continueOpen()
    }

    this._doDrain()
  }

  _read (cb) {
    this._doDrain()
    cb()
  }
}

module.exports = function pack (opts) {
  return new Pack(opts)
}

function modeToType (mode) {
  switch (mode & constants.S_IFMT) {
    case constants.S_IFBLK: return 'block-device'
    case constants.S_IFCHR: return 'character-device'
    case constants.S_IFDIR: return 'directory'
    case constants.S_IFIFO: return 'fifo'
    case constants.S_IFLNK: return 'symlink'
  }

  return 'file'
}

function noop () {}

function overflow (self, size) {
  size &= 511
  if (size) self.push(END_OF_TAR.subarray(0, 512 - size))
}

function mapWritable (buf) {
  return b4a.isBuffer(buf) ? buf : b4a.from(buf)
}


/***/ }),

/***/ "./node_modules/text-decoder/index.js":
/*!********************************************!*\
  !*** ./node_modules/text-decoder/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PassThroughDecoder = __webpack_require__(/*! ./lib/pass-through-decoder */ "./node_modules/text-decoder/lib/pass-through-decoder.js")
const UTF8Decoder = __webpack_require__(/*! ./lib/utf8-decoder */ "./node_modules/text-decoder/lib/utf8-decoder.js")

module.exports = class TextDecoder {
  constructor (encoding = 'utf8') {
    this.encoding = normalizeEncoding(encoding)

    switch (this.encoding) {
      case 'utf8':
        this.decoder = new UTF8Decoder()
        break
      case 'utf16le':
      case 'base64':
        throw new Error('Unsupported encoding: ' + this.encoding)
      default:
        this.decoder = new PassThroughDecoder(this.encoding)
    }
  }

  get remaining () {
    return this.decoder.remaining
  }

  push (data) {
    if (typeof data === 'string') return data
    return this.decoder.decode(data)
  }

  // For Node.js compatibility
  write (data) {
    return this.push(data)
  }

  end (data) {
    let result = ''
    if (data) result = this.push(data)
    result += this.decoder.flush()
    return result
  }
}

function normalizeEncoding (encoding) {
  encoding = encoding.toLowerCase()

  switch (encoding) {
    case 'utf8':
    case 'utf-8':
      return 'utf8'
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return 'utf16le'
    case 'latin1':
    case 'binary':
      return 'latin1'
    case 'base64':
    case 'ascii':
    case 'hex':
      return encoding
    default:
      throw new Error('Unknown encoding: ' + encoding)
  }
};


/***/ }),

/***/ "./node_modules/text-decoder/lib/pass-through-decoder.js":
/*!***************************************************************!*\
  !*** ./node_modules/text-decoder/lib/pass-through-decoder.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const b4a = __webpack_require__(/*! b4a */ "./node_modules/b4a/index.js")

module.exports = class PassThroughDecoder {
  constructor (encoding) {
    this.encoding = encoding
  }

  get remaining () {
    return 0
  }

  decode (tail) {
    return b4a.toString(tail, this.encoding)
  }

  flush () {
    return ''
  }
}


/***/ }),

/***/ "./node_modules/text-decoder/lib/utf8-decoder.js":
/*!*******************************************************!*\
  !*** ./node_modules/text-decoder/lib/utf8-decoder.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const b4a = __webpack_require__(/*! b4a */ "./node_modules/b4a/index.js")

/**
 * https://encoding.spec.whatwg.org/#utf-8-decoder
 */
module.exports = class UTF8Decoder {
  constructor () {
    this.codePoint = 0
    this.bytesSeen = 0
    this.bytesNeeded = 0
    this.lowerBoundary = 0x80
    this.upperBoundary = 0xbf
  }

  get remaining () {
    return this.bytesSeen
  }

  decode (data) {
    // If we have a fast path, just sniff if the last part is a boundary
    if (this.bytesNeeded === 0) {
      let isBoundary = true

      for (let i = Math.max(0, data.byteLength - 4), n = data.byteLength; i < n && isBoundary; i++) {
        isBoundary = data[i] <= 0x7f
      }

      if (isBoundary) return b4a.toString(data, 'utf8')
    }

    let result = ''

    for (let i = 0, n = data.byteLength; i < n; i++) {
      const byte = data[i]

      if (this.bytesNeeded === 0) {
        if (byte <= 0x7f) {
          result += String.fromCharCode(byte)
        } else {
          this.bytesSeen = 1

          if (byte >= 0xc2 && byte <= 0xdf) {
            this.bytesNeeded = 2
            this.codePoint = byte & 0x1f
          } else if (byte >= 0xe0 && byte <= 0xef) {
            if (byte === 0xe0) this.lowerBoundary = 0xa0
            else if (byte === 0xed) this.upperBoundary = 0x9f
            this.bytesNeeded = 3
            this.codePoint = byte & 0xf
          } else if (byte >= 0xf0 && byte <= 0xf4) {
            if (byte === 0xf0) this.lowerBoundary = 0x90
            if (byte === 0xf4) this.upperBoundary = 0x8f
            this.bytesNeeded = 4
            this.codePoint = byte & 0x7
          } else {
            result += '\ufffd'
          }
        }

        continue
      }

      if (byte < this.lowerBoundary || byte > this.upperBoundary) {
        this.codePoint = 0
        this.bytesNeeded = 0
        this.bytesSeen = 0
        this.lowerBoundary = 0x80
        this.upperBoundary = 0xbf

        result += '\ufffd'

        continue
      }

      this.lowerBoundary = 0x80
      this.upperBoundary = 0xbf

      this.codePoint = (this.codePoint << 6) | (byte & 0x3f)
      this.bytesSeen++

      if (this.bytesSeen !== this.bytesNeeded) continue

      result += String.fromCodePoint(this.codePoint)

      this.codePoint = 0
      this.bytesNeeded = 0
      this.bytesSeen = 0
    }

    return result
  }

  flush () {
    const result = this.bytesNeeded > 0 ? '\ufffd' : ''

    this.codePoint = 0
    this.bytesNeeded = 0
    this.bytesSeen = 0
    this.lowerBoundary = 0x80
    this.upperBoundary = 0xbf

    return result
  }
}


/***/ })

};
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfdGFyLWZzX2luZGV4X2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdENBLGtCQUFrQixtQkFBTyxDQUFDLDREQUFjOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvQ0EsV0FBVyxtQkFBTyxDQUFDLHlDQUFNO0FBQ3pCLFVBQVUsbUJBQU8sQ0FBQyw0REFBZTtBQUNqQzs7QUFFQTtBQUNBLE9BQU8sbUJBQU8sQ0FBQyxjQUFJO0FBQ25CLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILGVBQWUscUNBQXFDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7QUNyRkEsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUN6QztBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyxvREFBVztBQUNoQyxvQkFBb0IsbUJBQU8sQ0FBQywwREFBYzs7QUFFMUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5QkFBeUIsaUZBQWlGLElBQUk7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLGlGQUFpRixJQUFJO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtDQUFrQztBQUM5RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCw4QkFBOEI7QUFDNUY7QUFDQTtBQUNBLHlCQUF5Qiw4QkFBOEI7QUFDdkQsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQyxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGdCQUFnQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvcENBLFlBQVksbUJBQU8sQ0FBQyxzREFBWTtBQUNoQyxhQUFhLG1CQUFPLENBQUMsMENBQU07QUFDM0IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNOztBQUUzQjs7QUFFQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwRUFBMEUsZ0VBQWdFOztBQUUxSSxvQ0FBb0M7QUFDcEM7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hZQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsK0NBQXVCO0FBQzFDLEVBQUU7QUFDRjtBQUNBOzs7Ozs7Ozs7OztBQ2JBLFFBQVEscUNBQXFDLEVBQUUsbUJBQU8sQ0FBQyxnREFBUztBQUNoRSxhQUFhLG1CQUFPLENBQUMsb0RBQVc7QUFDaEMsWUFBWSxtQkFBTyxDQUFDLHdDQUFLO0FBQ3pCLGdCQUFnQixtQkFBTyxDQUFDLHVEQUFXOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsaUNBQWlDO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUJBQXlCLDhCQUE4QjtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLDRCQUE0QjtBQUNyRDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsOEJBQThCO0FBQzlFO0FBQ0E7QUFDQSx5QkFBeUIsOEJBQThCO0FBQ3ZELFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyWkEsWUFBWSxtQkFBTyxDQUFDLHdDQUFLOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQSxpQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVMsY0FBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0Isb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaFVBLDhGQUFzQztBQUN0QyxxRkFBZ0M7Ozs7Ozs7Ozs7O0FDRGhDLFFBQVEscUNBQXFDLEVBQUUsbUJBQU8sQ0FBQyxnREFBUztBQUNoRSxZQUFZLG1CQUFPLENBQUMsd0NBQUs7O0FBRXpCLGtCQUFrQixtQkFBTyxDQUFDLDJEQUFhO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLHVEQUFXOztBQUVuQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLDhCQUE4Qjs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOVJBLDJCQUEyQixtQkFBTyxDQUFDLDJGQUE0QjtBQUMvRCxvQkFBb0IsbUJBQU8sQ0FBQywyRUFBb0I7O0FBRWhEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0RBLFlBQVksbUJBQU8sQ0FBQyx3Q0FBSzs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQkEsWUFBWSxtQkFBTyxDQUFDLHdDQUFLOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwRUFBMEUscUJBQXFCO0FBQy9GO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx5Q0FBeUMsT0FBTztBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYWtlLW5vZGUvLi9ub2RlX21vZHVsZXMvYjRhL2luZGV4LmpzIiwid2VicGFjazovL2Zha2Utbm9kZS8uL25vZGVfbW9kdWxlcy9mYXN0LWZpZm8vZml4ZWQtc2l6ZS5qcyIsIndlYnBhY2s6Ly9mYWtlLW5vZGUvLi9ub2RlX21vZHVsZXMvZmFzdC1maWZvL2luZGV4LmpzIiwid2VicGFjazovL2Zha2Utbm9kZS8uL25vZGVfbW9kdWxlcy9wdW1wL2luZGV4LmpzIiwid2VicGFjazovL2Zha2Utbm9kZS8uL25vZGVfbW9kdWxlcy9zdHJlYW14L2luZGV4LmpzIiwid2VicGFjazovL2Zha2Utbm9kZS8uL25vZGVfbW9kdWxlcy90YXItZnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmFrZS1ub2RlLy4vbm9kZV9tb2R1bGVzL3Rhci1zdHJlYW0vY29uc3RhbnRzLmpzIiwid2VicGFjazovL2Zha2Utbm9kZS8uL25vZGVfbW9kdWxlcy90YXItc3RyZWFtL2V4dHJhY3QuanMiLCJ3ZWJwYWNrOi8vZmFrZS1ub2RlLy4vbm9kZV9tb2R1bGVzL3Rhci1zdHJlYW0vaGVhZGVycy5qcyIsIndlYnBhY2s6Ly9mYWtlLW5vZGUvLi9ub2RlX21vZHVsZXMvdGFyLXN0cmVhbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9mYWtlLW5vZGUvLi9ub2RlX21vZHVsZXMvdGFyLXN0cmVhbS9wYWNrLmpzIiwid2VicGFjazovL2Zha2Utbm9kZS8uL25vZGVfbW9kdWxlcy90ZXh0LWRlY29kZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmFrZS1ub2RlLy4vbm9kZV9tb2R1bGVzL3RleHQtZGVjb2Rlci9saWIvcGFzcy10aHJvdWdoLWRlY29kZXIuanMiLCJ3ZWJwYWNrOi8vZmFrZS1ub2RlLy4vbm9kZV9tb2R1bGVzL3RleHQtZGVjb2Rlci9saWIvdXRmOC1kZWNvZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGlzQnVmZmVyKHZhbHVlKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheVxufVxuXG5mdW5jdGlvbiBpc0VuY29kaW5nKGVuY29kaW5nKSB7XG4gIHJldHVybiBCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUoc2l6ZSkge1xuICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlU2xvdyhzaXplKSB7XG4gIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KHNpemUpXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykge1xuICByZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIHJldHVybiBCdWZmZXIuY29tcGFyZShhLCBiKVxufVxuXG5mdW5jdGlvbiBjb25jYXQoYnVmZmVycywgdG90YWxMZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoYnVmZmVycywgdG90YWxMZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGNvcHkoc291cmNlLCB0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiB0b0J1ZmZlcihzb3VyY2UpLmNvcHkodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbn1cblxuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIHRvQnVmZmVyKGEpLmVxdWFscyhiKVxufVxuXG5mdW5jdGlvbiBmaWxsKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgZW5kLCBlbmNvZGluZykge1xuICByZXR1cm4gdG9CdWZmZXIoYnVmZmVyKS5maWxsKHZhbHVlLCBvZmZzZXQsIGVuZCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gaW5jbHVkZXMoYnVmZmVyLCB2YWx1ZSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRvQnVmZmVyKGJ1ZmZlcikuaW5jbHVkZXModmFsdWUsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKGJ1ZmZlciwgdmFsdWUsIGJ5ZmVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0b0J1ZmZlcihidWZmZXIpLmluZGV4T2YodmFsdWUsIGJ5ZmVPZmZzZXQsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBsYXN0SW5kZXhPZihidWZmZXIsIHZhbHVlLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdG9CdWZmZXIoYnVmZmVyKS5sYXN0SW5kZXhPZih2YWx1ZSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIHN3YXAxNihidWZmZXIpIHtcbiAgcmV0dXJuIHRvQnVmZmVyKGJ1ZmZlcikuc3dhcDE2KClcbn1cblxuZnVuY3Rpb24gc3dhcDMyKGJ1ZmZlcikge1xuICByZXR1cm4gdG9CdWZmZXIoYnVmZmVyKS5zd2FwMzIoKVxufVxuXG5mdW5jdGlvbiBzd2FwNjQoYnVmZmVyKSB7XG4gIHJldHVybiB0b0J1ZmZlcihidWZmZXIpLnN3YXA2NCgpXG59XG5cbmZ1bmN0aW9uIHRvQnVmZmVyKGJ1ZmZlcikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHJldHVybiBidWZmZXJcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ1ZmZlci5idWZmZXIsIGJ1ZmZlci5ieXRlT2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aClcbn1cblxuZnVuY3Rpb24gdG9TdHJpbmcoYnVmZmVyLCBlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdG9CdWZmZXIoYnVmZmVyKS50b1N0cmluZyhlbmNvZGluZywgc3RhcnQsIGVuZClcbn1cblxuZnVuY3Rpb24gd3JpdGUoYnVmZmVyLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICByZXR1cm4gdG9CdWZmZXIoYnVmZmVyKS53cml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gcmVhZERvdWJsZUJFKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIHJldHVybiB0b0J1ZmZlcihidWZmZXIpLnJlYWREb3VibGVCRShvZmZzZXQpXG59XG5cbmZ1bmN0aW9uIHJlYWREb3VibGVMRShidWZmZXIsIG9mZnNldCkge1xuICByZXR1cm4gdG9CdWZmZXIoYnVmZmVyKS5yZWFkRG91YmxlTEUob2Zmc2V0KVxufVxuXG5mdW5jdGlvbiByZWFkRmxvYXRCRShidWZmZXIsIG9mZnNldCkge1xuICByZXR1cm4gdG9CdWZmZXIoYnVmZmVyKS5yZWFkRmxvYXRCRShvZmZzZXQpXG59XG5cbmZ1bmN0aW9uIHJlYWRGbG9hdExFKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIHJldHVybiB0b0J1ZmZlcihidWZmZXIpLnJlYWRGbG9hdExFKG9mZnNldClcbn1cblxuZnVuY3Rpb24gcmVhZEludDMyQkUoYnVmZmVyLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRvQnVmZmVyKGJ1ZmZlcikucmVhZEludDMyQkUob2Zmc2V0KVxufVxuXG5mdW5jdGlvbiByZWFkSW50MzJMRShidWZmZXIsIG9mZnNldCkge1xuICByZXR1cm4gdG9CdWZmZXIoYnVmZmVyKS5yZWFkSW50MzJMRShvZmZzZXQpXG59XG5cbmZ1bmN0aW9uIHJlYWRVSW50MzJCRShidWZmZXIsIG9mZnNldCkge1xuICByZXR1cm4gdG9CdWZmZXIoYnVmZmVyKS5yZWFkVUludDMyQkUob2Zmc2V0KVxufVxuXG5mdW5jdGlvbiByZWFkVUludDMyTEUoYnVmZmVyLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRvQnVmZmVyKGJ1ZmZlcikucmVhZFVJbnQzMkxFKG9mZnNldClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGVCRShidWZmZXIsIHZhbHVlLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRvQnVmZmVyKGJ1ZmZlcikud3JpdGVEb3VibGVCRSh2YWx1ZSwgb2Zmc2V0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZUxFKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCkge1xuICByZXR1cm4gdG9CdWZmZXIoYnVmZmVyKS53cml0ZURvdWJsZUxFKHZhbHVlLCBvZmZzZXQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXRCRShidWZmZXIsIHZhbHVlLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRvQnVmZmVyKGJ1ZmZlcikud3JpdGVGbG9hdEJFKHZhbHVlLCBvZmZzZXQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXRMRShidWZmZXIsIHZhbHVlLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRvQnVmZmVyKGJ1ZmZlcikud3JpdGVGbG9hdExFKHZhbHVlLCBvZmZzZXQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlSW50MzJCRShidWZmZXIsIHZhbHVlLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRvQnVmZmVyKGJ1ZmZlcikud3JpdGVJbnQzMkJFKHZhbHVlLCBvZmZzZXQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlSW50MzJMRShidWZmZXIsIHZhbHVlLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRvQnVmZmVyKGJ1ZmZlcikud3JpdGVJbnQzMkxFKHZhbHVlLCBvZmZzZXQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlVUludDMyQkUoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0KSB7XG4gIHJldHVybiB0b0J1ZmZlcihidWZmZXIpLndyaXRlVUludDMyQkUodmFsdWUsIG9mZnNldClcbn1cblxuZnVuY3Rpb24gd3JpdGVVSW50MzJMRShidWZmZXIsIHZhbHVlLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRvQnVmZmVyKGJ1ZmZlcikud3JpdGVVSW50MzJMRSh2YWx1ZSwgb2Zmc2V0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNCdWZmZXIsXG4gIGlzRW5jb2RpbmcsXG4gIGFsbG9jLFxuICBhbGxvY1Vuc2FmZSxcbiAgYWxsb2NVbnNhZmVTbG93LFxuICBieXRlTGVuZ3RoLFxuICBjb21wYXJlLFxuICBjb25jYXQsXG4gIGNvcHksXG4gIGVxdWFscyxcbiAgZmlsbCxcbiAgZnJvbSxcbiAgaW5jbHVkZXMsXG4gIGluZGV4T2YsXG4gIGxhc3RJbmRleE9mLFxuICBzd2FwMTYsXG4gIHN3YXAzMixcbiAgc3dhcDY0LFxuICB0b0J1ZmZlcixcbiAgdG9TdHJpbmcsXG4gIHdyaXRlLFxuICByZWFkRG91YmxlQkUsXG4gIHJlYWREb3VibGVMRSxcbiAgcmVhZEZsb2F0QkUsXG4gIHJlYWRGbG9hdExFLFxuICByZWFkSW50MzJCRSxcbiAgcmVhZEludDMyTEUsXG4gIHJlYWRVSW50MzJCRSxcbiAgcmVhZFVJbnQzMkxFLFxuICB3cml0ZURvdWJsZUJFLFxuICB3cml0ZURvdWJsZUxFLFxuICB3cml0ZUZsb2F0QkUsXG4gIHdyaXRlRmxvYXRMRSxcbiAgd3JpdGVJbnQzMkJFLFxuICB3cml0ZUludDMyTEUsXG4gIHdyaXRlVUludDMyQkUsXG4gIHdyaXRlVUludDMyTEVcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRml4ZWRGSUZPIHtcbiAgY29uc3RydWN0b3IgKGh3bSkge1xuICAgIGlmICghKGh3bSA+IDApIHx8ICgoaHdtIC0gMSkgJiBod20pICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ01heCBzaXplIGZvciBhIEZpeGVkRklGTyBzaG91bGQgYmUgYSBwb3dlciBvZiB0d28nKVxuICAgIHRoaXMuYnVmZmVyID0gbmV3IEFycmF5KGh3bSlcbiAgICB0aGlzLm1hc2sgPSBod20gLSAxXG4gICAgdGhpcy50b3AgPSAwXG4gICAgdGhpcy5idG0gPSAwXG4gICAgdGhpcy5uZXh0ID0gbnVsbFxuICB9XG5cbiAgY2xlYXIgKCkge1xuICAgIHRoaXMudG9wID0gdGhpcy5idG0gPSAwXG4gICAgdGhpcy5uZXh0ID0gbnVsbFxuICAgIHRoaXMuYnVmZmVyLmZpbGwodW5kZWZpbmVkKVxuICB9XG5cbiAgcHVzaCAoZGF0YSkge1xuICAgIGlmICh0aGlzLmJ1ZmZlclt0aGlzLnRvcF0gIT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlXG4gICAgdGhpcy5idWZmZXJbdGhpcy50b3BdID0gZGF0YVxuICAgIHRoaXMudG9wID0gKHRoaXMudG9wICsgMSkgJiB0aGlzLm1hc2tcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgc2hpZnQgKCkge1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLmJ1ZmZlclt0aGlzLmJ0bV1cbiAgICBpZiAobGFzdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgdGhpcy5idWZmZXJbdGhpcy5idG1dID0gdW5kZWZpbmVkXG4gICAgdGhpcy5idG0gPSAodGhpcy5idG0gKyAxKSAmIHRoaXMubWFza1xuICAgIHJldHVybiBsYXN0XG4gIH1cblxuICBwZWVrICgpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5idG1dXG4gIH1cblxuICBpc0VtcHR5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5idG1dID09PSB1bmRlZmluZWRcbiAgfVxufVxuIiwiY29uc3QgRml4ZWRGSUZPID0gcmVxdWlyZSgnLi9maXhlZC1zaXplJylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBGYXN0RklGTyB7XG4gIGNvbnN0cnVjdG9yIChod20pIHtcbiAgICB0aGlzLmh3bSA9IGh3bSB8fCAxNlxuICAgIHRoaXMuaGVhZCA9IG5ldyBGaXhlZEZJRk8odGhpcy5od20pXG4gICAgdGhpcy50YWlsID0gdGhpcy5oZWFkXG4gICAgdGhpcy5sZW5ndGggPSAwXG4gIH1cblxuICBjbGVhciAoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsXG4gICAgdGhpcy5oZWFkLmNsZWFyKClcbiAgICB0aGlzLmxlbmd0aCA9IDBcbiAgfVxuXG4gIHB1c2ggKHZhbCkge1xuICAgIHRoaXMubGVuZ3RoKytcbiAgICBpZiAoIXRoaXMuaGVhZC5wdXNoKHZhbCkpIHtcbiAgICAgIGNvbnN0IHByZXYgPSB0aGlzLmhlYWRcbiAgICAgIHRoaXMuaGVhZCA9IHByZXYubmV4dCA9IG5ldyBGaXhlZEZJRk8oMiAqIHRoaXMuaGVhZC5idWZmZXIubGVuZ3RoKVxuICAgICAgdGhpcy5oZWFkLnB1c2godmFsKVxuICAgIH1cbiAgfVxuXG4gIHNoaWZ0ICgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggIT09IDApIHRoaXMubGVuZ3RoLS1cbiAgICBjb25zdCB2YWwgPSB0aGlzLnRhaWwuc2hpZnQoKVxuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnRhaWwubmV4dCkge1xuICAgICAgY29uc3QgbmV4dCA9IHRoaXMudGFpbC5uZXh0XG4gICAgICB0aGlzLnRhaWwubmV4dCA9IG51bGxcbiAgICAgIHRoaXMudGFpbCA9IG5leHRcbiAgICAgIHJldHVybiB0aGlzLnRhaWwuc2hpZnQoKVxuICAgIH1cblxuICAgIHJldHVybiB2YWxcbiAgfVxuXG4gIHBlZWsgKCkge1xuICAgIGNvbnN0IHZhbCA9IHRoaXMudGFpbC5wZWVrKClcbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQgJiYgdGhpcy50YWlsLm5leHQpIHJldHVybiB0aGlzLnRhaWwubmV4dC5wZWVrKClcbiAgICByZXR1cm4gdmFsXG4gIH1cblxuICBpc0VtcHR5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDBcbiAgfVxufVxuIiwidmFyIG9uY2UgPSByZXF1aXJlKCdvbmNlJylcbnZhciBlb3MgPSByZXF1aXJlKCdlbmQtb2Ytc3RyZWFtJylcbnZhciBmc1xuXG50cnkge1xuICBmcyA9IHJlcXVpcmUoJ2ZzJykgLy8gd2Ugb25seSBuZWVkIGZzIHRvIGdldCB0aGUgUmVhZFN0cmVhbSBhbmQgV3JpdGVTdHJlYW0gcHJvdG90eXBlc1xufSBjYXRjaCAoZSkge31cblxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxudmFyIGFuY2llbnQgPSB0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgPyBmYWxzZSA6IC9edj9cXC4wLy50ZXN0KHByb2Nlc3MudmVyc2lvbilcblxudmFyIGlzRm4gPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG52YXIgaXNGUyA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgaWYgKCFhbmNpZW50KSByZXR1cm4gZmFsc2UgLy8gbmV3ZXIgbm9kZSB2ZXJzaW9uIGRvIG5vdCBuZWVkIHRvIGNhcmUgYWJvdXQgZnMgaXMgYSBzcGVjaWFsIHdheVxuICBpZiAoIWZzKSByZXR1cm4gZmFsc2UgLy8gYnJvd3NlclxuICByZXR1cm4gKHN0cmVhbSBpbnN0YW5jZW9mIChmcy5SZWFkU3RyZWFtIHx8IG5vb3ApIHx8IHN0cmVhbSBpbnN0YW5jZW9mIChmcy5Xcml0ZVN0cmVhbSB8fCBub29wKSkgJiYgaXNGbihzdHJlYW0uY2xvc2UpXG59XG5cbnZhciBpc1JlcXVlc3QgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIGlzRm4oc3RyZWFtLmFib3J0KVxufVxuXG52YXIgZGVzdHJveWVyID0gZnVuY3Rpb24gKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKVxuXG4gIHZhciBjbG9zZWQgPSBmYWxzZVxuICBzdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGNsb3NlZCA9IHRydWVcbiAgfSlcblxuICBlb3Moc3RyZWFtLCB7cmVhZGFibGU6IHJlYWRpbmcsIHdyaXRhYmxlOiB3cml0aW5nfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgY2xvc2VkID0gdHJ1ZVxuICAgIGNhbGxiYWNrKClcbiAgfSlcblxuICB2YXIgZGVzdHJveWVkID0gZmFsc2VcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoY2xvc2VkKSByZXR1cm5cbiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm5cbiAgICBkZXN0cm95ZWQgPSB0cnVlXG5cbiAgICBpZiAoaXNGUyhzdHJlYW0pKSByZXR1cm4gc3RyZWFtLmNsb3NlKG5vb3ApIC8vIHVzZSBjbG9zZSBmb3IgZnMgc3RyZWFtcyB0byBhdm9pZCBmZCBsZWFrc1xuICAgIGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkgcmV0dXJuIHN0cmVhbS5hYm9ydCgpIC8vIHJlcXVlc3QuZGVzdHJveSBqdXN0IGRvIC5lbmQgLSAuYWJvcnQgaXMgd2hhdCB3ZSB3YW50XG5cbiAgICBpZiAoaXNGbihzdHJlYW0uZGVzdHJveSkpIHJldHVybiBzdHJlYW0uZGVzdHJveSgpXG5cbiAgICBjYWxsYmFjayhlcnIgfHwgbmV3IEVycm9yKCdzdHJlYW0gd2FzIGRlc3Ryb3llZCcpKVxuICB9XG59XG5cbnZhciBjYWxsID0gZnVuY3Rpb24gKGZuKSB7XG4gIGZuKClcbn1cblxudmFyIHBpcGUgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgcmV0dXJuIGZyb20ucGlwZSh0bylcbn1cblxudmFyIHB1bXAgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdHJlYW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICB2YXIgY2FsbGJhY2sgPSBpc0ZuKHN0cmVhbXNbc3RyZWFtcy5sZW5ndGggLSAxXSB8fCBub29wKSAmJiBzdHJlYW1zLnBvcCgpIHx8IG5vb3BcblxuICBpZiAoQXJyYXkuaXNBcnJheShzdHJlYW1zWzBdKSkgc3RyZWFtcyA9IHN0cmVhbXNbMF1cbiAgaWYgKHN0cmVhbXMubGVuZ3RoIDwgMikgdGhyb3cgbmV3IEVycm9yKCdwdW1wIHJlcXVpcmVzIHR3byBzdHJlYW1zIHBlciBtaW5pbXVtJylcblxuICB2YXIgZXJyb3JcbiAgdmFyIGRlc3Ryb3lzID0gc3RyZWFtcy5tYXAoZnVuY3Rpb24gKHN0cmVhbSwgaSkge1xuICAgIHZhciByZWFkaW5nID0gaSA8IHN0cmVhbXMubGVuZ3RoIC0gMVxuICAgIHZhciB3cml0aW5nID0gaSA+IDBcbiAgICByZXR1cm4gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKCFlcnJvcikgZXJyb3IgPSBlcnJcbiAgICAgIGlmIChlcnIpIGRlc3Ryb3lzLmZvckVhY2goY2FsbClcbiAgICAgIGlmIChyZWFkaW5nKSByZXR1cm5cbiAgICAgIGRlc3Ryb3lzLmZvckVhY2goY2FsbClcbiAgICAgIGNhbGxiYWNrKGVycm9yKVxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIHN0cmVhbXMucmVkdWNlKHBpcGUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHVtcFxuIiwiY29uc3QgeyBFdmVudEVtaXR0ZXIgfSA9IHJlcXVpcmUoJ2V2ZW50cycpXG5jb25zdCBTVFJFQU1fREVTVFJPWUVEID0gbmV3IEVycm9yKCdTdHJlYW0gd2FzIGRlc3Ryb3llZCcpXG5jb25zdCBQUkVNQVRVUkVfQ0xPU0UgPSBuZXcgRXJyb3IoJ1ByZW1hdHVyZSBjbG9zZScpXG5cbmNvbnN0IEZJRk8gPSByZXF1aXJlKCdmYXN0LWZpZm8nKVxuY29uc3QgVGV4dERlY29kZXIgPSByZXF1aXJlKCd0ZXh0LWRlY29kZXInKVxuXG4vLyBpZiB3ZSBkbyBhIGZ1dHVyZSBtYWpvciwgZXhwZWN0IHF1ZXVlIG1pY3JvdGFzayB0byBiZSB0aGVyZSBhbHdheXMsIGZvciBub3cgYSBiaXQgZGVmZW5zaXZlXG5jb25zdCBxbXQgPSB0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT09ICd1bmRlZmluZWQnID8gZm4gPT4gZ2xvYmFsLnByb2Nlc3MubmV4dFRpY2soZm4pIDogcXVldWVNaWNyb3Rhc2tcblxuLyogZXNsaW50LWRpc2FibGUgbm8tbXVsdGktc3BhY2VzICovXG5cbi8vIDI5IGJpdHMgdXNlZCB0b3RhbCAoNCBmcm9tIHNoYXJlZCwgMTQgZnJvbSByZWFkLCBhbmQgMTEgZnJvbSB3cml0ZSlcbmNvbnN0IE1BWCA9ICgoMSA8PCAyOSkgLSAxKVxuXG4vLyBTaGFyZWQgc3RhdGVcbmNvbnN0IE9QRU5JTkcgICAgICAgPSAwYjAwMDFcbmNvbnN0IFBSRURFU1RST1lJTkcgPSAwYjAwMTBcbmNvbnN0IERFU1RST1lJTkcgICAgPSAwYjAxMDBcbmNvbnN0IERFU1RST1lFRCAgICAgPSAwYjEwMDBcblxuY29uc3QgTk9UX09QRU5JTkcgPSBNQVggXiBPUEVOSU5HXG5jb25zdCBOT1RfUFJFREVTVFJPWUlORyA9IE1BWCBeIFBSRURFU1RST1lJTkdcblxuLy8gUmVhZCBzdGF0ZSAoNCBiaXQgb2Zmc2V0IGZyb20gc2hhcmVkIHN0YXRlKVxuY29uc3QgUkVBRF9BQ1RJVkUgICAgICAgICAgID0gMGIwMDAwMDAwMDAwMDAwMSA8PCA0XG5jb25zdCBSRUFEX1VQREFUSU5HICAgICAgICAgPSAwYjAwMDAwMDAwMDAwMDEwIDw8IDRcbmNvbnN0IFJFQURfUFJJTUFSWSAgICAgICAgICA9IDBiMDAwMDAwMDAwMDAxMDAgPDwgNFxuY29uc3QgUkVBRF9RVUVVRUQgICAgICAgICAgID0gMGIwMDAwMDAwMDAwMTAwMCA8PCA0XG5jb25zdCBSRUFEX1JFU1VNRUQgICAgICAgICAgPSAwYjAwMDAwMDAwMDEwMDAwIDw8IDRcbmNvbnN0IFJFQURfUElQRV9EUkFJTkVEICAgICA9IDBiMDAwMDAwMDAxMDAwMDAgPDwgNFxuY29uc3QgUkVBRF9FTkRJTkcgICAgICAgICAgID0gMGIwMDAwMDAwMTAwMDAwMCA8PCA0XG5jb25zdCBSRUFEX0VNSVRfREFUQSAgICAgICAgPSAwYjAwMDAwMDEwMDAwMDAwIDw8IDRcbmNvbnN0IFJFQURfRU1JVF9SRUFEQUJMRSAgICA9IDBiMDAwMDAxMDAwMDAwMDAgPDwgNFxuY29uc3QgUkVBRF9FTUlUVEVEX1JFQURBQkxFID0gMGIwMDAwMTAwMDAwMDAwMCA8PCA0XG5jb25zdCBSRUFEX0RPTkUgICAgICAgICAgICAgPSAwYjAwMDEwMDAwMDAwMDAwIDw8IDRcbmNvbnN0IFJFQURfTkVYVF9USUNLICAgICAgICA9IDBiMDAxMDAwMDAwMDAwMDAgPDwgNFxuY29uc3QgUkVBRF9ORUVEU19QVVNIICAgICAgID0gMGIwMTAwMDAwMDAwMDAwMCA8PCA0XG5jb25zdCBSRUFEX1JFQURfQUhFQUQgICAgICAgPSAwYjEwMDAwMDAwMDAwMDAwIDw8IDRcblxuLy8gQ29tYmluZWQgcmVhZCBzdGF0ZVxuY29uc3QgUkVBRF9GTE9XSU5HID0gUkVBRF9SRVNVTUVEIHwgUkVBRF9QSVBFX0RSQUlORURcbmNvbnN0IFJFQURfQUNUSVZFX0FORF9ORUVEU19QVVNIID0gUkVBRF9BQ1RJVkUgfCBSRUFEX05FRURTX1BVU0hcbmNvbnN0IFJFQURfUFJJTUFSWV9BTkRfQUNUSVZFID0gUkVBRF9QUklNQVJZIHwgUkVBRF9BQ1RJVkVcbmNvbnN0IFJFQURfRU1JVF9SRUFEQUJMRV9BTkRfUVVFVUVEID0gUkVBRF9FTUlUX1JFQURBQkxFIHwgUkVBRF9RVUVVRURcbmNvbnN0IFJFQURfUkVTVU1FRF9SRUFEX0FIRUFEID0gUkVBRF9SRVNVTUVEIHwgUkVBRF9SRUFEX0FIRUFEXG5cbmNvbnN0IFJFQURfTk9UX0FDVElWRSAgICAgICAgICAgICA9IE1BWCBeIFJFQURfQUNUSVZFXG5jb25zdCBSRUFEX05PTl9QUklNQVJZICAgICAgICAgICAgPSBNQVggXiBSRUFEX1BSSU1BUllcbmNvbnN0IFJFQURfTk9OX1BSSU1BUllfQU5EX1BVU0hFRCA9IE1BWCBeIChSRUFEX1BSSU1BUlkgfCBSRUFEX05FRURTX1BVU0gpXG5jb25zdCBSRUFEX1BVU0hFRCAgICAgICAgICAgICAgICAgPSBNQVggXiBSRUFEX05FRURTX1BVU0hcbmNvbnN0IFJFQURfUEFVU0VEICAgICAgICAgICAgICAgICA9IE1BWCBeIFJFQURfUkVTVU1FRFxuY29uc3QgUkVBRF9OT1RfUVVFVUVEICAgICAgICAgICAgID0gTUFYIF4gKFJFQURfUVVFVUVEIHwgUkVBRF9FTUlUVEVEX1JFQURBQkxFKVxuY29uc3QgUkVBRF9OT1RfRU5ESU5HICAgICAgICAgICAgID0gTUFYIF4gUkVBRF9FTkRJTkdcbmNvbnN0IFJFQURfUElQRV9OT1RfRFJBSU5FRCAgICAgICA9IE1BWCBeIFJFQURfRkxPV0lOR1xuY29uc3QgUkVBRF9OT1RfTkVYVF9USUNLICAgICAgICAgID0gTUFYIF4gUkVBRF9ORVhUX1RJQ0tcbmNvbnN0IFJFQURfTk9UX1VQREFUSU5HICAgICAgICAgICA9IE1BWCBeIFJFQURfVVBEQVRJTkdcbmNvbnN0IFJFQURfTk9fUkVBRF9BSEVBRCAgICAgICAgICA9IE1BWCBeIFJFQURfUkVBRF9BSEVBRFxuY29uc3QgUkVBRF9QQVVTRURfTk9fUkVBRF9BSEVBRCAgID0gTUFYIF4gUkVBRF9SRVNVTUVEX1JFQURfQUhFQURcblxuLy8gV3JpdGUgc3RhdGUgKDE4IGJpdCBvZmZzZXQsIDQgYml0IG9mZnNldCBmcm9tIHNoYXJlZCBzdGF0ZSBhbmQgMTQgZnJvbSByZWFkIHN0YXRlKVxuY29uc3QgV1JJVEVfQUNUSVZFICAgICA9IDBiMDAwMDAwMDAwMDEgPDwgMThcbmNvbnN0IFdSSVRFX1VQREFUSU5HICAgPSAwYjAwMDAwMDAwMDEwIDw8IDE4XG5jb25zdCBXUklURV9QUklNQVJZICAgID0gMGIwMDAwMDAwMDEwMCA8PCAxOFxuY29uc3QgV1JJVEVfUVVFVUVEICAgICA9IDBiMDAwMDAwMDEwMDAgPDwgMThcbmNvbnN0IFdSSVRFX1VORFJBSU5FRCAgPSAwYjAwMDAwMDEwMDAwIDw8IDE4XG5jb25zdCBXUklURV9ET05FICAgICAgID0gMGIwMDAwMDEwMDAwMCA8PCAxOFxuY29uc3QgV1JJVEVfRU1JVF9EUkFJTiA9IDBiMDAwMDEwMDAwMDAgPDwgMThcbmNvbnN0IFdSSVRFX05FWFRfVElDSyAgPSAwYjAwMDEwMDAwMDAwIDw8IDE4XG5jb25zdCBXUklURV9XUklUSU5HICAgID0gMGIwMDEwMDAwMDAwMCA8PCAxOFxuY29uc3QgV1JJVEVfRklOSVNISU5HICA9IDBiMDEwMDAwMDAwMDAgPDwgMThcbmNvbnN0IFdSSVRFX0NPUktFRCAgICAgPSAwYjEwMDAwMDAwMDAwIDw8IDE4XG5cbmNvbnN0IFdSSVRFX05PVF9BQ1RJVkUgICAgPSBNQVggXiAoV1JJVEVfQUNUSVZFIHwgV1JJVEVfV1JJVElORylcbmNvbnN0IFdSSVRFX05PTl9QUklNQVJZICAgPSBNQVggXiBXUklURV9QUklNQVJZXG5jb25zdCBXUklURV9OT1RfRklOSVNISU5HID0gTUFYIF4gKFdSSVRFX0FDVElWRSB8IFdSSVRFX0ZJTklTSElORylcbmNvbnN0IFdSSVRFX0RSQUlORUQgICAgICAgPSBNQVggXiBXUklURV9VTkRSQUlORURcbmNvbnN0IFdSSVRFX05PVF9RVUVVRUQgICAgPSBNQVggXiBXUklURV9RVUVVRURcbmNvbnN0IFdSSVRFX05PVF9ORVhUX1RJQ0sgPSBNQVggXiBXUklURV9ORVhUX1RJQ0tcbmNvbnN0IFdSSVRFX05PVF9VUERBVElORyAgPSBNQVggXiBXUklURV9VUERBVElOR1xuY29uc3QgV1JJVEVfTk9UX0NPUktFRCAgICA9IE1BWCBeIFdSSVRFX0NPUktFRFxuXG4vLyBDb21iaW5lZCBzaGFyZWQgc3RhdGVcbmNvbnN0IEFDVElWRSA9IFJFQURfQUNUSVZFIHwgV1JJVEVfQUNUSVZFXG5jb25zdCBOT1RfQUNUSVZFID0gTUFYIF4gQUNUSVZFXG5jb25zdCBET05FID0gUkVBRF9ET05FIHwgV1JJVEVfRE9ORVxuY29uc3QgREVTVFJPWV9TVEFUVVMgPSBERVNUUk9ZSU5HIHwgREVTVFJPWUVEIHwgUFJFREVTVFJPWUlOR1xuY29uc3QgT1BFTl9TVEFUVVMgPSBERVNUUk9ZX1NUQVRVUyB8IE9QRU5JTkdcbmNvbnN0IEFVVE9fREVTVFJPWSA9IERFU1RST1lfU1RBVFVTIHwgRE9ORVxuY29uc3QgTk9OX1BSSU1BUlkgPSBXUklURV9OT05fUFJJTUFSWSAmIFJFQURfTk9OX1BSSU1BUllcbmNvbnN0IEFDVElWRV9PUl9USUNLSU5HID0gV1JJVEVfTkVYVF9USUNLIHwgUkVBRF9ORVhUX1RJQ0tcbmNvbnN0IFRJQ0tJTkcgPSBBQ1RJVkVfT1JfVElDS0lORyAmIE5PVF9BQ1RJVkVcbmNvbnN0IElTX09QRU5JTkcgPSBPUEVOX1NUQVRVUyB8IFRJQ0tJTkdcblxuLy8gQ29tYmluZWQgc2hhcmVkIHN0YXRlIGFuZCByZWFkIHN0YXRlXG5jb25zdCBSRUFEX1BSSU1BUllfU1RBVFVTID0gT1BFTl9TVEFUVVMgfCBSRUFEX0VORElORyB8IFJFQURfRE9ORVxuY29uc3QgUkVBRF9TVEFUVVMgPSBPUEVOX1NUQVRVUyB8IFJFQURfRE9ORSB8IFJFQURfUVVFVUVEXG5jb25zdCBSRUFEX0VORElOR19TVEFUVVMgPSBPUEVOX1NUQVRVUyB8IFJFQURfRU5ESU5HIHwgUkVBRF9RVUVVRURcbmNvbnN0IFJFQURfUkVBREFCTEVfU1RBVFVTID0gT1BFTl9TVEFUVVMgfCBSRUFEX0VNSVRfUkVBREFCTEUgfCBSRUFEX1FVRVVFRCB8IFJFQURfRU1JVFRFRF9SRUFEQUJMRVxuY29uc3QgU0hPVUxEX05PVF9SRUFEID0gT1BFTl9TVEFUVVMgfCBSRUFEX0FDVElWRSB8IFJFQURfRU5ESU5HIHwgUkVBRF9ET05FIHwgUkVBRF9ORUVEU19QVVNIIHwgUkVBRF9SRUFEX0FIRUFEXG5jb25zdCBSRUFEX0JBQ0tQUkVTU1VSRV9TVEFUVVMgPSBERVNUUk9ZX1NUQVRVUyB8IFJFQURfRU5ESU5HIHwgUkVBRF9ET05FXG5jb25zdCBSRUFEX1VQREFURV9TWU5DX1NUQVRVUyA9IFJFQURfVVBEQVRJTkcgfCBPUEVOX1NUQVRVUyB8IFJFQURfTkVYVF9USUNLIHwgUkVBRF9QUklNQVJZXG5jb25zdCBSRUFEX05FWFRfVElDS19PUl9PUEVOSU5HID0gUkVBRF9ORVhUX1RJQ0sgfCBPUEVOSU5HXG5cbi8vIENvbWJpbmVkIHdyaXRlIHN0YXRlXG5jb25zdCBXUklURV9QUklNQVJZX1NUQVRVUyA9IE9QRU5fU1RBVFVTIHwgV1JJVEVfRklOSVNISU5HIHwgV1JJVEVfRE9ORVxuY29uc3QgV1JJVEVfUVVFVUVEX0FORF9VTkRSQUlORUQgPSBXUklURV9RVUVVRUQgfCBXUklURV9VTkRSQUlORURcbmNvbnN0IFdSSVRFX1FVRVVFRF9BTkRfQUNUSVZFID0gV1JJVEVfUVVFVUVEIHwgV1JJVEVfQUNUSVZFXG5jb25zdCBXUklURV9EUkFJTl9TVEFUVVMgPSBXUklURV9RVUVVRUQgfCBXUklURV9VTkRSQUlORUQgfCBPUEVOX1NUQVRVUyB8IFdSSVRFX0FDVElWRVxuY29uc3QgV1JJVEVfU1RBVFVTID0gT1BFTl9TVEFUVVMgfCBXUklURV9BQ1RJVkUgfCBXUklURV9RVUVVRUQgfCBXUklURV9DT1JLRURcbmNvbnN0IFdSSVRFX1BSSU1BUllfQU5EX0FDVElWRSA9IFdSSVRFX1BSSU1BUlkgfCBXUklURV9BQ1RJVkVcbmNvbnN0IFdSSVRFX0FDVElWRV9BTkRfV1JJVElORyA9IFdSSVRFX0FDVElWRSB8IFdSSVRFX1dSSVRJTkdcbmNvbnN0IFdSSVRFX0ZJTklTSElOR19TVEFUVVMgPSBPUEVOX1NUQVRVUyB8IFdSSVRFX0ZJTklTSElORyB8IFdSSVRFX1FVRVVFRF9BTkRfQUNUSVZFIHwgV1JJVEVfRE9ORVxuY29uc3QgV1JJVEVfQkFDS1BSRVNTVVJFX1NUQVRVUyA9IFdSSVRFX1VORFJBSU5FRCB8IERFU1RST1lfU1RBVFVTIHwgV1JJVEVfRklOSVNISU5HIHwgV1JJVEVfRE9ORVxuY29uc3QgV1JJVEVfVVBEQVRFX1NZTkNfU1RBVFVTID0gV1JJVEVfVVBEQVRJTkcgfCBPUEVOX1NUQVRVUyB8IFdSSVRFX05FWFRfVElDSyB8IFdSSVRFX1BSSU1BUllcbmNvbnN0IFdSSVRFX0RST1BfREFUQSA9IFdSSVRFX0ZJTklTSElORyB8IFdSSVRFX0RPTkUgfCBERVNUUk9ZX1NUQVRVU1xuXG5jb25zdCBhc3luY0l0ZXJhdG9yID0gU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgU3ltYm9sKCdhc3luY0l0ZXJhdG9yJylcblxuY2xhc3MgV3JpdGFibGVTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yIChzdHJlYW0sIHsgaGlnaFdhdGVyTWFyayA9IDE2Mzg0LCBtYXAgPSBudWxsLCBtYXBXcml0YWJsZSwgYnl0ZUxlbmd0aCwgYnl0ZUxlbmd0aFdyaXRhYmxlIH0gPSB7fSkge1xuICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtXG4gICAgdGhpcy5xdWV1ZSA9IG5ldyBGSUZPKClcbiAgICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBoaWdoV2F0ZXJNYXJrXG4gICAgdGhpcy5idWZmZXJlZCA9IDBcbiAgICB0aGlzLmVycm9yID0gbnVsbFxuICAgIHRoaXMucGlwZWxpbmUgPSBudWxsXG4gICAgdGhpcy5kcmFpbnMgPSBudWxsIC8vIGlmIHdlIGFkZCBtb3JlIHNlbGRvbWx5IHVzZWQgaGVscGVycyB3ZSBtaWdodCB0aGVtIGludG8gYSBzdWJvYmplY3Qgc28gaXRzIGEgc2luZ2xlIHB0clxuICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhXcml0YWJsZSB8fCBieXRlTGVuZ3RoIHx8IGRlZmF1bHRCeXRlTGVuZ3RoXG4gICAgdGhpcy5tYXAgPSBtYXBXcml0YWJsZSB8fCBtYXBcbiAgICB0aGlzLmFmdGVyV3JpdGUgPSBhZnRlcldyaXRlLmJpbmQodGhpcylcbiAgICB0aGlzLmFmdGVyVXBkYXRlTmV4dFRpY2sgPSB1cGRhdGVXcml0ZU5ULmJpbmQodGhpcylcbiAgfVxuXG4gIGdldCBlbmRlZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJiBXUklURV9ET05FKSAhPT0gMFxuICB9XG5cbiAgcHVzaCAoZGF0YSkge1xuICAgIGlmICgodGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfRFJPUF9EQVRBKSAhPT0gMCkgcmV0dXJuIGZhbHNlXG4gICAgaWYgKHRoaXMubWFwICE9PSBudWxsKSBkYXRhID0gdGhpcy5tYXAoZGF0YSlcblxuICAgIHRoaXMuYnVmZmVyZWQgKz0gdGhpcy5ieXRlTGVuZ3RoKGRhdGEpXG4gICAgdGhpcy5xdWV1ZS5wdXNoKGRhdGEpXG5cbiAgICBpZiAodGhpcy5idWZmZXJlZCA8IHRoaXMuaGlnaFdhdGVyTWFyaykge1xuICAgICAgdGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlIHw9IFdSSVRFX1FVRVVFRFxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gV1JJVEVfUVVFVUVEX0FORF9VTkRSQUlORURcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHNoaWZ0ICgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5xdWV1ZS5zaGlmdCgpXG5cbiAgICB0aGlzLmJ1ZmZlcmVkIC09IHRoaXMuYnl0ZUxlbmd0aChkYXRhKVxuICAgIGlmICh0aGlzLmJ1ZmZlcmVkID09PSAwKSB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gV1JJVEVfTk9UX1FVRVVFRFxuXG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIGVuZCAoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5zdHJlYW0ub25jZSgnZmluaXNoJywgZGF0YSlcbiAgICBlbHNlIGlmIChkYXRhICE9PSB1bmRlZmluZWQgJiYgZGF0YSAhPT0gbnVsbCkgdGhpcy5wdXNoKGRhdGEpXG4gICAgdGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlID0gKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSB8IFdSSVRFX0ZJTklTSElORykgJiBXUklURV9OT05fUFJJTUFSWVxuICB9XG5cbiAgYXV0b0JhdGNoIChkYXRhLCBjYikge1xuICAgIGNvbnN0IGJ1ZmZlciA9IFtdXG4gICAgY29uc3Qgc3RyZWFtID0gdGhpcy5zdHJlYW1cblxuICAgIGJ1ZmZlci5wdXNoKGRhdGEpXG4gICAgd2hpbGUgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfU1RBVFVTKSA9PT0gV1JJVEVfUVVFVUVEX0FORF9BQ1RJVkUpIHtcbiAgICAgIGJ1ZmZlci5wdXNoKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5zaGlmdCgpKVxuICAgIH1cblxuICAgIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIE9QRU5fU1RBVFVTKSAhPT0gMCkgcmV0dXJuIGNiKG51bGwpXG4gICAgc3RyZWFtLl93cml0ZXYoYnVmZmVyLCBjYilcbiAgfVxuXG4gIHVwZGF0ZSAoKSB7XG4gICAgY29uc3Qgc3RyZWFtID0gdGhpcy5zdHJlYW1cblxuICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gV1JJVEVfVVBEQVRJTkdcblxuICAgIGRvIHtcbiAgICAgIHdoaWxlICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFdSSVRFX1NUQVRVUykgPT09IFdSSVRFX1FVRVVFRCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5zaGlmdCgpXG4gICAgICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gV1JJVEVfQUNUSVZFX0FORF9XUklUSU5HXG4gICAgICAgIHN0cmVhbS5fd3JpdGUoZGF0YSwgdGhpcy5hZnRlcldyaXRlKVxuICAgICAgfVxuXG4gICAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBXUklURV9QUklNQVJZX0FORF9BQ1RJVkUpID09PSAwKSB0aGlzLnVwZGF0ZU5vblByaW1hcnkoKVxuICAgIH0gd2hpbGUgKHRoaXMuY29udGludWVVcGRhdGUoKSA9PT0gdHJ1ZSlcblxuICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gV1JJVEVfTk9UX1VQREFUSU5HXG4gIH1cblxuICB1cGRhdGVOb25QcmltYXJ5ICgpIHtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLnN0cmVhbVxuXG4gICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfRklOSVNISU5HX1NUQVRVUykgPT09IFdSSVRFX0ZJTklTSElORykge1xuICAgICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSA9IHN0cmVhbS5fZHVwbGV4U3RhdGUgfCBXUklURV9BQ1RJVkVcbiAgICAgIHN0cmVhbS5fZmluYWwoYWZ0ZXJGaW5hbC5iaW5kKHRoaXMpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgREVTVFJPWV9TVEFUVVMpID09PSBERVNUUk9ZSU5HKSB7XG4gICAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBBQ1RJVkVfT1JfVElDS0lORykgPT09IDApIHtcbiAgICAgICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSB8PSBBQ1RJVkVcbiAgICAgICAgc3RyZWFtLl9kZXN0cm95KGFmdGVyRGVzdHJveS5iaW5kKHRoaXMpKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgSVNfT1BFTklORykgPT09IE9QRU5JTkcpIHtcbiAgICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgPSAoc3RyZWFtLl9kdXBsZXhTdGF0ZSB8IEFDVElWRSkgJiBOT1RfT1BFTklOR1xuICAgICAgc3RyZWFtLl9vcGVuKGFmdGVyT3Blbi5iaW5kKHRoaXMpKVxuICAgIH1cbiAgfVxuXG4gIGNvbnRpbnVlVXBkYXRlICgpIHtcbiAgICBpZiAoKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFdSSVRFX05FWFRfVElDSykgPT09IDApIHJldHVybiBmYWxzZVxuICAgIHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmPSBXUklURV9OT1RfTkVYVF9USUNLXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHVwZGF0ZUNhbGxiYWNrICgpIHtcbiAgICBpZiAoKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFdSSVRFX1VQREFURV9TWU5DX1NUQVRVUykgPT09IFdSSVRFX1BSSU1BUlkpIHRoaXMudXBkYXRlKClcbiAgICBlbHNlIHRoaXMudXBkYXRlTmV4dFRpY2soKVxuICB9XG5cbiAgdXBkYXRlTmV4dFRpY2sgKCkge1xuICAgIGlmICgodGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfTkVYVF9USUNLKSAhPT0gMCkgcmV0dXJuXG4gICAgdGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlIHw9IFdSSVRFX05FWFRfVElDS1xuICAgIGlmICgodGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfVVBEQVRJTkcpID09PSAwKSBxbXQodGhpcy5hZnRlclVwZGF0ZU5leHRUaWNrKVxuICB9XG59XG5cbmNsYXNzIFJlYWRhYmxlU3RhdGUge1xuICBjb25zdHJ1Y3RvciAoc3RyZWFtLCB7IGhpZ2hXYXRlck1hcmsgPSAxNjM4NCwgbWFwID0gbnVsbCwgbWFwUmVhZGFibGUsIGJ5dGVMZW5ndGgsIGJ5dGVMZW5ndGhSZWFkYWJsZSB9ID0ge30pIHtcbiAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbVxuICAgIHRoaXMucXVldWUgPSBuZXcgRklGTygpXG4gICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaGlnaFdhdGVyTWFyayA9PT0gMCA/IDEgOiBoaWdoV2F0ZXJNYXJrXG4gICAgdGhpcy5idWZmZXJlZCA9IDBcbiAgICB0aGlzLnJlYWRBaGVhZCA9IGhpZ2hXYXRlck1hcmsgPiAwXG4gICAgdGhpcy5lcnJvciA9IG51bGxcbiAgICB0aGlzLnBpcGVsaW5lID0gbnVsbFxuICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhSZWFkYWJsZSB8fCBieXRlTGVuZ3RoIHx8IGRlZmF1bHRCeXRlTGVuZ3RoXG4gICAgdGhpcy5tYXAgPSBtYXBSZWFkYWJsZSB8fCBtYXBcbiAgICB0aGlzLnBpcGVUbyA9IG51bGxcbiAgICB0aGlzLmFmdGVyUmVhZCA9IGFmdGVyUmVhZC5iaW5kKHRoaXMpXG4gICAgdGhpcy5hZnRlclVwZGF0ZU5leHRUaWNrID0gdXBkYXRlUmVhZE5ULmJpbmQodGhpcylcbiAgfVxuXG4gIGdldCBlbmRlZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJiBSRUFEX0RPTkUpICE9PSAwXG4gIH1cblxuICBwaXBlIChwaXBlVG8sIGNiKSB7XG4gICAgaWYgKHRoaXMucGlwZVRvICE9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IHBpcGUgdG8gb25lIGRlc3RpbmF0aW9uJylcbiAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG51bGxcblxuICAgIHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSB8PSBSRUFEX1BJUEVfRFJBSU5FRFxuICAgIHRoaXMucGlwZVRvID0gcGlwZVRvXG4gICAgdGhpcy5waXBlbGluZSA9IG5ldyBQaXBlbGluZSh0aGlzLnN0cmVhbSwgcGlwZVRvLCBjYilcblxuICAgIGlmIChjYikgdGhpcy5zdHJlYW0ub24oJ2Vycm9yJywgbm9vcCkgLy8gV2UgYWxyZWFkeSBlcnJvciBoYW5kbGUgdGhpcyBzbyBzdXByZXNzIGNyYXNoZXNcblxuICAgIGlmIChpc1N0cmVhbXgocGlwZVRvKSkge1xuICAgICAgcGlwZVRvLl93cml0YWJsZVN0YXRlLnBpcGVsaW5lID0gdGhpcy5waXBlbGluZVxuICAgICAgaWYgKGNiKSBwaXBlVG8ub24oJ2Vycm9yJywgbm9vcCkgLy8gV2UgYWxyZWFkeSBlcnJvciBoYW5kbGUgdGhpcyBzbyBzdXByZXNzIGNyYXNoZXNcbiAgICAgIHBpcGVUby5vbignZmluaXNoJywgdGhpcy5waXBlbGluZS5maW5pc2hlZC5iaW5kKHRoaXMucGlwZWxpbmUpKSAvLyBUT0RPOiBqdXN0IGNhbGwgZmluaXNoZWQgZnJvbSBwaXBlVG8gaXRzZWxmXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9uZXJyb3IgPSB0aGlzLnBpcGVsaW5lLmRvbmUuYmluZCh0aGlzLnBpcGVsaW5lLCBwaXBlVG8pXG4gICAgICBjb25zdCBvbmNsb3NlID0gdGhpcy5waXBlbGluZS5kb25lLmJpbmQodGhpcy5waXBlbGluZSwgcGlwZVRvLCBudWxsKSAvLyBvbmNsb3NlIGhhcyBhIHdlaXJkIGJvb2wgYXJnXG4gICAgICBwaXBlVG8ub24oJ2Vycm9yJywgb25lcnJvcilcbiAgICAgIHBpcGVUby5vbignY2xvc2UnLCBvbmNsb3NlKVxuICAgICAgcGlwZVRvLm9uKCdmaW5pc2gnLCB0aGlzLnBpcGVsaW5lLmZpbmlzaGVkLmJpbmQodGhpcy5waXBlbGluZSkpXG4gICAgfVxuXG4gICAgcGlwZVRvLm9uKCdkcmFpbicsIGFmdGVyRHJhaW4uYmluZCh0aGlzKSlcbiAgICB0aGlzLnN0cmVhbS5lbWl0KCdwaXBpbmcnLCBwaXBlVG8pXG4gICAgcGlwZVRvLmVtaXQoJ3BpcGUnLCB0aGlzLnN0cmVhbSlcbiAgfVxuXG4gIHB1c2ggKGRhdGEpIHtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLnN0cmVhbVxuXG4gICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuaGlnaFdhdGVyTWFyayA9IDBcbiAgICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgPSAoc3RyZWFtLl9kdXBsZXhTdGF0ZSB8IFJFQURfRU5ESU5HKSAmIFJFQURfTk9OX1BSSU1BUllfQU5EX1BVU0hFRFxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWFwICE9PSBudWxsKSB7XG4gICAgICBkYXRhID0gdGhpcy5tYXAoZGF0YSlcbiAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gUkVBRF9QVVNIRURcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyZWQgPCB0aGlzLmhpZ2hXYXRlck1hcmtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmJ1ZmZlcmVkICs9IHRoaXMuYnl0ZUxlbmd0aChkYXRhKVxuICAgIHRoaXMucXVldWUucHVzaChkYXRhKVxuXG4gICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSA9IChzdHJlYW0uX2R1cGxleFN0YXRlIHwgUkVBRF9RVUVVRUQpICYgUkVBRF9QVVNIRURcblxuICAgIHJldHVybiB0aGlzLmJ1ZmZlcmVkIDwgdGhpcy5oaWdoV2F0ZXJNYXJrXG4gIH1cblxuICBzaGlmdCAoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucXVldWUuc2hpZnQoKVxuXG4gICAgdGhpcy5idWZmZXJlZCAtPSB0aGlzLmJ5dGVMZW5ndGgoZGF0YSlcbiAgICBpZiAodGhpcy5idWZmZXJlZCA9PT0gMCkgdGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICY9IFJFQURfTk9UX1FVRVVFRFxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICB1bnNoaWZ0IChkYXRhKSB7XG4gICAgY29uc3QgcGVuZGluZyA9IFt0aGlzLm1hcCAhPT0gbnVsbCA/IHRoaXMubWFwKGRhdGEpIDogZGF0YV1cbiAgICB3aGlsZSAodGhpcy5idWZmZXJlZCA+IDApIHBlbmRpbmcucHVzaCh0aGlzLnNoaWZ0KCkpXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlbmRpbmcubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhID0gcGVuZGluZ1tpXVxuICAgICAgdGhpcy5idWZmZXJlZCArPSB0aGlzLmJ5dGVMZW5ndGgoZGF0YSlcbiAgICAgIHRoaXMucXVldWUucHVzaChkYXRhKVxuICAgIH1cblxuICAgIHRoaXMucHVzaChwZW5kaW5nW3BlbmRpbmcubGVuZ3RoIC0gMV0pXG4gIH1cblxuICByZWFkICgpIHtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLnN0cmVhbVxuXG4gICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9TVEFUVVMpID09PSBSRUFEX1FVRVVFRCkge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuc2hpZnQoKVxuICAgICAgaWYgKHRoaXMucGlwZVRvICE9PSBudWxsICYmIHRoaXMucGlwZVRvLndyaXRlKGRhdGEpID09PSBmYWxzZSkgc3RyZWFtLl9kdXBsZXhTdGF0ZSAmPSBSRUFEX1BJUEVfTk9UX0RSQUlORURcbiAgICAgIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfRU1JVF9EQVRBKSAhPT0gMCkgc3RyZWFtLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWFkQWhlYWQgPT09IGZhbHNlKSB7XG4gICAgICBzdHJlYW0uX2R1cGxleFN0YXRlIHw9IFJFQURfUkVBRF9BSEVBRFxuICAgICAgdGhpcy51cGRhdGVOZXh0VGljaygpXG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGRyYWluICgpIHtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLnN0cmVhbVxuXG4gICAgd2hpbGUgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9TVEFUVVMpID09PSBSRUFEX1FVRVVFRCAmJiAoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfRkxPV0lORykgIT09IDApIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnNoaWZ0KClcbiAgICAgIGlmICh0aGlzLnBpcGVUbyAhPT0gbnVsbCAmJiB0aGlzLnBpcGVUby53cml0ZShkYXRhKSA9PT0gZmFsc2UpIHN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gUkVBRF9QSVBFX05PVF9EUkFJTkVEXG4gICAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBSRUFEX0VNSVRfREFUQSkgIT09IDApIHN0cmVhbS5lbWl0KCdkYXRhJywgZGF0YSlcbiAgICB9XG4gIH1cblxuICB1cGRhdGUgKCkge1xuICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuc3RyZWFtXG5cbiAgICBzdHJlYW0uX2R1cGxleFN0YXRlIHw9IFJFQURfVVBEQVRJTkdcblxuICAgIGRvIHtcbiAgICAgIHRoaXMuZHJhaW4oKVxuXG4gICAgICB3aGlsZSAodGhpcy5idWZmZXJlZCA8IHRoaXMuaGlnaFdhdGVyTWFyayAmJiAoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFNIT1VMRF9OT1RfUkVBRCkgPT09IFJFQURfUkVBRF9BSEVBRCkge1xuICAgICAgICBzdHJlYW0uX2R1cGxleFN0YXRlIHw9IFJFQURfQUNUSVZFX0FORF9ORUVEU19QVVNIXG4gICAgICAgIHN0cmVhbS5fcmVhZCh0aGlzLmFmdGVyUmVhZClcbiAgICAgICAgdGhpcy5kcmFpbigpXG4gICAgICB9XG5cbiAgICAgIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfUkVBREFCTEVfU1RBVFVTKSA9PT0gUkVBRF9FTUlUX1JFQURBQkxFX0FORF9RVUVVRUQpIHtcbiAgICAgICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSB8PSBSRUFEX0VNSVRURURfUkVBREFCTEVcbiAgICAgICAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJylcbiAgICAgIH1cblxuICAgICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9QUklNQVJZX0FORF9BQ1RJVkUpID09PSAwKSB0aGlzLnVwZGF0ZU5vblByaW1hcnkoKVxuICAgIH0gd2hpbGUgKHRoaXMuY29udGludWVVcGRhdGUoKSA9PT0gdHJ1ZSlcblxuICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gUkVBRF9OT1RfVVBEQVRJTkdcbiAgfVxuXG4gIHVwZGF0ZU5vblByaW1hcnkgKCkge1xuICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuc3RyZWFtXG5cbiAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBSRUFEX0VORElOR19TVEFUVVMpID09PSBSRUFEX0VORElORykge1xuICAgICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSA9IChzdHJlYW0uX2R1cGxleFN0YXRlIHwgUkVBRF9ET05FKSAmIFJFQURfTk9UX0VORElOR1xuICAgICAgc3RyZWFtLmVtaXQoJ2VuZCcpXG4gICAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBBVVRPX0RFU1RST1kpID09PSBET05FKSBzdHJlYW0uX2R1cGxleFN0YXRlIHw9IERFU1RST1lJTkdcbiAgICAgIGlmICh0aGlzLnBpcGVUbyAhPT0gbnVsbCkgdGhpcy5waXBlVG8uZW5kKClcbiAgICB9XG5cbiAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBERVNUUk9ZX1NUQVRVUykgPT09IERFU1RST1lJTkcpIHtcbiAgICAgIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIEFDVElWRV9PUl9USUNLSU5HKSA9PT0gMCkge1xuICAgICAgICBzdHJlYW0uX2R1cGxleFN0YXRlIHw9IEFDVElWRVxuICAgICAgICBzdHJlYW0uX2Rlc3Ryb3koYWZ0ZXJEZXN0cm95LmJpbmQodGhpcykpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBJU19PUEVOSU5HKSA9PT0gT1BFTklORykge1xuICAgICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSA9IChzdHJlYW0uX2R1cGxleFN0YXRlIHwgQUNUSVZFKSAmIE5PVF9PUEVOSU5HXG4gICAgICBzdHJlYW0uX29wZW4oYWZ0ZXJPcGVuLmJpbmQodGhpcykpXG4gICAgfVxuICB9XG5cbiAgY29udGludWVVcGRhdGUgKCkge1xuICAgIGlmICgodGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9ORVhUX1RJQ0spID09PSAwKSByZXR1cm4gZmFsc2VcbiAgICB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gUkVBRF9OT1RfTkVYVF9USUNLXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHVwZGF0ZUNhbGxiYWNrICgpIHtcbiAgICBpZiAoKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfVVBEQVRFX1NZTkNfU1RBVFVTKSA9PT0gUkVBRF9QUklNQVJZKSB0aGlzLnVwZGF0ZSgpXG4gICAgZWxzZSB0aGlzLnVwZGF0ZU5leHRUaWNrKClcbiAgfVxuXG4gIHVwZGF0ZU5leHRUaWNrSWZPcGVuICgpIHtcbiAgICBpZiAoKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfTkVYVF9USUNLX09SX09QRU5JTkcpICE9PSAwKSByZXR1cm5cbiAgICB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gUkVBRF9ORVhUX1RJQ0tcbiAgICBpZiAoKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfVVBEQVRJTkcpID09PSAwKSBxbXQodGhpcy5hZnRlclVwZGF0ZU5leHRUaWNrKVxuICB9XG5cbiAgdXBkYXRlTmV4dFRpY2sgKCkge1xuICAgIGlmICgodGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9ORVhUX1RJQ0spICE9PSAwKSByZXR1cm5cbiAgICB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gUkVBRF9ORVhUX1RJQ0tcbiAgICBpZiAoKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfVVBEQVRJTkcpID09PSAwKSBxbXQodGhpcy5hZnRlclVwZGF0ZU5leHRUaWNrKVxuICB9XG59XG5cbmNsYXNzIFRyYW5zZm9ybVN0YXRlIHtcbiAgY29uc3RydWN0b3IgKHN0cmVhbSkge1xuICAgIHRoaXMuZGF0YSA9IG51bGxcbiAgICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gYWZ0ZXJUcmFuc2Zvcm0uYmluZChzdHJlYW0pXG4gICAgdGhpcy5hZnRlckZpbmFsID0gbnVsbFxuICB9XG59XG5cbmNsYXNzIFBpcGVsaW5lIHtcbiAgY29uc3RydWN0b3IgKHNyYywgZHN0LCBjYikge1xuICAgIHRoaXMuZnJvbSA9IHNyY1xuICAgIHRoaXMudG8gPSBkc3RcbiAgICB0aGlzLmFmdGVyUGlwZSA9IGNiXG4gICAgdGhpcy5lcnJvciA9IG51bGxcbiAgICB0aGlzLnBpcGVUb0ZpbmlzaGVkID0gZmFsc2VcbiAgfVxuXG4gIGZpbmlzaGVkICgpIHtcbiAgICB0aGlzLnBpcGVUb0ZpbmlzaGVkID0gdHJ1ZVxuICB9XG5cbiAgZG9uZSAoc3RyZWFtLCBlcnIpIHtcbiAgICBpZiAoZXJyKSB0aGlzLmVycm9yID0gZXJyXG5cbiAgICBpZiAoc3RyZWFtID09PSB0aGlzLnRvKSB7XG4gICAgICB0aGlzLnRvID0gbnVsbFxuXG4gICAgICBpZiAodGhpcy5mcm9tICE9PSBudWxsKSB7XG4gICAgICAgIGlmICgodGhpcy5mcm9tLl9kdXBsZXhTdGF0ZSAmIFJFQURfRE9ORSkgPT09IDAgfHwgIXRoaXMucGlwZVRvRmluaXNoZWQpIHtcbiAgICAgICAgICB0aGlzLmZyb20uZGVzdHJveSh0aGlzLmVycm9yIHx8IG5ldyBFcnJvcignV3JpdGFibGUgc3RyZWFtIGNsb3NlZCBwcmVtYXR1cmVseScpKVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHJlYW0gPT09IHRoaXMuZnJvbSkge1xuICAgICAgdGhpcy5mcm9tID0gbnVsbFxuXG4gICAgICBpZiAodGhpcy50byAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBSRUFEX0RPTkUpID09PSAwKSB7XG4gICAgICAgICAgdGhpcy50by5kZXN0cm95KHRoaXMuZXJyb3IgfHwgbmV3IEVycm9yKCdSZWFkYWJsZSBzdHJlYW0gY2xvc2VkIGJlZm9yZSBlbmRpbmcnKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5hZnRlclBpcGUgIT09IG51bGwpIHRoaXMuYWZ0ZXJQaXBlKHRoaXMuZXJyb3IpXG4gICAgdGhpcy50byA9IHRoaXMuZnJvbSA9IHRoaXMuYWZ0ZXJQaXBlID0gbnVsbFxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyRHJhaW4gKCkge1xuICB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gUkVBRF9QSVBFX0RSQUlORURcbiAgdGhpcy51cGRhdGVDYWxsYmFjaygpXG59XG5cbmZ1bmN0aW9uIGFmdGVyRmluYWwgKGVycikge1xuICBjb25zdCBzdHJlYW0gPSB0aGlzLnN0cmVhbVxuICBpZiAoZXJyKSBzdHJlYW0uZGVzdHJveShlcnIpXG4gIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIERFU1RST1lfU1RBVFVTKSA9PT0gMCkge1xuICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gV1JJVEVfRE9ORVxuICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKVxuICB9XG4gIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIEFVVE9fREVTVFJPWSkgPT09IERPTkUpIHtcbiAgICBzdHJlYW0uX2R1cGxleFN0YXRlIHw9IERFU1RST1lJTkdcbiAgfVxuXG4gIHN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gV1JJVEVfTk9UX0ZJTklTSElOR1xuXG4gIC8vIG5vIG5lZWQgdG8gd2FpdCB0aGUgZXh0cmEgdGljayBoZXJlLCBzbyB3ZSBzaG9ydCBjaXJjdWl0IHRoYXRcbiAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfVVBEQVRJTkcpID09PSAwKSB0aGlzLnVwZGF0ZSgpXG4gIGVsc2UgdGhpcy51cGRhdGVOZXh0VGljaygpXG59XG5cbmZ1bmN0aW9uIGFmdGVyRGVzdHJveSAoZXJyKSB7XG4gIGNvbnN0IHN0cmVhbSA9IHRoaXMuc3RyZWFtXG5cbiAgaWYgKCFlcnIgJiYgdGhpcy5lcnJvciAhPT0gU1RSRUFNX0RFU1RST1lFRCkgZXJyID0gdGhpcy5lcnJvclxuICBpZiAoZXJyKSBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpXG4gIHN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gREVTVFJPWUVEXG4gIHN0cmVhbS5lbWl0KCdjbG9zZScpXG5cbiAgY29uc3QgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGVcbiAgY29uc3Qgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGVcblxuICBpZiAocnMgIT09IG51bGwgJiYgcnMucGlwZWxpbmUgIT09IG51bGwpIHJzLnBpcGVsaW5lLmRvbmUoc3RyZWFtLCBlcnIpXG5cbiAgaWYgKHdzICE9PSBudWxsKSB7XG4gICAgd2hpbGUgKHdzLmRyYWlucyAhPT0gbnVsbCAmJiB3cy5kcmFpbnMubGVuZ3RoID4gMCkgd3MuZHJhaW5zLnNoaWZ0KCkucmVzb2x2ZShmYWxzZSlcbiAgICBpZiAod3MucGlwZWxpbmUgIT09IG51bGwpIHdzLnBpcGVsaW5lLmRvbmUoc3RyZWFtLCBlcnIpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZSAoZXJyKSB7XG4gIGNvbnN0IHN0cmVhbSA9IHRoaXMuc3RyZWFtXG5cbiAgaWYgKGVycikgc3RyZWFtLmRlc3Ryb3koZXJyKVxuICBzdHJlYW0uX2R1cGxleFN0YXRlICY9IFdSSVRFX05PVF9BQ1RJVkVcblxuICBpZiAodGhpcy5kcmFpbnMgIT09IG51bGwpIHRpY2tEcmFpbnModGhpcy5kcmFpbnMpXG5cbiAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfRFJBSU5fU1RBVFVTKSA9PT0gV1JJVEVfVU5EUkFJTkVEKSB7XG4gICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSAmPSBXUklURV9EUkFJTkVEXG4gICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfRU1JVF9EUkFJTikgPT09IFdSSVRFX0VNSVRfRFJBSU4pIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpXG4gICAgfVxuICB9XG5cbiAgdGhpcy51cGRhdGVDYWxsYmFjaygpXG59XG5cbmZ1bmN0aW9uIGFmdGVyUmVhZCAoZXJyKSB7XG4gIGlmIChlcnIpIHRoaXMuc3RyZWFtLmRlc3Ryb3koZXJyKVxuICB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gUkVBRF9OT1RfQUNUSVZFXG4gIGlmICh0aGlzLnJlYWRBaGVhZCA9PT0gZmFsc2UgJiYgKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfUkVTVU1FRCkgPT09IDApIHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmPSBSRUFEX05PX1JFQURfQUhFQURcbiAgdGhpcy51cGRhdGVDYWxsYmFjaygpXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlYWROVCAoKSB7XG4gIGlmICgodGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9VUERBVElORykgPT09IDApIHtcbiAgICB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gUkVBRF9OT1RfTkVYVF9USUNLXG4gICAgdGhpcy51cGRhdGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdyaXRlTlQgKCkge1xuICBpZiAoKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFdSSVRFX1VQREFUSU5HKSA9PT0gMCkge1xuICAgIHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmPSBXUklURV9OT1RfTkVYVF9USUNLXG4gICAgdGhpcy51cGRhdGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIHRpY2tEcmFpbnMgKGRyYWlucykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRyYWlucy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGRyYWlucy53cml0ZXMgYXJlIG1vbm90b25pYywgc28gaWYgb25lIGlzIDAgaXRzIGFsd2F5cyB0aGUgZmlyc3Qgb25lXG4gICAgaWYgKC0tZHJhaW5zW2ldLndyaXRlcyA9PT0gMCkge1xuICAgICAgZHJhaW5zLnNoaWZ0KCkucmVzb2x2ZSh0cnVlKVxuICAgICAgaS0tXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyT3BlbiAoZXJyKSB7XG4gIGNvbnN0IHN0cmVhbSA9IHRoaXMuc3RyZWFtXG5cbiAgaWYgKGVycikgc3RyZWFtLmRlc3Ryb3koZXJyKVxuXG4gIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIERFU1RST1lJTkcpID09PSAwKSB7XG4gICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9QUklNQVJZX1NUQVRVUykgPT09IDApIHN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gUkVBRF9QUklNQVJZXG4gICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfUFJJTUFSWV9TVEFUVVMpID09PSAwKSBzdHJlYW0uX2R1cGxleFN0YXRlIHw9IFdSSVRFX1BSSU1BUllcbiAgICBzdHJlYW0uZW1pdCgnb3BlbicpXG4gIH1cblxuICBzdHJlYW0uX2R1cGxleFN0YXRlICY9IE5PVF9BQ1RJVkVcblxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlICE9PSBudWxsKSB7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLnVwZGF0ZUNhbGxiYWNrKClcbiAgfVxuXG4gIGlmIChzdHJlYW0uX3JlYWRhYmxlU3RhdGUgIT09IG51bGwpIHtcbiAgICBzdHJlYW0uX3JlYWRhYmxlU3RhdGUudXBkYXRlQ2FsbGJhY2soKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtIChlcnIsIGRhdGEpIHtcbiAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhICE9PSBudWxsKSB0aGlzLnB1c2goZGF0YSlcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5hZnRlcldyaXRlKGVycilcbn1cblxuZnVuY3Rpb24gbmV3TGlzdGVuZXIgKG5hbWUpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgIT09IG51bGwpIHtcbiAgICBpZiAobmFtZSA9PT0gJ2RhdGEnKSB7XG4gICAgICB0aGlzLl9kdXBsZXhTdGF0ZSB8PSAoUkVBRF9FTUlUX0RBVEEgfCBSRUFEX1JFU1VNRURfUkVBRF9BSEVBRClcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUudXBkYXRlTmV4dFRpY2soKVxuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gJ3JlYWRhYmxlJykge1xuICAgICAgdGhpcy5fZHVwbGV4U3RhdGUgfD0gUkVBRF9FTUlUX1JFQURBQkxFXG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSAhPT0gbnVsbCkge1xuICAgIGlmIChuYW1lID09PSAnZHJhaW4nKSB7XG4gICAgICB0aGlzLl9kdXBsZXhTdGF0ZSB8PSBXUklURV9FTUlUX0RSQUlOXG4gICAgICB0aGlzLl93cml0YWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgU3RyZWFtIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzLl9kdXBsZXhTdGF0ZSA9IDBcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbnVsbFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBudWxsXG5cbiAgICBpZiAob3B0cykge1xuICAgICAgaWYgKG9wdHMub3BlbikgdGhpcy5fb3BlbiA9IG9wdHMub3BlblxuICAgICAgaWYgKG9wdHMuZGVzdHJveSkgdGhpcy5fZGVzdHJveSA9IG9wdHMuZGVzdHJveVxuICAgICAgaWYgKG9wdHMucHJlZGVzdHJveSkgdGhpcy5fcHJlZGVzdHJveSA9IG9wdHMucHJlZGVzdHJveVxuICAgICAgaWYgKG9wdHMuc2lnbmFsKSB7XG4gICAgICAgIG9wdHMuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnQuYmluZCh0aGlzKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm9uKCduZXdMaXN0ZW5lcicsIG5ld0xpc3RlbmVyKVxuICB9XG5cbiAgX29wZW4gKGNiKSB7XG4gICAgY2IobnVsbClcbiAgfVxuXG4gIF9kZXN0cm95IChjYikge1xuICAgIGNiKG51bGwpXG4gIH1cblxuICBfcHJlZGVzdHJveSAoKSB7XG4gICAgLy8gZG9lcyBub3RoaW5nXG4gIH1cblxuICBnZXQgcmVhZGFibGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlICE9PSBudWxsID8gdHJ1ZSA6IHVuZGVmaW5lZFxuICB9XG5cbiAgZ2V0IHdyaXRhYmxlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAhPT0gbnVsbCA/IHRydWUgOiB1bmRlZmluZWRcbiAgfVxuXG4gIGdldCBkZXN0cm95ZWQgKCkge1xuICAgIHJldHVybiAodGhpcy5fZHVwbGV4U3RhdGUgJiBERVNUUk9ZRUQpICE9PSAwXG4gIH1cblxuICBnZXQgZGVzdHJveWluZyAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9kdXBsZXhTdGF0ZSAmIERFU1RST1lfU1RBVFVTKSAhPT0gMFxuICB9XG5cbiAgZGVzdHJveSAoZXJyKSB7XG4gICAgaWYgKCh0aGlzLl9kdXBsZXhTdGF0ZSAmIERFU1RST1lfU1RBVFVTKSA9PT0gMCkge1xuICAgICAgaWYgKCFlcnIpIGVyciA9IFNUUkVBTV9ERVNUUk9ZRURcbiAgICAgIHRoaXMuX2R1cGxleFN0YXRlID0gKHRoaXMuX2R1cGxleFN0YXRlIHwgREVTVFJPWUlORykgJiBOT05fUFJJTUFSWVxuXG4gICAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcmsgPSAwXG4gICAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZXJyb3IgPSBlcnJcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyayA9IDBcbiAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvciA9IGVyclxuICAgICAgfVxuXG4gICAgICB0aGlzLl9kdXBsZXhTdGF0ZSB8PSBQUkVERVNUUk9ZSU5HXG4gICAgICB0aGlzLl9wcmVkZXN0cm95KClcbiAgICAgIHRoaXMuX2R1cGxleFN0YXRlICY9IE5PVF9QUkVERVNUUk9ZSU5HXG5cbiAgICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlICE9PSBudWxsKSB0aGlzLl9yZWFkYWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlICE9PSBudWxsKSB0aGlzLl93cml0YWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgUmVhZGFibGUgZXh0ZW5kcyBTdHJlYW0ge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMpXG5cbiAgICB0aGlzLl9kdXBsZXhTdGF0ZSB8PSBPUEVOSU5HIHwgV1JJVEVfRE9ORSB8IFJFQURfUkVBRF9BSEVBRFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZSh0aGlzLCBvcHRzKVxuXG4gICAgaWYgKG9wdHMpIHtcbiAgICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRBaGVhZCA9PT0gZmFsc2UpIHRoaXMuX2R1cGxleFN0YXRlICY9IFJFQURfTk9fUkVBRF9BSEVBRFxuICAgICAgaWYgKG9wdHMucmVhZCkgdGhpcy5fcmVhZCA9IG9wdHMucmVhZFxuICAgICAgaWYgKG9wdHMuZWFnZXJPcGVuKSB0aGlzLl9yZWFkYWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgICAgIGlmIChvcHRzLmVuY29kaW5nKSB0aGlzLnNldEVuY29kaW5nKG9wdHMuZW5jb2RpbmcpXG4gICAgfVxuICB9XG5cbiAgc2V0RW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gICAgY29uc3QgZGVjID0gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nKVxuICAgIGNvbnN0IG1hcCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUubWFwIHx8IGVjaG9cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLm1hcCA9IG1hcE9yU2tpcFxuICAgIHJldHVybiB0aGlzXG5cbiAgICBmdW5jdGlvbiBtYXBPclNraXAgKGRhdGEpIHtcbiAgICAgIGNvbnN0IG5leHQgPSBkZWMucHVzaChkYXRhKVxuICAgICAgcmV0dXJuIG5leHQgPT09ICcnICYmIChkYXRhLmJ5dGVMZW5ndGggIT09IDAgfHwgZGVjLnJlbWFpbmluZyA+IDApID8gbnVsbCA6IG1hcChuZXh0KVxuICAgIH1cbiAgfVxuXG4gIF9yZWFkIChjYikge1xuICAgIGNiKG51bGwpXG4gIH1cblxuICBwaXBlIChkZXN0LCBjYikge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUudXBkYXRlTmV4dFRpY2soKVxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucGlwZShkZXN0LCBjYilcbiAgICByZXR1cm4gZGVzdFxuICB9XG5cbiAgcmVhZCAoKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS51cGRhdGVOZXh0VGljaygpXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZCgpXG4gIH1cblxuICBwdXNoIChkYXRhKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS51cGRhdGVOZXh0VGlja0lmT3BlbigpXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUucHVzaChkYXRhKVxuICB9XG5cbiAgdW5zaGlmdCAoZGF0YSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUudXBkYXRlTmV4dFRpY2tJZk9wZW4oKVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLnVuc2hpZnQoZGF0YSlcbiAgfVxuXG4gIHJlc3VtZSAoKSB7XG4gICAgdGhpcy5fZHVwbGV4U3RhdGUgfD0gUkVBRF9SRVNVTUVEX1JFQURfQUhFQURcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcGF1c2UgKCkge1xuICAgIHRoaXMuX2R1cGxleFN0YXRlICY9ICh0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRBaGVhZCA9PT0gZmFsc2UgPyBSRUFEX1BBVVNFRF9OT19SRUFEX0FIRUFEIDogUkVBRF9QQVVTRUQpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXRpYyBfZnJvbUFzeW5jSXRlcmF0b3IgKGl0ZSwgb3B0cykge1xuICAgIGxldCBkZXN0cm95XG5cbiAgICBjb25zdCBycyA9IG5ldyBSZWFkYWJsZSh7XG4gICAgICAuLi5vcHRzLFxuICAgICAgcmVhZCAoY2IpIHtcbiAgICAgICAgaXRlLm5leHQoKS50aGVuKHB1c2gpLnRoZW4oY2IuYmluZChudWxsLCBudWxsKSkuY2F0Y2goY2IpXG4gICAgICB9LFxuICAgICAgcHJlZGVzdHJveSAoKSB7XG4gICAgICAgIGRlc3Ryb3kgPSBpdGUucmV0dXJuKClcbiAgICAgIH0sXG4gICAgICBkZXN0cm95IChjYikge1xuICAgICAgICBpZiAoIWRlc3Ryb3kpIHJldHVybiBjYihudWxsKVxuICAgICAgICBkZXN0cm95LnRoZW4oY2IuYmluZChudWxsLCBudWxsKSkuY2F0Y2goY2IpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiByc1xuXG4gICAgZnVuY3Rpb24gcHVzaCAoZGF0YSkge1xuICAgICAgaWYgKGRhdGEuZG9uZSkgcnMucHVzaChudWxsKVxuICAgICAgZWxzZSBycy5wdXNoKGRhdGEudmFsdWUpXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGZyb20gKGRhdGEsIG9wdHMpIHtcbiAgICBpZiAoaXNSZWFkU3RyZWFteChkYXRhKSkgcmV0dXJuIGRhdGFcbiAgICBpZiAoZGF0YVthc3luY0l0ZXJhdG9yXSkgcmV0dXJuIHRoaXMuX2Zyb21Bc3luY0l0ZXJhdG9yKGRhdGFbYXN5bmNJdGVyYXRvcl0oKSwgb3B0cylcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIGRhdGEgPSBkYXRhID09PSB1bmRlZmluZWQgPyBbXSA6IFtkYXRhXVxuXG4gICAgbGV0IGkgPSAwXG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZSh7XG4gICAgICAuLi5vcHRzLFxuICAgICAgcmVhZCAoY2IpIHtcbiAgICAgICAgdGhpcy5wdXNoKGkgPT09IGRhdGEubGVuZ3RoID8gbnVsbCA6IGRhdGFbaSsrXSlcbiAgICAgICAgY2IobnVsbClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgc3RhdGljIGlzQmFja3ByZXNzdXJlZCAocnMpIHtcbiAgICByZXR1cm4gKHJzLl9kdXBsZXhTdGF0ZSAmIFJFQURfQkFDS1BSRVNTVVJFX1NUQVRVUykgIT09IDAgfHwgcnMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyZWQgPj0gcnMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFya1xuICB9XG5cbiAgc3RhdGljIGlzUGF1c2VkIChycykge1xuICAgIHJldHVybiAocnMuX2R1cGxleFN0YXRlICYgUkVBRF9SRVNVTUVEKSA9PT0gMFxuICB9XG5cbiAgW2FzeW5jSXRlcmF0b3JdICgpIHtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzXG5cbiAgICBsZXQgZXJyb3IgPSBudWxsXG4gICAgbGV0IHByb21pc2VSZXNvbHZlID0gbnVsbFxuICAgIGxldCBwcm9taXNlUmVqZWN0ID0gbnVsbFxuXG4gICAgdGhpcy5vbignZXJyb3InLCAoZXJyKSA9PiB7IGVycm9yID0gZXJyIH0pXG4gICAgdGhpcy5vbigncmVhZGFibGUnLCBvbnJlYWRhYmxlKVxuICAgIHRoaXMub24oJ2Nsb3NlJywgb25jbG9zZSlcblxuICAgIHJldHVybiB7XG4gICAgICBbYXN5bmNJdGVyYXRvcl0gKCkge1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfSxcbiAgICAgIG5leHQgKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHByb21pc2VSZXNvbHZlID0gcmVzb2x2ZVxuICAgICAgICAgIHByb21pc2VSZWplY3QgPSByZWplY3RcbiAgICAgICAgICBjb25zdCBkYXRhID0gc3RyZWFtLnJlYWQoKVxuICAgICAgICAgIGlmIChkYXRhICE9PSBudWxsKSBvbmRhdGEoZGF0YSlcbiAgICAgICAgICBlbHNlIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIERFU1RST1lFRCkgIT09IDApIG9uZGF0YShudWxsKVxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIHJldHVybiAoKSB7XG4gICAgICAgIHJldHVybiBkZXN0cm95KG51bGwpXG4gICAgICB9LFxuICAgICAgdGhyb3cgKGVycikge1xuICAgICAgICByZXR1cm4gZGVzdHJveShlcnIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25yZWFkYWJsZSAoKSB7XG4gICAgICBpZiAocHJvbWlzZVJlc29sdmUgIT09IG51bGwpIG9uZGF0YShzdHJlYW0ucmVhZCgpKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uY2xvc2UgKCkge1xuICAgICAgaWYgKHByb21pc2VSZXNvbHZlICE9PSBudWxsKSBvbmRhdGEobnVsbClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbmRhdGEgKGRhdGEpIHtcbiAgICAgIGlmIChwcm9taXNlUmVqZWN0ID09PSBudWxsKSByZXR1cm5cbiAgICAgIGlmIChlcnJvcikgcHJvbWlzZVJlamVjdChlcnJvcilcbiAgICAgIGVsc2UgaWYgKGRhdGEgPT09IG51bGwgJiYgKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBSRUFEX0RPTkUpID09PSAwKSBwcm9taXNlUmVqZWN0KFNUUkVBTV9ERVNUUk9ZRUQpXG4gICAgICBlbHNlIHByb21pc2VSZXNvbHZlKHsgdmFsdWU6IGRhdGEsIGRvbmU6IGRhdGEgPT09IG51bGwgfSlcbiAgICAgIHByb21pc2VSZWplY3QgPSBwcm9taXNlUmVzb2x2ZSA9IG51bGxcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXN0cm95IChlcnIpIHtcbiAgICAgIHN0cmVhbS5kZXN0cm95KGVycilcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGlmIChzdHJlYW0uX2R1cGxleFN0YXRlICYgREVTVFJPWUVEKSByZXR1cm4gcmVzb2x2ZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSlcbiAgICAgICAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChlcnIpIHJlamVjdChlcnIpXG4gICAgICAgICAgZWxzZSByZXNvbHZlKHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgV3JpdGFibGUgZXh0ZW5kcyBTdHJlYW0ge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMpXG5cbiAgICB0aGlzLl9kdXBsZXhTdGF0ZSB8PSBPUEVOSU5HIHwgUkVBRF9ET05FXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKHRoaXMsIG9wdHMpXG5cbiAgICBpZiAob3B0cykge1xuICAgICAgaWYgKG9wdHMud3JpdGV2KSB0aGlzLl93cml0ZXYgPSBvcHRzLndyaXRldlxuICAgICAgaWYgKG9wdHMud3JpdGUpIHRoaXMuX3dyaXRlID0gb3B0cy53cml0ZVxuICAgICAgaWYgKG9wdHMuZmluYWwpIHRoaXMuX2ZpbmFsID0gb3B0cy5maW5hbFxuICAgICAgaWYgKG9wdHMuZWFnZXJPcGVuKSB0aGlzLl93cml0YWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgICB9XG4gIH1cblxuICBjb3JrICgpIHtcbiAgICB0aGlzLl9kdXBsZXhTdGF0ZSB8PSBXUklURV9DT1JLRURcbiAgfVxuXG4gIHVuY29yayAoKSB7XG4gICAgdGhpcy5fZHVwbGV4U3RhdGUgJj0gV1JJVEVfTk9UX0NPUktFRFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUudXBkYXRlTmV4dFRpY2soKVxuICB9XG5cbiAgX3dyaXRldiAoYmF0Y2gsIGNiKSB7XG4gICAgY2IobnVsbClcbiAgfVxuXG4gIF93cml0ZSAoZGF0YSwgY2IpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmF1dG9CYXRjaChkYXRhLCBjYilcbiAgfVxuXG4gIF9maW5hbCAoY2IpIHtcbiAgICBjYihudWxsKVxuICB9XG5cbiAgc3RhdGljIGlzQmFja3ByZXNzdXJlZCAod3MpIHtcbiAgICByZXR1cm4gKHdzLl9kdXBsZXhTdGF0ZSAmIFdSSVRFX0JBQ0tQUkVTU1VSRV9TVEFUVVMpICE9PSAwXG4gIH1cblxuICBzdGF0aWMgZHJhaW5lZCAod3MpIHtcbiAgICBpZiAod3MuZGVzdHJveWVkKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKVxuICAgIGNvbnN0IHN0YXRlID0gd3MuX3dyaXRhYmxlU3RhdGVcbiAgICBjb25zdCBwZW5kaW5nID0gKGlzV3JpdGV2KHdzKSA/IE1hdGgubWluKDEsIHN0YXRlLnF1ZXVlLmxlbmd0aCkgOiBzdGF0ZS5xdWV1ZS5sZW5ndGgpXG4gICAgY29uc3Qgd3JpdGVzID0gcGVuZGluZyArICgod3MuX2R1cGxleFN0YXRlICYgV1JJVEVfV1JJVElORykgPyAxIDogMClcbiAgICBpZiAod3JpdGVzID09PSAwKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpXG4gICAgaWYgKHN0YXRlLmRyYWlucyA9PT0gbnVsbCkgc3RhdGUuZHJhaW5zID0gW11cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHN0YXRlLmRyYWlucy5wdXNoKHsgd3JpdGVzLCByZXNvbHZlIH0pXG4gICAgfSlcbiAgfVxuXG4gIHdyaXRlIChkYXRhKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS51cGRhdGVOZXh0VGljaygpXG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUucHVzaChkYXRhKVxuICB9XG5cbiAgZW5kIChkYXRhKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS51cGRhdGVOZXh0VGljaygpXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmQoZGF0YSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbmNsYXNzIER1cGxleCBleHRlbmRzIFJlYWRhYmxlIHsgLy8gYW5kIFdyaXRhYmxlXG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cylcblxuICAgIHRoaXMuX2R1cGxleFN0YXRlID0gT1BFTklORyB8ICh0aGlzLl9kdXBsZXhTdGF0ZSAmIFJFQURfUkVBRF9BSEVBRClcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUodGhpcywgb3B0cylcblxuICAgIGlmIChvcHRzKSB7XG4gICAgICBpZiAob3B0cy53cml0ZXYpIHRoaXMuX3dyaXRldiA9IG9wdHMud3JpdGV2XG4gICAgICBpZiAob3B0cy53cml0ZSkgdGhpcy5fd3JpdGUgPSBvcHRzLndyaXRlXG4gICAgICBpZiAob3B0cy5maW5hbCkgdGhpcy5fZmluYWwgPSBvcHRzLmZpbmFsXG4gICAgfVxuICB9XG5cbiAgY29yayAoKSB7XG4gICAgdGhpcy5fZHVwbGV4U3RhdGUgfD0gV1JJVEVfQ09SS0VEXG4gIH1cblxuICB1bmNvcmsgKCkge1xuICAgIHRoaXMuX2R1cGxleFN0YXRlICY9IFdSSVRFX05PVF9DT1JLRURcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgfVxuXG4gIF93cml0ZXYgKGJhdGNoLCBjYikge1xuICAgIGNiKG51bGwpXG4gIH1cblxuICBfd3JpdGUgKGRhdGEsIGNiKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5hdXRvQmF0Y2goZGF0YSwgY2IpXG4gIH1cblxuICBfZmluYWwgKGNiKSB7XG4gICAgY2IobnVsbClcbiAgfVxuXG4gIHdyaXRlIChkYXRhKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS51cGRhdGVOZXh0VGljaygpXG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUucHVzaChkYXRhKVxuICB9XG5cbiAgZW5kIChkYXRhKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS51cGRhdGVOZXh0VGljaygpXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmQoZGF0YSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbmNsYXNzIFRyYW5zZm9ybSBleHRlbmRzIER1cGxleCB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cylcbiAgICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZSh0aGlzKVxuXG4gICAgaWYgKG9wdHMpIHtcbiAgICAgIGlmIChvcHRzLnRyYW5zZm9ybSkgdGhpcy5fdHJhbnNmb3JtID0gb3B0cy50cmFuc2Zvcm1cbiAgICAgIGlmIChvcHRzLmZsdXNoKSB0aGlzLl9mbHVzaCA9IG9wdHMuZmx1c2hcbiAgICB9XG4gIH1cblxuICBfd3JpdGUgKGRhdGEsIGNiKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyZWQgPj0gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5kYXRhID0gZGF0YVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm0oZGF0YSwgdGhpcy5fdHJhbnNmb3JtU3RhdGUuYWZ0ZXJUcmFuc2Zvcm0pXG4gICAgfVxuICB9XG5cbiAgX3JlYWQgKGNiKSB7XG4gICAgaWYgKHRoaXMuX3RyYW5zZm9ybVN0YXRlLmRhdGEgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5kYXRhXG4gICAgICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5kYXRhID0gbnVsbFxuICAgICAgY2IobnVsbClcbiAgICAgIHRoaXMuX3RyYW5zZm9ybShkYXRhLCB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5hZnRlclRyYW5zZm9ybSlcbiAgICB9IGVsc2Uge1xuICAgICAgY2IobnVsbClcbiAgICB9XG4gIH1cblxuICBkZXN0cm95IChlcnIpIHtcbiAgICBzdXBlci5kZXN0cm95KGVycilcbiAgICBpZiAodGhpcy5fdHJhbnNmb3JtU3RhdGUuZGF0YSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtU3RhdGUuZGF0YSA9IG51bGxcbiAgICAgIHRoaXMuX3RyYW5zZm9ybVN0YXRlLmFmdGVyVHJhbnNmb3JtKClcbiAgICB9XG4gIH1cblxuICBfdHJhbnNmb3JtIChkYXRhLCBjYikge1xuICAgIGNiKG51bGwsIGRhdGEpXG4gIH1cblxuICBfZmx1c2ggKGNiKSB7XG4gICAgY2IobnVsbClcbiAgfVxuXG4gIF9maW5hbCAoY2IpIHtcbiAgICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5hZnRlckZpbmFsID0gY2JcbiAgICB0aGlzLl9mbHVzaCh0cmFuc2Zvcm1BZnRlckZsdXNoLmJpbmQodGhpcykpXG4gIH1cbn1cblxuY2xhc3MgUGFzc1Rocm91Z2ggZXh0ZW5kcyBUcmFuc2Zvcm0ge31cblxuZnVuY3Rpb24gdHJhbnNmb3JtQWZ0ZXJGbHVzaCAoZXJyLCBkYXRhKSB7XG4gIGNvbnN0IGNiID0gdGhpcy5fdHJhbnNmb3JtU3RhdGUuYWZ0ZXJGaW5hbFxuICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHRoaXMucHVzaChkYXRhKVxuICB0aGlzLnB1c2gobnVsbClcbiAgY2IobnVsbClcbn1cblxuZnVuY3Rpb24gcGlwZWxpbmVQcm9taXNlICguLi5zdHJlYW1zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmV0dXJuIHBpcGVsaW5lKC4uLnN0cmVhbXMsIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgcmVzb2x2ZSgpXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gcGlwZWxpbmUgKHN0cmVhbSwgLi4uc3RyZWFtcykge1xuICBjb25zdCBhbGwgPSBBcnJheS5pc0FycmF5KHN0cmVhbSkgPyBbLi4uc3RyZWFtLCAuLi5zdHJlYW1zXSA6IFtzdHJlYW0sIC4uLnN0cmVhbXNdXG4gIGNvbnN0IGRvbmUgPSAoYWxsLmxlbmd0aCAmJiB0eXBlb2YgYWxsW2FsbC5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykgPyBhbGwucG9wKCkgOiBudWxsXG5cbiAgaWYgKGFsbC5sZW5ndGggPCAyKSB0aHJvdyBuZXcgRXJyb3IoJ1BpcGVsaW5lIHJlcXVpcmVzIGF0IGxlYXN0IDIgc3RyZWFtcycpXG5cbiAgbGV0IHNyYyA9IGFsbFswXVxuICBsZXQgZGVzdCA9IG51bGxcbiAgbGV0IGVycm9yID0gbnVsbFxuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVzdCA9IGFsbFtpXVxuXG4gICAgaWYgKGlzU3RyZWFteChzcmMpKSB7XG4gICAgICBzcmMucGlwZShkZXN0LCBvbmVycm9yKVxuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvckhhbmRsZShzcmMsIHRydWUsIGkgPiAxLCBvbmVycm9yKVxuICAgICAgc3JjLnBpcGUoZGVzdClcbiAgICB9XG5cbiAgICBzcmMgPSBkZXN0XG4gIH1cblxuICBpZiAoZG9uZSkge1xuICAgIGxldCBmaW4gPSBmYWxzZVxuXG4gICAgY29uc3QgYXV0b0Rlc3Ryb3kgPSBpc1N0cmVhbXgoZGVzdCkgfHwgISEoZGVzdC5fd3JpdGFibGVTdGF0ZSAmJiBkZXN0Ll93cml0YWJsZVN0YXRlLmF1dG9EZXN0cm95KVxuXG4gICAgZGVzdC5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyb3IgPT09IG51bGwpIGVycm9yID0gZXJyXG4gICAgfSlcblxuICAgIGRlc3Qub24oJ2ZpbmlzaCcsICgpID0+IHtcbiAgICAgIGZpbiA9IHRydWVcbiAgICAgIGlmICghYXV0b0Rlc3Ryb3kpIGRvbmUoZXJyb3IpXG4gICAgfSlcblxuICAgIGlmIChhdXRvRGVzdHJveSkge1xuICAgICAgZGVzdC5vbignY2xvc2UnLCAoKSA9PiBkb25lKGVycm9yIHx8IChmaW4gPyBudWxsIDogUFJFTUFUVVJFX0NMT1NFKSkpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlc3RcblxuICBmdW5jdGlvbiBlcnJvckhhbmRsZSAocywgcmQsIHdyLCBvbmVycm9yKSB7XG4gICAgcy5vbignZXJyb3InLCBvbmVycm9yKVxuICAgIHMub24oJ2Nsb3NlJywgb25jbG9zZSlcblxuICAgIGZ1bmN0aW9uIG9uY2xvc2UgKCkge1xuICAgICAgaWYgKHJkICYmIHMuX3JlYWRhYmxlU3RhdGUgJiYgIXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQpIHJldHVybiBvbmVycm9yKFBSRU1BVFVSRV9DTE9TRSlcbiAgICAgIGlmICh3ciAmJiBzLl93cml0YWJsZVN0YXRlICYmICFzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm4gb25lcnJvcihQUkVNQVRVUkVfQ0xPU0UpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lcnJvciAoZXJyKSB7XG4gICAgaWYgKCFlcnIgfHwgZXJyb3IpIHJldHVyblxuICAgIGVycm9yID0gZXJyXG5cbiAgICBmb3IgKGNvbnN0IHMgb2YgYWxsKSB7XG4gICAgICBzLmRlc3Ryb3koZXJyKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBlY2hvIChzKSB7XG4gIHJldHVybiBzXG59XG5cbmZ1bmN0aW9uIGlzU3RyZWFtIChzdHJlYW0pIHtcbiAgcmV0dXJuICEhc3RyZWFtLl9yZWFkYWJsZVN0YXRlIHx8ICEhc3RyZWFtLl93cml0YWJsZVN0YXRlXG59XG5cbmZ1bmN0aW9uIGlzU3RyZWFteCAoc3RyZWFtKSB7XG4gIHJldHVybiB0eXBlb2Ygc3RyZWFtLl9kdXBsZXhTdGF0ZSA9PT0gJ251bWJlcicgJiYgaXNTdHJlYW0oc3RyZWFtKVxufVxuXG5mdW5jdGlvbiBpc0VuZGVkIChzdHJlYW0pIHtcbiAgcmV0dXJuICEhc3RyZWFtLl9yZWFkYWJsZVN0YXRlICYmIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRlZFxufVxuXG5mdW5jdGlvbiBpc0ZpbmlzaGVkIChzdHJlYW0pIHtcbiAgcmV0dXJuICEhc3RyZWFtLl93cml0YWJsZVN0YXRlICYmIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lbmRlZFxufVxuXG5mdW5jdGlvbiBnZXRTdHJlYW1FcnJvciAoc3RyZWFtLCBvcHRzID0ge30pIHtcbiAgY29uc3QgZXJyID0gKHN0cmVhbS5fcmVhZGFibGVTdGF0ZSAmJiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZXJyb3IpIHx8IChzdHJlYW0uX3dyaXRhYmxlU3RhdGUgJiYgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yKVxuXG4gIC8vIGF2b2lkIGltcGxpY2l0IGVycm9ycyBieSBkZWZhdWx0XG4gIHJldHVybiAoIW9wdHMuYWxsICYmIGVyciA9PT0gU1RSRUFNX0RFU1RST1lFRCkgPyBudWxsIDogZXJyXG59XG5cbmZ1bmN0aW9uIGlzUmVhZFN0cmVhbXggKHN0cmVhbSkge1xuICByZXR1cm4gaXNTdHJlYW14KHN0cmVhbSkgJiYgc3RyZWFtLnJlYWRhYmxlXG59XG5cbmZ1bmN0aW9uIGlzRGlzdHVyYmVkIChzdHJlYW0pIHtcbiAgcmV0dXJuIChzdHJlYW0uX2R1cGxleFN0YXRlICYgT1BFTklORykgIT09IE9QRU5JTkcgfHwgKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBBQ1RJVkVfT1JfVElDS0lORykgIT09IDBcbn1cblxuZnVuY3Rpb24gaXNUeXBlZEFycmF5IChkYXRhKSB7XG4gIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgZGF0YSAhPT0gbnVsbCAmJiB0eXBlb2YgZGF0YS5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Qnl0ZUxlbmd0aCAoZGF0YSkge1xuICByZXR1cm4gaXNUeXBlZEFycmF5KGRhdGEpID8gZGF0YS5ieXRlTGVuZ3RoIDogMTAyNFxufVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbmZ1bmN0aW9uIGFib3J0ICgpIHtcbiAgdGhpcy5kZXN0cm95KG5ldyBFcnJvcignU3RyZWFtIGFib3J0ZWQuJykpXG59XG5cbmZ1bmN0aW9uIGlzV3JpdGV2IChzKSB7XG4gIHJldHVybiBzLl93cml0ZXYgIT09IFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ICYmIHMuX3dyaXRldiAhPT0gRHVwbGV4LnByb3RvdHlwZS5fd3JpdGV2XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwaXBlbGluZSxcbiAgcGlwZWxpbmVQcm9taXNlLFxuICBpc1N0cmVhbSxcbiAgaXNTdHJlYW14LFxuICBpc0VuZGVkLFxuICBpc0ZpbmlzaGVkLFxuICBpc0Rpc3R1cmJlZCxcbiAgZ2V0U3RyZWFtRXJyb3IsXG4gIFN0cmVhbSxcbiAgV3JpdGFibGUsXG4gIFJlYWRhYmxlLFxuICBEdXBsZXgsXG4gIFRyYW5zZm9ybSxcbiAgLy8gRXhwb3J0IFBhc3NUaHJvdWdoIGZvciBjb21wYXRpYmlsaXR5IHdpdGggTm9kZS5qcyBjb3JlJ3Mgc3RyZWFtIG1vZHVsZVxuICBQYXNzVGhyb3VnaFxufVxuIiwiY29uc3QgdGFyID0gcmVxdWlyZSgndGFyLXN0cmVhbScpXG5jb25zdCBwdW1wID0gcmVxdWlyZSgncHVtcCcpXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcblxuY29uc3Qgd2luMzIgPSAoZ2xvYmFsLkJhcmUgPyBnbG9iYWwuQmFyZS5wbGF0Zm9ybSA6IHByb2Nlc3MucGxhdGZvcm0pID09PSAnd2luMzInXG5cbmV4cG9ydHMucGFjayA9IGZ1bmN0aW9uIHBhY2sgKGN3ZCwgb3B0cykge1xuICBpZiAoIWN3ZCkgY3dkID0gJy4nXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgY29uc3QgeGZzID0gb3B0cy5mcyB8fCBmc1xuICBjb25zdCBpZ25vcmUgPSBvcHRzLmlnbm9yZSB8fCBvcHRzLmZpbHRlciB8fCBub29wXG4gIGNvbnN0IG1hcFN0cmVhbSA9IG9wdHMubWFwU3RyZWFtIHx8IGVjaG9cbiAgY29uc3Qgc3RhdE5leHQgPSBzdGF0QWxsKHhmcywgb3B0cy5kZXJlZmVyZW5jZSA/IHhmcy5zdGF0IDogeGZzLmxzdGF0LCBjd2QsIGlnbm9yZSwgb3B0cy5lbnRyaWVzLCBvcHRzLnNvcnQpXG4gIGNvbnN0IHN0cmljdCA9IG9wdHMuc3RyaWN0ICE9PSBmYWxzZVxuICBjb25zdCB1bWFzayA9IHR5cGVvZiBvcHRzLnVtYXNrID09PSAnbnVtYmVyJyA/IH5vcHRzLnVtYXNrIDogfnByb2Nlc3NVbWFzaygpXG4gIGNvbnN0IHBhY2sgPSBvcHRzLnBhY2sgfHwgdGFyLnBhY2soKVxuICBjb25zdCBmaW5pc2ggPSBvcHRzLmZpbmlzaCB8fCBub29wXG5cbiAgbGV0IG1hcCA9IG9wdHMubWFwIHx8IG5vb3BcbiAgbGV0IGRtb2RlID0gdHlwZW9mIG9wdHMuZG1vZGUgPT09ICdudW1iZXInID8gb3B0cy5kbW9kZSA6IDBcbiAgbGV0IGZtb2RlID0gdHlwZW9mIG9wdHMuZm1vZGUgPT09ICdudW1iZXInID8gb3B0cy5mbW9kZSA6IDBcblxuICBpZiAob3B0cy5zdHJpcCkgbWFwID0gc3RyaXAobWFwLCBvcHRzLnN0cmlwKVxuXG4gIGlmIChvcHRzLnJlYWRhYmxlKSB7XG4gICAgZG1vZGUgfD0gcGFyc2VJbnQoNTU1LCA4KVxuICAgIGZtb2RlIHw9IHBhcnNlSW50KDQ0NCwgOClcbiAgfVxuICBpZiAob3B0cy53cml0YWJsZSkge1xuICAgIGRtb2RlIHw9IHBhcnNlSW50KDMzMywgOClcbiAgICBmbW9kZSB8PSBwYXJzZUludCgyMjIsIDgpXG4gIH1cblxuICBvbm5leHRlbnRyeSgpXG5cbiAgZnVuY3Rpb24gb25zeW1saW5rIChmaWxlbmFtZSwgaGVhZGVyKSB7XG4gICAgeGZzLnJlYWRsaW5rKHBhdGguam9pbihjd2QsIGZpbGVuYW1lKSwgZnVuY3Rpb24gKGVyciwgbGlua25hbWUpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBwYWNrLmRlc3Ryb3koZXJyKVxuICAgICAgaGVhZGVyLmxpbmtuYW1lID0gbm9ybWFsaXplKGxpbmtuYW1lKVxuICAgICAgcGFjay5lbnRyeShoZWFkZXIsIG9ubmV4dGVudHJ5KVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBvbnN0YXQgKGVyciwgZmlsZW5hbWUsIHN0YXQpIHtcbiAgICBpZiAocGFjay5kZXN0cm95ZWQpIHJldHVyblxuICAgIGlmIChlcnIpIHJldHVybiBwYWNrLmRlc3Ryb3koZXJyKVxuICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgIGlmIChvcHRzLmZpbmFsaXplICE9PSBmYWxzZSkgcGFjay5maW5hbGl6ZSgpXG4gICAgICByZXR1cm4gZmluaXNoKHBhY2spXG4gICAgfVxuXG4gICAgaWYgKHN0YXQuaXNTb2NrZXQoKSkgcmV0dXJuIG9ubmV4dGVudHJ5KCkgLy8gdGFyIGRvZXMgbm90IHN1cHBvcnQgc29ja2V0cy4uLlxuXG4gICAgbGV0IGhlYWRlciA9IHtcbiAgICAgIG5hbWU6IG5vcm1hbGl6ZShmaWxlbmFtZSksXG4gICAgICBtb2RlOiAoc3RhdC5tb2RlIHwgKHN0YXQuaXNEaXJlY3RvcnkoKSA/IGRtb2RlIDogZm1vZGUpKSAmIHVtYXNrLFxuICAgICAgbXRpbWU6IHN0YXQubXRpbWUsXG4gICAgICBzaXplOiBzdGF0LnNpemUsXG4gICAgICB0eXBlOiAnZmlsZScsXG4gICAgICB1aWQ6IHN0YXQudWlkLFxuICAgICAgZ2lkOiBzdGF0LmdpZFxuICAgIH1cblxuICAgIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIGhlYWRlci5zaXplID0gMFxuICAgICAgaGVhZGVyLnR5cGUgPSAnZGlyZWN0b3J5J1xuICAgICAgaGVhZGVyID0gbWFwKGhlYWRlcikgfHwgaGVhZGVyXG4gICAgICByZXR1cm4gcGFjay5lbnRyeShoZWFkZXIsIG9ubmV4dGVudHJ5KVxuICAgIH1cblxuICAgIGlmIChzdGF0LmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgIGhlYWRlci5zaXplID0gMFxuICAgICAgaGVhZGVyLnR5cGUgPSAnc3ltbGluaydcbiAgICAgIGhlYWRlciA9IG1hcChoZWFkZXIpIHx8IGhlYWRlclxuICAgICAgcmV0dXJuIG9uc3ltbGluayhmaWxlbmFtZSwgaGVhZGVyKVxuICAgIH1cblxuICAgIC8vIFRPRE86IGFkZCBmaWZvIGV0Yy4uLlxuXG4gICAgaGVhZGVyID0gbWFwKGhlYWRlcikgfHwgaGVhZGVyXG5cbiAgICBpZiAoIXN0YXQuaXNGaWxlKCkpIHtcbiAgICAgIGlmIChzdHJpY3QpIHJldHVybiBwYWNrLmRlc3Ryb3kobmV3IEVycm9yKCd1bnN1cHBvcnRlZCB0eXBlIGZvciAnICsgZmlsZW5hbWUpKVxuICAgICAgcmV0dXJuIG9ubmV4dGVudHJ5KClcbiAgICB9XG5cbiAgICBjb25zdCBlbnRyeSA9IHBhY2suZW50cnkoaGVhZGVyLCBvbm5leHRlbnRyeSlcbiAgICBjb25zdCBycyA9IG1hcFN0cmVhbSh4ZnMuY3JlYXRlUmVhZFN0cmVhbShwYXRoLmpvaW4oY3dkLCBmaWxlbmFtZSksIHsgc3RhcnQ6IDAsIGVuZDogaGVhZGVyLnNpemUgPiAwID8gaGVhZGVyLnNpemUgLSAxIDogaGVhZGVyLnNpemUgfSksIGhlYWRlcilcblxuICAgIHJzLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHsgLy8gYWx3YXlzIGZvcndhcmQgZXJyb3JzIG9uIGRlc3Ryb3lcbiAgICAgIGVudHJ5LmRlc3Ryb3koZXJyKVxuICAgIH0pXG5cbiAgICBwdW1wKHJzLCBlbnRyeSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ubmV4dGVudHJ5IChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gcGFjay5kZXN0cm95KGVycilcbiAgICBzdGF0TmV4dChvbnN0YXQpXG4gIH1cblxuICByZXR1cm4gcGFja1xufVxuXG5mdW5jdGlvbiBoZWFkIChsaXN0KSB7XG4gIHJldHVybiBsaXN0Lmxlbmd0aCA/IGxpc3RbbGlzdC5sZW5ndGggLSAxXSA6IG51bGxcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0dldHVpZCAoKSB7XG4gIHJldHVybiAoIWdsb2JhbC5CYXJlICYmIHByb2Nlc3MuZ2V0dWlkKSA/IHByb2Nlc3MuZ2V0dWlkKCkgOiAtMVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzVW1hc2sgKCkge1xuICByZXR1cm4gKCFnbG9iYWwuQmFyZSAmJiBwcm9jZXNzLnVtYXNrKSA/IHByb2Nlc3MudW1hc2soKSA6IDBcbn1cblxuZXhwb3J0cy5leHRyYWN0ID0gZnVuY3Rpb24gZXh0cmFjdCAoY3dkLCBvcHRzKSB7XG4gIGlmICghY3dkKSBjd2QgPSAnLidcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICBjd2QgPSBwYXRoLnJlc29sdmUoY3dkKVxuXG4gIGNvbnN0IHhmcyA9IG9wdHMuZnMgfHwgZnNcbiAgY29uc3QgaWdub3JlID0gb3B0cy5pZ25vcmUgfHwgb3B0cy5maWx0ZXIgfHwgbm9vcFxuICBjb25zdCBtYXBTdHJlYW0gPSBvcHRzLm1hcFN0cmVhbSB8fCBlY2hvXG4gIGNvbnN0IG93biA9IG9wdHMuY2hvd24gIT09IGZhbHNlICYmICF3aW4zMiAmJiBwcm9jZXNzR2V0dWlkKCkgPT09IDBcbiAgY29uc3QgZXh0cmFjdCA9IG9wdHMuZXh0cmFjdCB8fCB0YXIuZXh0cmFjdCgpXG4gIGNvbnN0IHN0YWNrID0gW11cbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKVxuICBjb25zdCB1bWFzayA9IHR5cGVvZiBvcHRzLnVtYXNrID09PSAnbnVtYmVyJyA/IH5vcHRzLnVtYXNrIDogfnByb2Nlc3NVbWFzaygpXG4gIGNvbnN0IHN0cmljdCA9IG9wdHMuc3RyaWN0ICE9PSBmYWxzZVxuICBjb25zdCB2YWxpZGF0ZVN5bUxpbmtzID0gb3B0cy52YWxpZGF0ZVN5bWxpbmtzICE9PSBmYWxzZVxuXG4gIGxldCBtYXAgPSBvcHRzLm1hcCB8fCBub29wXG4gIGxldCBkbW9kZSA9IHR5cGVvZiBvcHRzLmRtb2RlID09PSAnbnVtYmVyJyA/IG9wdHMuZG1vZGUgOiAwXG4gIGxldCBmbW9kZSA9IHR5cGVvZiBvcHRzLmZtb2RlID09PSAnbnVtYmVyJyA/IG9wdHMuZm1vZGUgOiAwXG5cbiAgaWYgKG9wdHMuc3RyaXApIG1hcCA9IHN0cmlwKG1hcCwgb3B0cy5zdHJpcClcblxuICBpZiAob3B0cy5yZWFkYWJsZSkge1xuICAgIGRtb2RlIHw9IHBhcnNlSW50KDU1NSwgOClcbiAgICBmbW9kZSB8PSBwYXJzZUludCg0NDQsIDgpXG4gIH1cbiAgaWYgKG9wdHMud3JpdGFibGUpIHtcbiAgICBkbW9kZSB8PSBwYXJzZUludCgzMzMsIDgpXG4gICAgZm1vZGUgfD0gcGFyc2VJbnQoMjIyLCA4KVxuICB9XG5cbiAgZXh0cmFjdC5vbignZW50cnknLCBvbmVudHJ5KVxuXG4gIGlmIChvcHRzLmZpbmlzaCkgZXh0cmFjdC5vbignZmluaXNoJywgb3B0cy5maW5pc2gpXG5cbiAgcmV0dXJuIGV4dHJhY3RcblxuICBmdW5jdGlvbiBvbmVudHJ5IChoZWFkZXIsIHN0cmVhbSwgbmV4dCkge1xuICAgIGhlYWRlciA9IG1hcChoZWFkZXIpIHx8IGhlYWRlclxuICAgIGhlYWRlci5uYW1lID0gbm9ybWFsaXplKGhlYWRlci5uYW1lKVxuXG4gICAgY29uc3QgbmFtZSA9IHBhdGguam9pbihjd2QsIHBhdGguam9pbignLycsIGhlYWRlci5uYW1lKSlcblxuICAgIGlmIChpZ25vcmUobmFtZSwgaGVhZGVyKSkge1xuICAgICAgc3RyZWFtLnJlc3VtZSgpXG4gICAgICByZXR1cm4gbmV4dCgpXG4gICAgfVxuXG4gICAgY29uc3QgZGlyID0gcGF0aC5qb2luKG5hbWUsICcuJykgPT09IHBhdGguam9pbihjd2QsICcuJykgPyBjd2QgOiBwYXRoLmRpcm5hbWUobmFtZSlcblxuICAgIHZhbGlkYXRlKHhmcywgZGlyLCBwYXRoLmpvaW4oY3dkLCAnLicpLCBmdW5jdGlvbiAoZXJyLCB2YWxpZCkge1xuICAgICAgaWYgKGVycikgcmV0dXJuIG5leHQoZXJyKVxuICAgICAgaWYgKCF2YWxpZCkgcmV0dXJuIG5leHQobmV3IEVycm9yKGRpciArICcgaXMgbm90IGEgdmFsaWQgcGF0aCcpKVxuXG4gICAgICBpZiAoaGVhZGVyLnR5cGUgPT09ICdkaXJlY3RvcnknKSB7XG4gICAgICAgIHN0YWNrLnB1c2goW25hbWUsIGhlYWRlci5tdGltZV0pXG4gICAgICAgIHJldHVybiBta2RpcmZpeChuYW1lLCB7XG4gICAgICAgICAgZnM6IHhmcyxcbiAgICAgICAgICBvd24sXG4gICAgICAgICAgdWlkOiBoZWFkZXIudWlkLFxuICAgICAgICAgIGdpZDogaGVhZGVyLmdpZCxcbiAgICAgICAgICBtb2RlOiBoZWFkZXIubW9kZVxuICAgICAgICB9LCBzdGF0KVxuICAgICAgfVxuXG4gICAgICBta2RpcmZpeChkaXIsIHtcbiAgICAgICAgZnM6IHhmcyxcbiAgICAgICAgb3duLFxuICAgICAgICB1aWQ6IGhlYWRlci51aWQsXG4gICAgICAgIGdpZDogaGVhZGVyLmdpZCxcbiAgICAgICAgLy8gbm9ybWFsbHksIHRoZSBmb2xkZXJzIHdpdGggcmlnaHRzIGFuZCBvd25lciBzaG91bGQgYmUgcGFydCBvZiB0aGUgVEFSIGZpbGVcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBub3QgdGhlIGNhc2UsIGNyZWF0ZSBmb2xkZXIgZm9yIHNhbWUgdXNlciBhcyBmaWxlIGFuZCB3aXRoXG4gICAgICAgIC8vIHN0YW5kYXJkIHBlcm1pc3Npb25zIG9mIDBvNzU1IChyd3hyLXhyLXgpXG4gICAgICAgIG1vZGU6IDBvNzU1XG4gICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBuZXh0KGVycilcblxuICAgICAgICBzd2l0Y2ggKGhlYWRlci50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnZmlsZSc6IHJldHVybiBvbmZpbGUoKVxuICAgICAgICAgIGNhc2UgJ2xpbmsnOiByZXR1cm4gb25saW5rKClcbiAgICAgICAgICBjYXNlICdzeW1saW5rJzogcmV0dXJuIG9uc3ltbGluaygpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSByZXR1cm4gbmV4dChuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIHR5cGUgZm9yICcgKyBuYW1lICsgJyAoJyArIGhlYWRlci50eXBlICsgJyknKSlcblxuICAgICAgICBzdHJlYW0ucmVzdW1lKClcbiAgICAgICAgbmV4dCgpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBmdW5jdGlvbiBzdGF0IChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBuZXh0KGVycilcbiAgICAgIHV0aW1lcyhuYW1lLCBoZWFkZXIsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIG5leHQoZXJyKVxuICAgICAgICBpZiAod2luMzIpIHJldHVybiBuZXh0KClcbiAgICAgICAgY2hwZXJtKG5hbWUsIGhlYWRlciwgbmV4dClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25zeW1saW5rICgpIHtcbiAgICAgIGlmICh3aW4zMikgcmV0dXJuIG5leHQoKSAvLyBza2lwIHN5bWxpbmtzIG9uIHdpbiBmb3Igbm93IGJlZm9yZSBpdCBjYW4gYmUgdGVzdGVkXG4gICAgICB4ZnMudW5saW5rKG5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZHN0ID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShuYW1lKSwgaGVhZGVyLmxpbmtuYW1lKVxuICAgICAgICBpZiAoIWluQ3dkKGRzdCkgJiYgdmFsaWRhdGVTeW1MaW5rcykgcmV0dXJuIG5leHQobmV3IEVycm9yKG5hbWUgKyAnIGlzIG5vdCBhIHZhbGlkIHN5bWxpbmsnKSlcblxuICAgICAgICB4ZnMuc3ltbGluayhoZWFkZXIubGlua25hbWUsIG5hbWUsIHN0YXQpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9ubGluayAoKSB7XG4gICAgICBpZiAod2luMzIpIHJldHVybiBuZXh0KCkgLy8gc2tpcCBsaW5rcyBvbiB3aW4gZm9yIG5vdyBiZWZvcmUgaXQgY2FuIGJlIHRlc3RlZFxuICAgICAgeGZzLnVubGluayhuYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGxpbmsgPSBwYXRoLmpvaW4oY3dkLCBwYXRoLmpvaW4oJy8nLCBoZWFkZXIubGlua25hbWUpKVxuXG4gICAgICAgIGZzLnJlYWxwYXRoKGxpbmssIGZ1bmN0aW9uIChlcnIsIGRzdCkge1xuICAgICAgICAgIGlmIChlcnIgfHwgIWluQ3dkKGRzdCkpIHJldHVybiBuZXh0KG5ldyBFcnJvcihuYW1lICsgJyBpcyBub3QgYSB2YWxpZCBoYXJkbGluaycpKVxuXG4gICAgICAgICAgeGZzLmxpbmsoZHN0LCBuYW1lLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSAnRVBFUk0nICYmIG9wdHMuaGFyZGxpbmtBc0ZpbGVzRmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgc3RyZWFtID0geGZzLmNyZWF0ZVJlYWRTdHJlYW0oZHN0KVxuICAgICAgICAgICAgICByZXR1cm4gb25maWxlKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdChlcnIpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5Dd2QgKGRzdCkge1xuICAgICAgcmV0dXJuIGRzdCA9PT0gY3dkIHx8IGRzdC5zdGFydHNXaXRoKGN3ZCArIHBhdGguc2VwKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uZmlsZSAoKSB7XG4gICAgICBjb25zdCB3cyA9IHhmcy5jcmVhdGVXcml0ZVN0cmVhbShuYW1lKVxuICAgICAgY29uc3QgcnMgPSBtYXBTdHJlYW0oc3RyZWFtLCBoZWFkZXIpXG5cbiAgICAgIHdzLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHsgLy8gYWx3YXlzIGZvcndhcmQgZXJyb3JzIG9uIGRlc3Ryb3lcbiAgICAgICAgcnMuZGVzdHJveShlcnIpXG4gICAgICB9KVxuXG4gICAgICBwdW1wKHJzLCB3cywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gbmV4dChlcnIpXG4gICAgICAgIHdzLm9uKCdjbG9zZScsIHN0YXQpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHV0aW1lc1BhcmVudCAobmFtZSwgY2IpIHsgLy8gd2UganVzdCBzZXQgdGhlIG10aW1lIG9uIHRoZSBwYXJlbnQgZGlyIGFnYWluIGV2ZXJ5dGltZSB3ZSB3cml0ZSBhbiBlbnRyeVxuICAgIGxldCB0b3BcbiAgICB3aGlsZSAoKHRvcCA9IGhlYWQoc3RhY2spKSAmJiBuYW1lLnNsaWNlKDAsIHRvcFswXS5sZW5ndGgpICE9PSB0b3BbMF0pIHN0YWNrLnBvcCgpXG4gICAgaWYgKCF0b3ApIHJldHVybiBjYigpXG4gICAgeGZzLnV0aW1lcyh0b3BbMF0sIG5vdywgdG9wWzFdLCBjYilcbiAgfVxuXG4gIGZ1bmN0aW9uIHV0aW1lcyAobmFtZSwgaGVhZGVyLCBjYikge1xuICAgIGlmIChvcHRzLnV0aW1lcyA9PT0gZmFsc2UpIHJldHVybiBjYigpXG5cbiAgICBpZiAoaGVhZGVyLnR5cGUgPT09ICdkaXJlY3RvcnknKSByZXR1cm4geGZzLnV0aW1lcyhuYW1lLCBub3csIGhlYWRlci5tdGltZSwgY2IpXG4gICAgaWYgKGhlYWRlci50eXBlID09PSAnc3ltbGluaycpIHJldHVybiB1dGltZXNQYXJlbnQobmFtZSwgY2IpIC8vIFRPRE86IGhvdyB0byBzZXQgbXRpbWUgb24gbGluaz9cblxuICAgIHhmcy51dGltZXMobmFtZSwgbm93LCBoZWFkZXIubXRpbWUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICB1dGltZXNQYXJlbnQobmFtZSwgY2IpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNocGVybSAobmFtZSwgaGVhZGVyLCBjYikge1xuICAgIGNvbnN0IGxpbmsgPSBoZWFkZXIudHlwZSA9PT0gJ3N5bWxpbmsnXG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuL25vLWRlcHJlY2F0ZWQtYXBpICovXG4gICAgY29uc3QgY2htb2QgPSBsaW5rID8geGZzLmxjaG1vZCA6IHhmcy5jaG1vZFxuICAgIGNvbnN0IGNob3duID0gbGluayA/IHhmcy5sY2hvd24gOiB4ZnMuY2hvd25cbiAgICAvKiBlc2xpbnQtZW5hYmxlIG4vbm8tZGVwcmVjYXRlZC1hcGkgKi9cblxuICAgIGlmICghY2htb2QpIHJldHVybiBjYigpXG5cbiAgICBjb25zdCBtb2RlID0gKGhlYWRlci5tb2RlIHwgKGhlYWRlci50eXBlID09PSAnZGlyZWN0b3J5JyA/IGRtb2RlIDogZm1vZGUpKSAmIHVtYXNrXG5cbiAgICBpZiAoY2hvd24gJiYgb3duKSBjaG93bi5jYWxsKHhmcywgbmFtZSwgaGVhZGVyLnVpZCwgaGVhZGVyLmdpZCwgb25jaG93bilcbiAgICBlbHNlIG9uY2hvd24obnVsbClcblxuICAgIGZ1bmN0aW9uIG9uY2hvd24gKGVycikge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIGlmICghY2htb2QpIHJldHVybiBjYigpXG4gICAgICBjaG1vZC5jYWxsKHhmcywgbmFtZSwgbW9kZSwgY2IpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWtkaXJmaXggKG5hbWUsIG9wdHMsIGNiKSB7XG4gICAgLy8gd2hlbiBta2RpciBpcyBjYWxsZWQgb24gYW4gZXhpc3RpbmcgZGlyZWN0b3J5LCB0aGUgcGVybWlzc2lvbnNcbiAgICAvLyB3aWxsIGJlIG92ZXJ3cml0dGVuICg/KSwgdG8gYXZvaWQgdGhpcyB3ZSBjaGVjayBmb3IgaXRzIGV4aXN0YW5jZSBmaXJzdFxuICAgIHhmcy5zdGF0KG5hbWUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmICghZXJyKSByZXR1cm4gY2IobnVsbClcbiAgICAgIGlmIChlcnIuY29kZSAhPT0gJ0VOT0VOVCcpIHJldHVybiBjYihlcnIpXG4gICAgICB4ZnMubWtkaXIobmFtZSwgeyBtb2RlOiBvcHRzLm1vZGUsIHJlY3Vyc2l2ZTogdHJ1ZSB9LCBmdW5jdGlvbiAoZXJyLCBtYWRlKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICAgIGNocGVybShuYW1lLCBvcHRzLCBjYilcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZSAoZnMsIG5hbWUsIHJvb3QsIGNiKSB7XG4gIGlmIChuYW1lID09PSByb290KSByZXR1cm4gY2IobnVsbCwgdHJ1ZSlcblxuICBmcy5sc3RhdChuYW1lLCBmdW5jdGlvbiAoZXJyLCBzdCkge1xuICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgIT09ICdFTk9FTlQnICYmIGVyci5jb2RlICE9PSAnRVBFUk0nKSByZXR1cm4gY2IoZXJyKVxuICAgIGlmIChlcnIgfHwgc3QuaXNEaXJlY3RvcnkoKSkgcmV0dXJuIHZhbGlkYXRlKGZzLCBwYXRoLmpvaW4obmFtZSwgJy4uJyksIHJvb3QsIGNiKVxuICAgIGNiKG51bGwsIGZhbHNlKVxuICB9KVxufVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbmZ1bmN0aW9uIGVjaG8gKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWVcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplIChuYW1lKSB7XG4gIHJldHVybiB3aW4zMiA/IG5hbWUucmVwbGFjZSgvXFxcXC9nLCAnLycpLnJlcGxhY2UoL1s6Pzw+fF0vZywgJ18nKSA6IG5hbWVcbn1cblxuZnVuY3Rpb24gc3RhdEFsbCAoZnMsIHN0YXQsIGN3ZCwgaWdub3JlLCBlbnRyaWVzLCBzb3J0KSB7XG4gIGlmICghZW50cmllcykgZW50cmllcyA9IFsnLiddXG4gIGNvbnN0IHF1ZXVlID0gZW50cmllcy5zbGljZSgwKVxuXG4gIHJldHVybiBmdW5jdGlvbiBsb29wIChjYWxsYmFjaykge1xuICAgIGlmICghcXVldWUubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2sobnVsbClcblxuICAgIGNvbnN0IG5leHQgPSBxdWV1ZS5zaGlmdCgpXG4gICAgY29uc3QgbmV4dEFicyA9IHBhdGguam9pbihjd2QsIG5leHQpXG5cbiAgICBzdGF0LmNhbGwoZnMsIG5leHRBYnMsIGZ1bmN0aW9uIChlcnIsIHN0YXQpIHtcbiAgICAgIC8vIGlnbm9yZSBlcnJvcnMgaWYgdGhlIGZpbGVzIHdlcmUgZGVsZXRlZCB3aGlsZSBidWZmZXJpbmdcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlbnRyaWVzLmluZGV4T2YobmV4dCkgPT09IC0xICYmIGVyci5jb2RlID09PSAnRU5PRU5UJyA/IG51bGwgOiBlcnIpXG5cbiAgICAgIGlmICghc3RhdC5pc0RpcmVjdG9yeSgpKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgbmV4dCwgc3RhdClcblxuICAgICAgZnMucmVhZGRpcihuZXh0QWJzLCBmdW5jdGlvbiAoZXJyLCBmaWxlcykge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuXG4gICAgICAgIGlmIChzb3J0KSBmaWxlcy5zb3J0KClcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFpZ25vcmUocGF0aC5qb2luKGN3ZCwgbmV4dCwgZmlsZXNbaV0pKSkgcXVldWUucHVzaChwYXRoLmpvaW4obmV4dCwgZmlsZXNbaV0pKVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgbmV4dCwgc3RhdClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBzdHJpcCAobWFwLCBsZXZlbCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGhlYWRlcikge1xuICAgIGhlYWRlci5uYW1lID0gaGVhZGVyLm5hbWUuc3BsaXQoJy8nKS5zbGljZShsZXZlbCkuam9pbignLycpXG5cbiAgICBjb25zdCBsaW5rbmFtZSA9IGhlYWRlci5saW5rbmFtZVxuICAgIGlmIChsaW5rbmFtZSAmJiAoaGVhZGVyLnR5cGUgPT09ICdsaW5rJyB8fCBwYXRoLmlzQWJzb2x1dGUobGlua25hbWUpKSkge1xuICAgICAgaGVhZGVyLmxpbmtuYW1lID0gbGlua25hbWUuc3BsaXQoJy8nKS5zbGljZShsZXZlbCkuam9pbignLycpXG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcChoZWFkZXIpXG4gIH1cbn1cbiIsImNvbnN0IGNvbnN0YW50cyA9IHsgLy8ganVzdCBmb3IgZW52cyB3aXRob3V0IGZzXG4gIFNfSUZNVDogNjE0NDAsXG4gIFNfSUZESVI6IDE2Mzg0LFxuICBTX0lGQ0hSOiA4MTkyLFxuICBTX0lGQkxLOiAyNDU3NixcbiAgU19JRklGTzogNDA5NixcbiAgU19JRkxOSzogNDA5NjBcbn1cblxudHJ5IHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdmcycpLmNvbnN0YW50cyB8fCBjb25zdGFudHNcbn0gY2F0Y2gge1xuICBtb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50c1xufVxuIiwiY29uc3QgeyBXcml0YWJsZSwgUmVhZGFibGUsIGdldFN0cmVhbUVycm9yIH0gPSByZXF1aXJlKCdzdHJlYW14JylcbmNvbnN0IEZJRk8gPSByZXF1aXJlKCdmYXN0LWZpZm8nKVxuY29uc3QgYjRhID0gcmVxdWlyZSgnYjRhJylcbmNvbnN0IGhlYWRlcnMgPSByZXF1aXJlKCcuL2hlYWRlcnMnKVxuXG5jb25zdCBFTVBUWSA9IGI0YS5hbGxvYygwKVxuXG5jbGFzcyBCdWZmZXJMaXN0IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuYnVmZmVyZWQgPSAwXG4gICAgdGhpcy5zaGlmdGVkID0gMFxuICAgIHRoaXMucXVldWUgPSBuZXcgRklGTygpXG5cbiAgICB0aGlzLl9vZmZzZXQgPSAwXG4gIH1cblxuICBwdXNoIChidWZmZXIpIHtcbiAgICB0aGlzLmJ1ZmZlcmVkICs9IGJ1ZmZlci5ieXRlTGVuZ3RoXG4gICAgdGhpcy5xdWV1ZS5wdXNoKGJ1ZmZlcilcbiAgfVxuXG4gIHNoaWZ0Rmlyc3QgKHNpemUpIHtcbiAgICByZXR1cm4gdGhpcy5fYnVmZmVyZWQgPT09IDAgPyBudWxsIDogdGhpcy5fbmV4dChzaXplKVxuICB9XG5cbiAgc2hpZnQgKHNpemUpIHtcbiAgICBpZiAoc2l6ZSA+IHRoaXMuYnVmZmVyZWQpIHJldHVybiBudWxsXG4gICAgaWYgKHNpemUgPT09IDApIHJldHVybiBFTVBUWVxuXG4gICAgbGV0IGNodW5rID0gdGhpcy5fbmV4dChzaXplKVxuXG4gICAgaWYgKHNpemUgPT09IGNodW5rLmJ5dGVMZW5ndGgpIHJldHVybiBjaHVuayAvLyBsaWtlbHkgY2FzZVxuXG4gICAgY29uc3QgY2h1bmtzID0gW2NodW5rXVxuXG4gICAgd2hpbGUgKChzaXplIC09IGNodW5rLmJ5dGVMZW5ndGgpID4gMCkge1xuICAgICAgY2h1bmsgPSB0aGlzLl9uZXh0KHNpemUpXG4gICAgICBjaHVua3MucHVzaChjaHVuaylcbiAgICB9XG5cbiAgICByZXR1cm4gYjRhLmNvbmNhdChjaHVua3MpXG4gIH1cblxuICBfbmV4dCAoc2l6ZSkge1xuICAgIGNvbnN0IGJ1ZiA9IHRoaXMucXVldWUucGVlaygpXG4gICAgY29uc3QgcmVtID0gYnVmLmJ5dGVMZW5ndGggLSB0aGlzLl9vZmZzZXRcblxuICAgIGlmIChzaXplID49IHJlbSkge1xuICAgICAgY29uc3Qgc3ViID0gdGhpcy5fb2Zmc2V0ID8gYnVmLnN1YmFycmF5KHRoaXMuX29mZnNldCwgYnVmLmJ5dGVMZW5ndGgpIDogYnVmXG4gICAgICB0aGlzLnF1ZXVlLnNoaWZ0KClcbiAgICAgIHRoaXMuX29mZnNldCA9IDBcbiAgICAgIHRoaXMuYnVmZmVyZWQgLT0gcmVtXG4gICAgICB0aGlzLnNoaWZ0ZWQgKz0gcmVtXG4gICAgICByZXR1cm4gc3ViXG4gICAgfVxuXG4gICAgdGhpcy5idWZmZXJlZCAtPSBzaXplXG4gICAgdGhpcy5zaGlmdGVkICs9IHNpemVcblxuICAgIHJldHVybiBidWYuc3ViYXJyYXkodGhpcy5fb2Zmc2V0LCAodGhpcy5fb2Zmc2V0ICs9IHNpemUpKVxuICB9XG59XG5cbmNsYXNzIFNvdXJjZSBleHRlbmRzIFJlYWRhYmxlIHtcbiAgY29uc3RydWN0b3IgKHNlbGYsIGhlYWRlciwgb2Zmc2V0KSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5oZWFkZXIgPSBoZWFkZXJcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldFxuXG4gICAgdGhpcy5fcGFyZW50ID0gc2VsZlxuICB9XG5cbiAgX3JlYWQgKGNiKSB7XG4gICAgaWYgKHRoaXMuaGVhZGVyLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMucHVzaChudWxsKVxuICAgIH1cbiAgICBpZiAodGhpcy5fcGFyZW50Ll9zdHJlYW0gPT09IHRoaXMpIHtcbiAgICAgIHRoaXMuX3BhcmVudC5fdXBkYXRlKClcbiAgICB9XG4gICAgY2IobnVsbClcbiAgfVxuXG4gIF9wcmVkZXN0cm95ICgpIHtcbiAgICB0aGlzLl9wYXJlbnQuZGVzdHJveShnZXRTdHJlYW1FcnJvcih0aGlzKSlcbiAgfVxuXG4gIF9kZXRhY2ggKCkge1xuICAgIGlmICh0aGlzLl9wYXJlbnQuX3N0cmVhbSA9PT0gdGhpcykge1xuICAgICAgdGhpcy5fcGFyZW50Ll9zdHJlYW0gPSBudWxsXG4gICAgICB0aGlzLl9wYXJlbnQuX21pc3NpbmcgPSBvdmVyZmxvdyh0aGlzLmhlYWRlci5zaXplKVxuICAgICAgdGhpcy5fcGFyZW50Ll91cGRhdGUoKVxuICAgIH1cbiAgfVxuXG4gIF9kZXN0cm95IChjYikge1xuICAgIHRoaXMuX2RldGFjaCgpXG4gICAgY2IobnVsbClcbiAgfVxufVxuXG5jbGFzcyBFeHRyYWN0IGV4dGVuZHMgV3JpdGFibGUge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMpXG5cbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuXG4gICAgdGhpcy5fYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKVxuICAgIHRoaXMuX29mZnNldCA9IDBcbiAgICB0aGlzLl9oZWFkZXIgPSBudWxsXG4gICAgdGhpcy5fc3RyZWFtID0gbnVsbFxuICAgIHRoaXMuX21pc3NpbmcgPSAwXG4gICAgdGhpcy5fbG9uZ0hlYWRlciA9IGZhbHNlXG4gICAgdGhpcy5fY2FsbGJhY2sgPSBub29wXG4gICAgdGhpcy5fbG9ja2VkID0gZmFsc2VcbiAgICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlXG4gICAgdGhpcy5fcGF4ID0gbnVsbFxuICAgIHRoaXMuX3BheEdsb2JhbCA9IG51bGxcbiAgICB0aGlzLl9nbnVMb25nUGF0aCA9IG51bGxcbiAgICB0aGlzLl9nbnVMb25nTGlua1BhdGggPSBudWxsXG4gICAgdGhpcy5fZmlsZW5hbWVFbmNvZGluZyA9IG9wdHMuZmlsZW5hbWVFbmNvZGluZyB8fCAndXRmLTgnXG4gICAgdGhpcy5fYWxsb3dVbmtub3duRm9ybWF0ID0gISFvcHRzLmFsbG93VW5rbm93bkZvcm1hdFxuICAgIHRoaXMuX3VubG9ja0JvdW5kID0gdGhpcy5fdW5sb2NrLmJpbmQodGhpcylcbiAgfVxuXG4gIF91bmxvY2sgKGVycikge1xuICAgIHRoaXMuX2xvY2tlZCA9IGZhbHNlXG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koZXJyKVxuICAgICAgdGhpcy5fY29udGludWVXcml0ZShlcnIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGUoKVxuICB9XG5cbiAgX2NvbnN1bWVIZWFkZXIgKCkge1xuICAgIGlmICh0aGlzLl9sb2NrZWQpIHJldHVybiBmYWxzZVxuXG4gICAgdGhpcy5fb2Zmc2V0ID0gdGhpcy5fYnVmZmVyLnNoaWZ0ZWRcblxuICAgIHRyeSB7XG4gICAgICB0aGlzLl9oZWFkZXIgPSBoZWFkZXJzLmRlY29kZSh0aGlzLl9idWZmZXIuc2hpZnQoNTEyKSwgdGhpcy5fZmlsZW5hbWVFbmNvZGluZywgdGhpcy5fYWxsb3dVbmtub3duRm9ybWF0KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fY29udGludWVXcml0ZShlcnIpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2hlYWRlcikgcmV0dXJuIHRydWVcblxuICAgIHN3aXRjaCAodGhpcy5faGVhZGVyLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2dudS1sb25nLXBhdGgnOlxuICAgICAgY2FzZSAnZ251LWxvbmctbGluay1wYXRoJzpcbiAgICAgIGNhc2UgJ3BheC1nbG9iYWwtaGVhZGVyJzpcbiAgICAgIGNhc2UgJ3BheC1oZWFkZXInOlxuICAgICAgICB0aGlzLl9sb25nSGVhZGVyID0gdHJ1ZVxuICAgICAgICB0aGlzLl9taXNzaW5nID0gdGhpcy5faGVhZGVyLnNpemVcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICB0aGlzLl9sb2NrZWQgPSB0cnVlXG4gICAgdGhpcy5fYXBwbHlMb25nSGVhZGVycygpXG5cbiAgICBpZiAodGhpcy5faGVhZGVyLnNpemUgPT09IDAgfHwgdGhpcy5faGVhZGVyLnR5cGUgPT09ICdkaXJlY3RvcnknKSB7XG4gICAgICB0aGlzLmVtaXQoJ2VudHJ5JywgdGhpcy5faGVhZGVyLCB0aGlzLl9jcmVhdGVTdHJlYW0oKSwgdGhpcy5fdW5sb2NrQm91bmQpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHRoaXMuX3N0cmVhbSA9IHRoaXMuX2NyZWF0ZVN0cmVhbSgpXG4gICAgdGhpcy5fbWlzc2luZyA9IHRoaXMuX2hlYWRlci5zaXplXG5cbiAgICB0aGlzLmVtaXQoJ2VudHJ5JywgdGhpcy5faGVhZGVyLCB0aGlzLl9zdHJlYW0sIHRoaXMuX3VubG9ja0JvdW5kKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBfYXBwbHlMb25nSGVhZGVycyAoKSB7XG4gICAgaWYgKHRoaXMuX2dudUxvbmdQYXRoKSB7XG4gICAgICB0aGlzLl9oZWFkZXIubmFtZSA9IHRoaXMuX2dudUxvbmdQYXRoXG4gICAgICB0aGlzLl9nbnVMb25nUGF0aCA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZ251TG9uZ0xpbmtQYXRoKSB7XG4gICAgICB0aGlzLl9oZWFkZXIubGlua25hbWUgPSB0aGlzLl9nbnVMb25nTGlua1BhdGhcbiAgICAgIHRoaXMuX2dudUxvbmdMaW5rUGF0aCA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGF4KSB7XG4gICAgICBpZiAodGhpcy5fcGF4LnBhdGgpIHRoaXMuX2hlYWRlci5uYW1lID0gdGhpcy5fcGF4LnBhdGhcbiAgICAgIGlmICh0aGlzLl9wYXgubGlua3BhdGgpIHRoaXMuX2hlYWRlci5saW5rbmFtZSA9IHRoaXMuX3BheC5saW5rcGF0aFxuICAgICAgaWYgKHRoaXMuX3BheC5zaXplKSB0aGlzLl9oZWFkZXIuc2l6ZSA9IHBhcnNlSW50KHRoaXMuX3BheC5zaXplLCAxMClcbiAgICAgIHRoaXMuX2hlYWRlci5wYXggPSB0aGlzLl9wYXhcbiAgICAgIHRoaXMuX3BheCA9IG51bGxcbiAgICB9XG4gIH1cblxuICBfZGVjb2RlTG9uZ0hlYWRlciAoYnVmKSB7XG4gICAgc3dpdGNoICh0aGlzLl9oZWFkZXIudHlwZSkge1xuICAgICAgY2FzZSAnZ251LWxvbmctcGF0aCc6XG4gICAgICAgIHRoaXMuX2dudUxvbmdQYXRoID0gaGVhZGVycy5kZWNvZGVMb25nUGF0aChidWYsIHRoaXMuX2ZpbGVuYW1lRW5jb2RpbmcpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdnbnUtbG9uZy1saW5rLXBhdGgnOlxuICAgICAgICB0aGlzLl9nbnVMb25nTGlua1BhdGggPSBoZWFkZXJzLmRlY29kZUxvbmdQYXRoKGJ1ZiwgdGhpcy5fZmlsZW5hbWVFbmNvZGluZylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3BheC1nbG9iYWwtaGVhZGVyJzpcbiAgICAgICAgdGhpcy5fcGF4R2xvYmFsID0gaGVhZGVycy5kZWNvZGVQYXgoYnVmKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncGF4LWhlYWRlcic6XG4gICAgICAgIHRoaXMuX3BheCA9IHRoaXMuX3BheEdsb2JhbCA9PT0gbnVsbFxuICAgICAgICAgID8gaGVhZGVycy5kZWNvZGVQYXgoYnVmKVxuICAgICAgICAgIDogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fcGF4R2xvYmFsLCBoZWFkZXJzLmRlY29kZVBheChidWYpKVxuICAgICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIF9jb25zdW1lTG9uZ0hlYWRlciAoKSB7XG4gICAgdGhpcy5fbG9uZ0hlYWRlciA9IGZhbHNlXG4gICAgdGhpcy5fbWlzc2luZyA9IG92ZXJmbG93KHRoaXMuX2hlYWRlci5zaXplKVxuXG4gICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyLnNoaWZ0KHRoaXMuX2hlYWRlci5zaXplKVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2RlY29kZUxvbmdIZWFkZXIoYnVmKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fY29udGludWVXcml0ZShlcnIpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgX2NvbnN1bWVTdHJlYW0gKCkge1xuICAgIGNvbnN0IGJ1ZiA9IHRoaXMuX2J1ZmZlci5zaGlmdEZpcnN0KHRoaXMuX21pc3NpbmcpXG4gICAgaWYgKGJ1ZiA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlXG5cbiAgICB0aGlzLl9taXNzaW5nIC09IGJ1Zi5ieXRlTGVuZ3RoXG4gICAgY29uc3QgZHJhaW5lZCA9IHRoaXMuX3N0cmVhbS5wdXNoKGJ1ZilcblxuICAgIGlmICh0aGlzLl9taXNzaW5nID09PSAwKSB7XG4gICAgICB0aGlzLl9zdHJlYW0ucHVzaChudWxsKVxuICAgICAgaWYgKGRyYWluZWQpIHRoaXMuX3N0cmVhbS5fZGV0YWNoKClcbiAgICAgIHJldHVybiBkcmFpbmVkICYmIHRoaXMuX2xvY2tlZCA9PT0gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gZHJhaW5lZFxuICB9XG5cbiAgX2NyZWF0ZVN0cmVhbSAoKSB7XG4gICAgcmV0dXJuIG5ldyBTb3VyY2UodGhpcywgdGhpcy5faGVhZGVyLCB0aGlzLl9vZmZzZXQpXG4gIH1cblxuICBfdXBkYXRlICgpIHtcbiAgICB3aGlsZSAodGhpcy5fYnVmZmVyLmJ1ZmZlcmVkID4gMCAmJiAhdGhpcy5kZXN0cm95aW5nKSB7XG4gICAgICBpZiAodGhpcy5fbWlzc2luZyA+IDApIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0cmVhbSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0aGlzLl9jb25zdW1lU3RyZWFtKCkgPT09IGZhbHNlKSByZXR1cm5cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2xvbmdIZWFkZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAodGhpcy5fbWlzc2luZyA+IHRoaXMuX2J1ZmZlci5idWZmZXJlZCkgYnJlYWtcbiAgICAgICAgICBpZiAodGhpcy5fY29uc3VtZUxvbmdIZWFkZXIoKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpZ25vcmUgPSB0aGlzLl9idWZmZXIuc2hpZnRGaXJzdCh0aGlzLl9taXNzaW5nKVxuICAgICAgICBpZiAoaWdub3JlICE9PSBudWxsKSB0aGlzLl9taXNzaW5nIC09IGlnbm9yZS5ieXRlTGVuZ3RoXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9idWZmZXIuYnVmZmVyZWQgPCA1MTIpIGJyZWFrXG4gICAgICBpZiAodGhpcy5fc3RyZWFtICE9PSBudWxsIHx8IHRoaXMuX2NvbnN1bWVIZWFkZXIoKSA9PT0gZmFsc2UpIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2NvbnRpbnVlV3JpdGUobnVsbClcbiAgfVxuXG4gIF9jb250aW51ZVdyaXRlIChlcnIpIHtcbiAgICBjb25zdCBjYiA9IHRoaXMuX2NhbGxiYWNrXG4gICAgdGhpcy5fY2FsbGJhY2sgPSBub29wXG4gICAgY2IoZXJyKVxuICB9XG5cbiAgX3dyaXRlIChkYXRhLCBjYikge1xuICAgIHRoaXMuX2NhbGxiYWNrID0gY2JcbiAgICB0aGlzLl9idWZmZXIucHVzaChkYXRhKVxuICAgIHRoaXMuX3VwZGF0ZSgpXG4gIH1cblxuICBfZmluYWwgKGNiKSB7XG4gICAgdGhpcy5fZmluaXNoZWQgPSB0aGlzLl9taXNzaW5nID09PSAwICYmIHRoaXMuX2J1ZmZlci5idWZmZXJlZCA9PT0gMFxuICAgIGNiKHRoaXMuX2ZpbmlzaGVkID8gbnVsbCA6IG5ldyBFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgZGF0YScpKVxuICB9XG5cbiAgX3ByZWRlc3Ryb3kgKCkge1xuICAgIHRoaXMuX2NvbnRpbnVlV3JpdGUobnVsbClcbiAgfVxuXG4gIF9kZXN0cm95IChjYikge1xuICAgIGlmICh0aGlzLl9zdHJlYW0pIHRoaXMuX3N0cmVhbS5kZXN0cm95KGdldFN0cmVhbUVycm9yKHRoaXMpKVxuICAgIGNiKG51bGwpXG4gIH1cblxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdICgpIHtcbiAgICBsZXQgZXJyb3IgPSBudWxsXG5cbiAgICBsZXQgcHJvbWlzZVJlc29sdmUgPSBudWxsXG4gICAgbGV0IHByb21pc2VSZWplY3QgPSBudWxsXG5cbiAgICBsZXQgZW50cnlTdHJlYW0gPSBudWxsXG4gICAgbGV0IGVudHJ5Q2FsbGJhY2sgPSBudWxsXG5cbiAgICBjb25zdCBleHRyYWN0ID0gdGhpc1xuXG4gICAgdGhpcy5vbignZW50cnknLCBvbmVudHJ5KVxuICAgIHRoaXMub24oJ2Vycm9yJywgKGVycikgPT4geyBlcnJvciA9IGVyciB9KVxuICAgIHRoaXMub24oJ2Nsb3NlJywgb25jbG9zZSlcblxuICAgIHJldHVybiB7XG4gICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH0sXG4gICAgICBuZXh0ICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKG9ubmV4dClcbiAgICAgIH0sXG4gICAgICByZXR1cm4gKCkge1xuICAgICAgICByZXR1cm4gZGVzdHJveShudWxsKVxuICAgICAgfSxcbiAgICAgIHRocm93IChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGRlc3Ryb3koZXJyKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnN1bWVDYWxsYmFjayAoZXJyKSB7XG4gICAgICBpZiAoIWVudHJ5Q2FsbGJhY2spIHJldHVyblxuICAgICAgY29uc3QgY2IgPSBlbnRyeUNhbGxiYWNrXG4gICAgICBlbnRyeUNhbGxiYWNrID0gbnVsbFxuICAgICAgY2IoZXJyKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9ubmV4dCAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcilcbiAgICAgIH1cblxuICAgICAgaWYgKGVudHJ5U3RyZWFtKSB7XG4gICAgICAgIHJlc29sdmUoeyB2YWx1ZTogZW50cnlTdHJlYW0sIGRvbmU6IGZhbHNlIH0pXG4gICAgICAgIGVudHJ5U3RyZWFtID0gbnVsbFxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgcHJvbWlzZVJlc29sdmUgPSByZXNvbHZlXG4gICAgICBwcm9taXNlUmVqZWN0ID0gcmVqZWN0XG5cbiAgICAgIGNvbnN1bWVDYWxsYmFjayhudWxsKVxuXG4gICAgICBpZiAoZXh0cmFjdC5fZmluaXNoZWQgJiYgcHJvbWlzZVJlc29sdmUpIHtcbiAgICAgICAgcHJvbWlzZVJlc29sdmUoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pXG4gICAgICAgIHByb21pc2VSZXNvbHZlID0gcHJvbWlzZVJlamVjdCA9IG51bGxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbmVudHJ5IChoZWFkZXIsIHN0cmVhbSwgY2FsbGJhY2spIHtcbiAgICAgIGVudHJ5Q2FsbGJhY2sgPSBjYWxsYmFja1xuICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIG5vb3ApIC8vIG5vIHdheSBhcm91bmQgdGhpcyBkdWUgdG8gdGljayBzaWxseW5lc3NcblxuICAgICAgaWYgKHByb21pc2VSZXNvbHZlKSB7XG4gICAgICAgIHByb21pc2VSZXNvbHZlKHsgdmFsdWU6IHN0cmVhbSwgZG9uZTogZmFsc2UgfSlcbiAgICAgICAgcHJvbWlzZVJlc29sdmUgPSBwcm9taXNlUmVqZWN0ID0gbnVsbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW50cnlTdHJlYW0gPSBzdHJlYW1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbmNsb3NlICgpIHtcbiAgICAgIGNvbnN1bWVDYWxsYmFjayhlcnJvcilcbiAgICAgIGlmICghcHJvbWlzZVJlc29sdmUpIHJldHVyblxuICAgICAgaWYgKGVycm9yKSBwcm9taXNlUmVqZWN0KGVycm9yKVxuICAgICAgZWxzZSBwcm9taXNlUmVzb2x2ZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSlcbiAgICAgIHByb21pc2VSZXNvbHZlID0gcHJvbWlzZVJlamVjdCA9IG51bGxcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXN0cm95IChlcnIpIHtcbiAgICAgIGV4dHJhY3QuZGVzdHJveShlcnIpXG4gICAgICBjb25zdW1lQ2FsbGJhY2soZXJyKVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYgKGV4dHJhY3QuZGVzdHJveWVkKSByZXR1cm4gcmVzb2x2ZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSlcbiAgICAgICAgZXh0cmFjdC5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZXJyKSByZWplY3QoZXJyKVxuICAgICAgICAgIGVsc2UgcmVzb2x2ZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXh0cmFjdCAob3B0cykge1xuICByZXR1cm4gbmV3IEV4dHJhY3Qob3B0cylcbn1cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5mdW5jdGlvbiBvdmVyZmxvdyAoc2l6ZSkge1xuICBzaXplICY9IDUxMVxuICByZXR1cm4gc2l6ZSAmJiA1MTIgLSBzaXplXG59XG4iLCJjb25zdCBiNGEgPSByZXF1aXJlKCdiNGEnKVxuXG5jb25zdCBaRVJPUyA9ICcwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuY29uc3QgU0VWRU5TID0gJzc3Nzc3Nzc3Nzc3Nzc3Nzc3NzcnXG5jb25zdCBaRVJPX09GRlNFVCA9ICcwJy5jaGFyQ29kZUF0KDApXG5jb25zdCBVU1RBUl9NQUdJQyA9IGI0YS5mcm9tKFsweDc1LCAweDczLCAweDc0LCAweDYxLCAweDcyLCAweDAwXSkgLy8gdXN0YXJcXHgwMFxuY29uc3QgVVNUQVJfVkVSID0gYjRhLmZyb20oW1pFUk9fT0ZGU0VULCBaRVJPX09GRlNFVF0pXG5jb25zdCBHTlVfTUFHSUMgPSBiNGEuZnJvbShbMHg3NSwgMHg3MywgMHg3NCwgMHg2MSwgMHg3MiwgMHgyMF0pIC8vIHVzdGFyXFx4MjBcbmNvbnN0IEdOVV9WRVIgPSBiNGEuZnJvbShbMHgyMCwgMHgwMF0pXG5jb25zdCBNQVNLID0gMG83Nzc3XG5jb25zdCBNQUdJQ19PRkZTRVQgPSAyNTdcbmNvbnN0IFZFUlNJT05fT0ZGU0VUID0gMjYzXG5cbmV4cG9ydHMuZGVjb2RlTG9uZ1BhdGggPSBmdW5jdGlvbiBkZWNvZGVMb25nUGF0aCAoYnVmLCBlbmNvZGluZykge1xuICByZXR1cm4gZGVjb2RlU3RyKGJ1ZiwgMCwgYnVmLmxlbmd0aCwgZW5jb2RpbmcpXG59XG5cbmV4cG9ydHMuZW5jb2RlUGF4ID0gZnVuY3Rpb24gZW5jb2RlUGF4IChvcHRzKSB7IC8vIFRPRE86IGVuY29kZSBtb3JlIHN0dWZmIGluIHBheFxuICBsZXQgcmVzdWx0ID0gJydcbiAgaWYgKG9wdHMubmFtZSkgcmVzdWx0ICs9IGFkZExlbmd0aCgnIHBhdGg9JyArIG9wdHMubmFtZSArICdcXG4nKVxuICBpZiAob3B0cy5saW5rbmFtZSkgcmVzdWx0ICs9IGFkZExlbmd0aCgnIGxpbmtwYXRoPScgKyBvcHRzLmxpbmtuYW1lICsgJ1xcbicpXG4gIGNvbnN0IHBheCA9IG9wdHMucGF4XG4gIGlmIChwYXgpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXgpIHtcbiAgICAgIHJlc3VsdCArPSBhZGRMZW5ndGgoJyAnICsga2V5ICsgJz0nICsgcGF4W2tleV0gKyAnXFxuJylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGI0YS5mcm9tKHJlc3VsdClcbn1cblxuZXhwb3J0cy5kZWNvZGVQYXggPSBmdW5jdGlvbiBkZWNvZGVQYXggKGJ1Zikge1xuICBjb25zdCByZXN1bHQgPSB7fVxuXG4gIHdoaWxlIChidWYubGVuZ3RoKSB7XG4gICAgbGV0IGkgPSAwXG4gICAgd2hpbGUgKGkgPCBidWYubGVuZ3RoICYmIGJ1ZltpXSAhPT0gMzIpIGkrK1xuICAgIGNvbnN0IGxlbiA9IHBhcnNlSW50KGI0YS50b1N0cmluZyhidWYuc3ViYXJyYXkoMCwgaSkpLCAxMClcbiAgICBpZiAoIWxlbikgcmV0dXJuIHJlc3VsdFxuXG4gICAgY29uc3QgYiA9IGI0YS50b1N0cmluZyhidWYuc3ViYXJyYXkoaSArIDEsIGxlbiAtIDEpKVxuICAgIGNvbnN0IGtleUluZGV4ID0gYi5pbmRleE9mKCc9JylcbiAgICBpZiAoa2V5SW5kZXggPT09IC0xKSByZXR1cm4gcmVzdWx0XG4gICAgcmVzdWx0W2Iuc2xpY2UoMCwga2V5SW5kZXgpXSA9IGIuc2xpY2Uoa2V5SW5kZXggKyAxKVxuXG4gICAgYnVmID0gYnVmLnN1YmFycmF5KGxlbilcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUgKG9wdHMpIHtcbiAgY29uc3QgYnVmID0gYjRhLmFsbG9jKDUxMilcbiAgbGV0IG5hbWUgPSBvcHRzLm5hbWVcbiAgbGV0IHByZWZpeCA9ICcnXG5cbiAgaWYgKG9wdHMudHlwZWZsYWcgPT09IDUgJiYgbmFtZVtuYW1lLmxlbmd0aCAtIDFdICE9PSAnLycpIG5hbWUgKz0gJy8nXG4gIGlmIChiNGEuYnl0ZUxlbmd0aChuYW1lKSAhPT0gbmFtZS5sZW5ndGgpIHJldHVybiBudWxsIC8vIHV0Zi04XG5cbiAgd2hpbGUgKGI0YS5ieXRlTGVuZ3RoKG5hbWUpID4gMTAwKSB7XG4gICAgY29uc3QgaSA9IG5hbWUuaW5kZXhPZignLycpXG4gICAgaWYgKGkgPT09IC0xKSByZXR1cm4gbnVsbFxuICAgIHByZWZpeCArPSBwcmVmaXggPyAnLycgKyBuYW1lLnNsaWNlKDAsIGkpIDogbmFtZS5zbGljZSgwLCBpKVxuICAgIG5hbWUgPSBuYW1lLnNsaWNlKGkgKyAxKVxuICB9XG5cbiAgaWYgKGI0YS5ieXRlTGVuZ3RoKG5hbWUpID4gMTAwIHx8IGI0YS5ieXRlTGVuZ3RoKHByZWZpeCkgPiAxNTUpIHJldHVybiBudWxsXG4gIGlmIChvcHRzLmxpbmtuYW1lICYmIGI0YS5ieXRlTGVuZ3RoKG9wdHMubGlua25hbWUpID4gMTAwKSByZXR1cm4gbnVsbFxuXG4gIGI0YS53cml0ZShidWYsIG5hbWUpXG4gIGI0YS53cml0ZShidWYsIGVuY29kZU9jdChvcHRzLm1vZGUgJiBNQVNLLCA2KSwgMTAwKVxuICBiNGEud3JpdGUoYnVmLCBlbmNvZGVPY3Qob3B0cy51aWQsIDYpLCAxMDgpXG4gIGI0YS53cml0ZShidWYsIGVuY29kZU9jdChvcHRzLmdpZCwgNiksIDExNilcbiAgZW5jb2RlU2l6ZShvcHRzLnNpemUsIGJ1ZiwgMTI0KVxuICBiNGEud3JpdGUoYnVmLCBlbmNvZGVPY3QoKG9wdHMubXRpbWUuZ2V0VGltZSgpIC8gMTAwMCkgfCAwLCAxMSksIDEzNilcblxuICBidWZbMTU2XSA9IFpFUk9fT0ZGU0VUICsgdG9UeXBlZmxhZyhvcHRzLnR5cGUpXG5cbiAgaWYgKG9wdHMubGlua25hbWUpIGI0YS53cml0ZShidWYsIG9wdHMubGlua25hbWUsIDE1NylcblxuICBiNGEuY29weShVU1RBUl9NQUdJQywgYnVmLCBNQUdJQ19PRkZTRVQpXG4gIGI0YS5jb3B5KFVTVEFSX1ZFUiwgYnVmLCBWRVJTSU9OX09GRlNFVClcbiAgaWYgKG9wdHMudW5hbWUpIGI0YS53cml0ZShidWYsIG9wdHMudW5hbWUsIDI2NSlcbiAgaWYgKG9wdHMuZ25hbWUpIGI0YS53cml0ZShidWYsIG9wdHMuZ25hbWUsIDI5NylcbiAgYjRhLndyaXRlKGJ1ZiwgZW5jb2RlT2N0KG9wdHMuZGV2bWFqb3IgfHwgMCwgNiksIDMyOSlcbiAgYjRhLndyaXRlKGJ1ZiwgZW5jb2RlT2N0KG9wdHMuZGV2bWlub3IgfHwgMCwgNiksIDMzNylcblxuICBpZiAocHJlZml4KSBiNGEud3JpdGUoYnVmLCBwcmVmaXgsIDM0NSlcblxuICBiNGEud3JpdGUoYnVmLCBlbmNvZGVPY3QoY2tzdW0oYnVmKSwgNiksIDE0OClcblxuICByZXR1cm4gYnVmXG59XG5cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlIChidWYsIGZpbGVuYW1lRW5jb2RpbmcsIGFsbG93VW5rbm93bkZvcm1hdCkge1xuICBsZXQgdHlwZWZsYWcgPSBidWZbMTU2XSA9PT0gMCA/IDAgOiBidWZbMTU2XSAtIFpFUk9fT0ZGU0VUXG5cbiAgbGV0IG5hbWUgPSBkZWNvZGVTdHIoYnVmLCAwLCAxMDAsIGZpbGVuYW1lRW5jb2RpbmcpXG4gIGNvbnN0IG1vZGUgPSBkZWNvZGVPY3QoYnVmLCAxMDAsIDgpXG4gIGNvbnN0IHVpZCA9IGRlY29kZU9jdChidWYsIDEwOCwgOClcbiAgY29uc3QgZ2lkID0gZGVjb2RlT2N0KGJ1ZiwgMTE2LCA4KVxuICBjb25zdCBzaXplID0gZGVjb2RlT2N0KGJ1ZiwgMTI0LCAxMilcbiAgY29uc3QgbXRpbWUgPSBkZWNvZGVPY3QoYnVmLCAxMzYsIDEyKVxuICBjb25zdCB0eXBlID0gdG9UeXBlKHR5cGVmbGFnKVxuICBjb25zdCBsaW5rbmFtZSA9IGJ1ZlsxNTddID09PSAwID8gbnVsbCA6IGRlY29kZVN0cihidWYsIDE1NywgMTAwLCBmaWxlbmFtZUVuY29kaW5nKVxuICBjb25zdCB1bmFtZSA9IGRlY29kZVN0cihidWYsIDI2NSwgMzIpXG4gIGNvbnN0IGduYW1lID0gZGVjb2RlU3RyKGJ1ZiwgMjk3LCAzMilcbiAgY29uc3QgZGV2bWFqb3IgPSBkZWNvZGVPY3QoYnVmLCAzMjksIDgpXG4gIGNvbnN0IGRldm1pbm9yID0gZGVjb2RlT2N0KGJ1ZiwgMzM3LCA4KVxuXG4gIGNvbnN0IGMgPSBja3N1bShidWYpXG5cbiAgLy8gY2hlY2tzdW0gaXMgc3RpbGwgaW5pdGlhbCB2YWx1ZSBpZiBoZWFkZXIgd2FzIG51bGwuXG4gIGlmIChjID09PSA4ICogMzIpIHJldHVybiBudWxsXG5cbiAgLy8gdmFsaWQgY2hlY2tzdW1cbiAgaWYgKGMgIT09IGRlY29kZU9jdChidWYsIDE0OCwgOCkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YXIgaGVhZGVyLiBNYXliZSB0aGUgdGFyIGlzIGNvcnJ1cHRlZCBvciBpdCBuZWVkcyB0byBiZSBndW56aXBwZWQ/JylcblxuICBpZiAoaXNVU1RBUihidWYpKSB7XG4gICAgLy8gdXN0YXIgKHBvc2l4KSBmb3JtYXQuXG4gICAgLy8gcHJlcGVuZCBwcmVmaXgsIGlmIHByZXNlbnQuXG4gICAgaWYgKGJ1ZlszNDVdKSBuYW1lID0gZGVjb2RlU3RyKGJ1ZiwgMzQ1LCAxNTUsIGZpbGVuYW1lRW5jb2RpbmcpICsgJy8nICsgbmFtZVxuICB9IGVsc2UgaWYgKGlzR05VKGJ1ZikpIHtcbiAgICAvLyAnZ251Jy8nb2xkZ251JyBmb3JtYXQuIFNpbWlsYXIgdG8gdXN0YXIsIGJ1dCBoYXMgc3VwcG9ydCBmb3IgaW5jcmVtZW50YWwgYW5kXG4gICAgLy8gbXVsdGktdm9sdW1lIHRhcmJhbGxzLlxuICB9IGVsc2Uge1xuICAgIGlmICghYWxsb3dVbmtub3duRm9ybWF0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGFyIGhlYWRlcjogdW5rbm93biBmb3JtYXQuJylcbiAgICB9XG4gIH1cblxuICAvLyB0byBzdXBwb3J0IG9sZCB0YXIgdmVyc2lvbnMgdGhhdCB1c2UgdHJhaWxpbmcgLyB0byBpbmRpY2F0ZSBkaXJzXG4gIGlmICh0eXBlZmxhZyA9PT0gMCAmJiBuYW1lICYmIG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJy8nKSB0eXBlZmxhZyA9IDVcblxuICByZXR1cm4ge1xuICAgIG5hbWUsXG4gICAgbW9kZSxcbiAgICB1aWQsXG4gICAgZ2lkLFxuICAgIHNpemUsXG4gICAgbXRpbWU6IG5ldyBEYXRlKDEwMDAgKiBtdGltZSksXG4gICAgdHlwZSxcbiAgICBsaW5rbmFtZSxcbiAgICB1bmFtZSxcbiAgICBnbmFtZSxcbiAgICBkZXZtYWpvcixcbiAgICBkZXZtaW5vcixcbiAgICBwYXg6IG51bGxcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1VTVEFSIChidWYpIHtcbiAgcmV0dXJuIGI0YS5lcXVhbHMoVVNUQVJfTUFHSUMsIGJ1Zi5zdWJhcnJheShNQUdJQ19PRkZTRVQsIE1BR0lDX09GRlNFVCArIDYpKVxufVxuXG5mdW5jdGlvbiBpc0dOVSAoYnVmKSB7XG4gIHJldHVybiBiNGEuZXF1YWxzKEdOVV9NQUdJQywgYnVmLnN1YmFycmF5KE1BR0lDX09GRlNFVCwgTUFHSUNfT0ZGU0VUICsgNikpICYmXG4gICAgYjRhLmVxdWFscyhHTlVfVkVSLCBidWYuc3ViYXJyYXkoVkVSU0lPTl9PRkZTRVQsIFZFUlNJT05fT0ZGU0VUICsgMikpXG59XG5cbmZ1bmN0aW9uIGNsYW1wIChpbmRleCwgbGVuLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHJldHVybiBkZWZhdWx0VmFsdWVcbiAgaW5kZXggPSB+fmluZGV4IC8vIENvZXJjZSB0byBpbnRlZ2VyLlxuICBpZiAoaW5kZXggPj0gbGVuKSByZXR1cm4gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgaW5kZXggKz0gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gdG9UeXBlIChmbGFnKSB7XG4gIHN3aXRjaCAoZmxhZykge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiAnZmlsZSdcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gJ2xpbmsnXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuICdzeW1saW5rJ1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiAnY2hhcmFjdGVyLWRldmljZSdcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gJ2Jsb2NrLWRldmljZSdcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gJ2RpcmVjdG9yeSdcbiAgICBjYXNlIDY6XG4gICAgICByZXR1cm4gJ2ZpZm8nXG4gICAgY2FzZSA3OlxuICAgICAgcmV0dXJuICdjb250aWd1b3VzLWZpbGUnXG4gICAgY2FzZSA3MjpcbiAgICAgIHJldHVybiAncGF4LWhlYWRlcidcbiAgICBjYXNlIDU1OlxuICAgICAgcmV0dXJuICdwYXgtZ2xvYmFsLWhlYWRlcidcbiAgICBjYXNlIDI3OlxuICAgICAgcmV0dXJuICdnbnUtbG9uZy1saW5rLXBhdGgnXG4gICAgY2FzZSAyODpcbiAgICBjYXNlIDMwOlxuICAgICAgcmV0dXJuICdnbnUtbG9uZy1wYXRoJ1xuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gdG9UeXBlZmxhZyAoZmxhZykge1xuICBzd2l0Y2ggKGZsYWcpIHtcbiAgICBjYXNlICdmaWxlJzpcbiAgICAgIHJldHVybiAwXG4gICAgY2FzZSAnbGluayc6XG4gICAgICByZXR1cm4gMVxuICAgIGNhc2UgJ3N5bWxpbmsnOlxuICAgICAgcmV0dXJuIDJcbiAgICBjYXNlICdjaGFyYWN0ZXItZGV2aWNlJzpcbiAgICAgIHJldHVybiAzXG4gICAgY2FzZSAnYmxvY2stZGV2aWNlJzpcbiAgICAgIHJldHVybiA0XG4gICAgY2FzZSAnZGlyZWN0b3J5JzpcbiAgICAgIHJldHVybiA1XG4gICAgY2FzZSAnZmlmbyc6XG4gICAgICByZXR1cm4gNlxuICAgIGNhc2UgJ2NvbnRpZ3VvdXMtZmlsZSc6XG4gICAgICByZXR1cm4gN1xuICAgIGNhc2UgJ3BheC1oZWFkZXInOlxuICAgICAgcmV0dXJuIDcyXG4gIH1cblxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBpbmRleE9mIChibG9jaywgbnVtLCBvZmZzZXQsIGVuZCkge1xuICBmb3IgKDsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQrKykge1xuICAgIGlmIChibG9ja1tvZmZzZXRdID09PSBudW0pIHJldHVybiBvZmZzZXRcbiAgfVxuICByZXR1cm4gZW5kXG59XG5cbmZ1bmN0aW9uIGNrc3VtIChibG9jaykge1xuICBsZXQgc3VtID0gOCAqIDMyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTQ4OyBpKyspIHN1bSArPSBibG9ja1tpXVxuICBmb3IgKGxldCBqID0gMTU2OyBqIDwgNTEyOyBqKyspIHN1bSArPSBibG9ja1tqXVxuICByZXR1cm4gc3VtXG59XG5cbmZ1bmN0aW9uIGVuY29kZU9jdCAodmFsLCBuKSB7XG4gIHZhbCA9IHZhbC50b1N0cmluZyg4KVxuICBpZiAodmFsLmxlbmd0aCA+IG4pIHJldHVybiBTRVZFTlMuc2xpY2UoMCwgbikgKyAnICdcbiAgcmV0dXJuIFpFUk9TLnNsaWNlKDAsIG4gLSB2YWwubGVuZ3RoKSArIHZhbCArICcgJ1xufVxuXG5mdW5jdGlvbiBlbmNvZGVTaXplQmluIChudW0sIGJ1Ziwgb2ZmKSB7XG4gIGJ1ZltvZmZdID0gMHg4MFxuICBmb3IgKGxldCBpID0gMTE7IGkgPiAwOyBpLS0pIHtcbiAgICBidWZbb2ZmICsgaV0gPSBudW0gJiAweGZmXG4gICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyAweDEwMClcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmNvZGVTaXplIChudW0sIGJ1Ziwgb2ZmKSB7XG4gIGlmIChudW0udG9TdHJpbmcoOCkubGVuZ3RoID4gMTEpIHtcbiAgICBlbmNvZGVTaXplQmluKG51bSwgYnVmLCBvZmYpXG4gIH0gZWxzZSB7XG4gICAgYjRhLndyaXRlKGJ1ZiwgZW5jb2RlT2N0KG51bSwgMTEpLCBvZmYpXG4gIH1cbn1cblxuLyogQ29waWVkIGZyb20gdGhlIG5vZGUtdGFyIHJlcG8gYW5kIG1vZGlmaWVkIHRvIG1lZXRcbiAqIHRhci1zdHJlYW0gY29kaW5nIHN0YW5kYXJkLlxuICpcbiAqIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL25wbS9ub2RlLXRhci9ibG9iLzUxYjY2MjdhMWYzNTdkMmViNDMzZTczNzhlNWYwNWU4M2I3YWE2Y2QvbGliL2hlYWRlci5qcyNMMzQ5XG4gKi9cbmZ1bmN0aW9uIHBhcnNlMjU2IChidWYpIHtcbiAgLy8gZmlyc3QgYnl0ZSBNVVNUIGJlIGVpdGhlciA4MCBvciBGRlxuICAvLyA4MCBmb3IgcG9zaXRpdmUsIEZGIGZvciAyJ3MgY29tcFxuICBsZXQgcG9zaXRpdmVcbiAgaWYgKGJ1ZlswXSA9PT0gMHg4MCkgcG9zaXRpdmUgPSB0cnVlXG4gIGVsc2UgaWYgKGJ1ZlswXSA9PT0gMHhGRikgcG9zaXRpdmUgPSBmYWxzZVxuICBlbHNlIHJldHVybiBudWxsXG5cbiAgLy8gYnVpbGQgdXAgYSBiYXNlLTI1NiB0dXBsZSBmcm9tIHRoZSBsZWFzdCBzaWcgdG8gdGhlIGhpZ2hlc3RcbiAgY29uc3QgdHVwbGUgPSBbXVxuICBsZXQgaVxuICBmb3IgKGkgPSBidWYubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgIGNvbnN0IGJ5dGUgPSBidWZbaV1cbiAgICBpZiAocG9zaXRpdmUpIHR1cGxlLnB1c2goYnl0ZSlcbiAgICBlbHNlIHR1cGxlLnB1c2goMHhGRiAtIGJ5dGUpXG4gIH1cblxuICBsZXQgc3VtID0gMFxuICBjb25zdCBsID0gdHVwbGUubGVuZ3RoXG4gIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICBzdW0gKz0gdHVwbGVbaV0gKiBNYXRoLnBvdygyNTYsIGkpXG4gIH1cblxuICByZXR1cm4gcG9zaXRpdmUgPyBzdW0gOiAtMSAqIHN1bVxufVxuXG5mdW5jdGlvbiBkZWNvZGVPY3QgKHZhbCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFsID0gdmFsLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKVxuICBvZmZzZXQgPSAwXG5cbiAgLy8gSWYgcHJlZml4ZWQgd2l0aCAweDgwIHRoZW4gcGFyc2UgYXMgYSBiYXNlLTI1NiBpbnRlZ2VyXG4gIGlmICh2YWxbb2Zmc2V0XSAmIDB4ODApIHtcbiAgICByZXR1cm4gcGFyc2UyNTYodmFsKVxuICB9IGVsc2Uge1xuICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIHRhciBjYW4gcHJlZml4IHdpdGggc3BhY2VzXG4gICAgd2hpbGUgKG9mZnNldCA8IHZhbC5sZW5ndGggJiYgdmFsW29mZnNldF0gPT09IDMyKSBvZmZzZXQrK1xuICAgIGNvbnN0IGVuZCA9IGNsYW1wKGluZGV4T2YodmFsLCAzMiwgb2Zmc2V0LCB2YWwubGVuZ3RoKSwgdmFsLmxlbmd0aCwgdmFsLmxlbmd0aClcbiAgICB3aGlsZSAob2Zmc2V0IDwgZW5kICYmIHZhbFtvZmZzZXRdID09PSAwKSBvZmZzZXQrK1xuICAgIGlmIChlbmQgPT09IG9mZnNldCkgcmV0dXJuIDBcbiAgICByZXR1cm4gcGFyc2VJbnQoYjRhLnRvU3RyaW5nKHZhbC5zdWJhcnJheShvZmZzZXQsIGVuZCkpLCA4KVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlY29kZVN0ciAodmFsLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGI0YS50b1N0cmluZyh2YWwuc3ViYXJyYXkob2Zmc2V0LCBpbmRleE9mKHZhbCwgMCwgb2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpKSwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFkZExlbmd0aCAoc3RyKSB7XG4gIGNvbnN0IGxlbiA9IGI0YS5ieXRlTGVuZ3RoKHN0cilcbiAgbGV0IGRpZ2l0cyA9IE1hdGguZmxvb3IoTWF0aC5sb2cobGVuKSAvIE1hdGgubG9nKDEwKSkgKyAxXG4gIGlmIChsZW4gKyBkaWdpdHMgPj0gTWF0aC5wb3coMTAsIGRpZ2l0cykpIGRpZ2l0cysrXG5cbiAgcmV0dXJuIChsZW4gKyBkaWdpdHMpICsgc3RyXG59XG4iLCJleHBvcnRzLmV4dHJhY3QgPSByZXF1aXJlKCcuL2V4dHJhY3QnKVxuZXhwb3J0cy5wYWNrID0gcmVxdWlyZSgnLi9wYWNrJylcbiIsImNvbnN0IHsgUmVhZGFibGUsIFdyaXRhYmxlLCBnZXRTdHJlYW1FcnJvciB9ID0gcmVxdWlyZSgnc3RyZWFteCcpXG5jb25zdCBiNGEgPSByZXF1aXJlKCdiNGEnKVxuXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBoZWFkZXJzID0gcmVxdWlyZSgnLi9oZWFkZXJzJylcblxuY29uc3QgRE1PREUgPSAwbzc1NVxuY29uc3QgRk1PREUgPSAwbzY0NFxuXG5jb25zdCBFTkRfT0ZfVEFSID0gYjRhLmFsbG9jKDEwMjQpXG5cbmNsYXNzIFNpbmsgZXh0ZW5kcyBXcml0YWJsZSB7XG4gIGNvbnN0cnVjdG9yIChwYWNrLCBoZWFkZXIsIGNhbGxiYWNrKSB7XG4gICAgc3VwZXIoeyBtYXBXcml0YWJsZSwgZWFnZXJPcGVuOiB0cnVlIH0pXG5cbiAgICB0aGlzLndyaXR0ZW4gPSAwXG4gICAgdGhpcy5oZWFkZXIgPSBoZWFkZXJcblxuICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLl9saW5rbmFtZSA9IG51bGxcbiAgICB0aGlzLl9pc0xpbmtuYW1lID0gaGVhZGVyLnR5cGUgPT09ICdzeW1saW5rJyAmJiAhaGVhZGVyLmxpbmtuYW1lXG4gICAgdGhpcy5faXNWb2lkID0gaGVhZGVyLnR5cGUgIT09ICdmaWxlJyAmJiBoZWFkZXIudHlwZSAhPT0gJ2NvbnRpZ3VvdXMtZmlsZSdcbiAgICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlXG4gICAgdGhpcy5fcGFjayA9IHBhY2tcbiAgICB0aGlzLl9vcGVuQ2FsbGJhY2sgPSBudWxsXG5cbiAgICBpZiAodGhpcy5fcGFjay5fc3RyZWFtID09PSBudWxsKSB0aGlzLl9wYWNrLl9zdHJlYW0gPSB0aGlzXG4gICAgZWxzZSB0aGlzLl9wYWNrLl9wZW5kaW5nLnB1c2godGhpcylcbiAgfVxuXG4gIF9vcGVuIChjYikge1xuICAgIHRoaXMuX29wZW5DYWxsYmFjayA9IGNiXG4gICAgaWYgKHRoaXMuX3BhY2suX3N0cmVhbSA9PT0gdGhpcykgdGhpcy5fY29udGludWVPcGVuKClcbiAgfVxuXG4gIF9jb250aW51ZVBhY2sgKGVycikge1xuICAgIGlmICh0aGlzLl9jYWxsYmFjayA9PT0gbnVsbCkgcmV0dXJuXG5cbiAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuX2NhbGxiYWNrXG4gICAgdGhpcy5fY2FsbGJhY2sgPSBudWxsXG5cbiAgICBjYWxsYmFjayhlcnIpXG4gIH1cblxuICBfY29udGludWVPcGVuICgpIHtcbiAgICBpZiAodGhpcy5fcGFjay5fc3RyZWFtID09PSBudWxsKSB0aGlzLl9wYWNrLl9zdHJlYW0gPSB0aGlzXG5cbiAgICBjb25zdCBjYiA9IHRoaXMuX29wZW5DYWxsYmFja1xuICAgIHRoaXMuX29wZW5DYWxsYmFjayA9IG51bGxcbiAgICBpZiAoY2IgPT09IG51bGwpIHJldHVyblxuXG4gICAgaWYgKHRoaXMuX3BhY2suZGVzdHJveWluZykgcmV0dXJuIGNiKG5ldyBFcnJvcigncGFjayBzdHJlYW0gZGVzdHJveWVkJykpXG4gICAgaWYgKHRoaXMuX3BhY2suX2ZpbmFsaXplZCkgcmV0dXJuIGNiKG5ldyBFcnJvcigncGFjayBzdHJlYW0gaXMgYWxyZWFkeSBmaW5hbGl6ZWQnKSlcblxuICAgIHRoaXMuX3BhY2suX3N0cmVhbSA9IHRoaXNcblxuICAgIGlmICghdGhpcy5faXNMaW5rbmFtZSkge1xuICAgICAgdGhpcy5fcGFjay5fZW5jb2RlKHRoaXMuaGVhZGVyKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9pc1ZvaWQpIHtcbiAgICAgIHRoaXMuX2ZpbmlzaCgpXG4gICAgICB0aGlzLl9jb250aW51ZVBhY2sobnVsbClcbiAgICB9XG5cbiAgICBjYihudWxsKVxuICB9XG5cbiAgX3dyaXRlIChkYXRhLCBjYikge1xuICAgIGlmICh0aGlzLl9pc0xpbmtuYW1lKSB7XG4gICAgICB0aGlzLl9saW5rbmFtZSA9IHRoaXMuX2xpbmtuYW1lID8gYjRhLmNvbmNhdChbdGhpcy5fbGlua25hbWUsIGRhdGFdKSA6IGRhdGFcbiAgICAgIHJldHVybiBjYihudWxsKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9pc1ZvaWQpIHtcbiAgICAgIGlmIChkYXRhLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ05vIGJvZHkgYWxsb3dlZCBmb3IgdGhpcyBlbnRyeScpKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNiKClcbiAgICB9XG5cbiAgICB0aGlzLndyaXR0ZW4gKz0gZGF0YS5ieXRlTGVuZ3RoXG4gICAgaWYgKHRoaXMuX3BhY2sucHVzaChkYXRhKSkgcmV0dXJuIGNiKClcbiAgICB0aGlzLl9wYWNrLl9kcmFpbiA9IGNiXG4gIH1cblxuICBfZmluaXNoICgpIHtcbiAgICBpZiAodGhpcy5fZmluaXNoZWQpIHJldHVyblxuICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZVxuXG4gICAgaWYgKHRoaXMuX2lzTGlua25hbWUpIHtcbiAgICAgIHRoaXMuaGVhZGVyLmxpbmtuYW1lID0gdGhpcy5fbGlua25hbWUgPyBiNGEudG9TdHJpbmcodGhpcy5fbGlua25hbWUsICd1dGYtOCcpIDogJydcbiAgICAgIHRoaXMuX3BhY2suX2VuY29kZSh0aGlzLmhlYWRlcilcbiAgICB9XG5cbiAgICBvdmVyZmxvdyh0aGlzLl9wYWNrLCB0aGlzLmhlYWRlci5zaXplKVxuXG4gICAgdGhpcy5fcGFjay5fZG9uZSh0aGlzKVxuICB9XG5cbiAgX2ZpbmFsIChjYikge1xuICAgIGlmICh0aGlzLndyaXR0ZW4gIT09IHRoaXMuaGVhZGVyLnNpemUpIHsgLy8gY29ycnVwdGluZyB0YXJcbiAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ1NpemUgbWlzbWF0Y2gnKSlcbiAgICB9XG5cbiAgICB0aGlzLl9maW5pc2goKVxuICAgIGNiKG51bGwpXG4gIH1cblxuICBfZ2V0RXJyb3IgKCkge1xuICAgIHJldHVybiBnZXRTdHJlYW1FcnJvcih0aGlzKSB8fCBuZXcgRXJyb3IoJ3RhciBlbnRyeSBkZXN0cm95ZWQnKVxuICB9XG5cbiAgX3ByZWRlc3Ryb3kgKCkge1xuICAgIHRoaXMuX3BhY2suZGVzdHJveSh0aGlzLl9nZXRFcnJvcigpKVxuICB9XG5cbiAgX2Rlc3Ryb3kgKGNiKSB7XG4gICAgdGhpcy5fcGFjay5fZG9uZSh0aGlzKVxuXG4gICAgdGhpcy5fY29udGludWVQYWNrKHRoaXMuX2ZpbmlzaGVkID8gbnVsbCA6IHRoaXMuX2dldEVycm9yKCkpXG5cbiAgICBjYigpXG4gIH1cbn1cblxuY2xhc3MgUGFjayBleHRlbmRzIFJlYWRhYmxlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKVxuICAgIHRoaXMuX2RyYWluID0gbm9vcFxuICAgIHRoaXMuX2ZpbmFsaXplZCA9IGZhbHNlXG4gICAgdGhpcy5fZmluYWxpemluZyA9IGZhbHNlXG4gICAgdGhpcy5fcGVuZGluZyA9IFtdXG4gICAgdGhpcy5fc3RyZWFtID0gbnVsbFxuICB9XG5cbiAgZW50cnkgKGhlYWRlciwgYnVmZmVyLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9maW5hbGl6ZWQgfHwgdGhpcy5kZXN0cm95aW5nKSB0aHJvdyBuZXcgRXJyb3IoJ2FscmVhZHkgZmluYWxpemVkIG9yIGRlc3Ryb3llZCcpXG5cbiAgICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBidWZmZXJcbiAgICAgIGJ1ZmZlciA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAoIWNhbGxiYWNrKSBjYWxsYmFjayA9IG5vb3BcblxuICAgIGlmICghaGVhZGVyLnNpemUgfHwgaGVhZGVyLnR5cGUgPT09ICdzeW1saW5rJykgaGVhZGVyLnNpemUgPSAwXG4gICAgaWYgKCFoZWFkZXIudHlwZSkgaGVhZGVyLnR5cGUgPSBtb2RlVG9UeXBlKGhlYWRlci5tb2RlKVxuICAgIGlmICghaGVhZGVyLm1vZGUpIGhlYWRlci5tb2RlID0gaGVhZGVyLnR5cGUgPT09ICdkaXJlY3RvcnknID8gRE1PREUgOiBGTU9ERVxuICAgIGlmICghaGVhZGVyLnVpZCkgaGVhZGVyLnVpZCA9IDBcbiAgICBpZiAoIWhlYWRlci5naWQpIGhlYWRlci5naWQgPSAwXG4gICAgaWYgKCFoZWFkZXIubXRpbWUpIGhlYWRlci5tdGltZSA9IG5ldyBEYXRlKClcblxuICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJykgYnVmZmVyID0gYjRhLmZyb20oYnVmZmVyKVxuXG4gICAgY29uc3Qgc2luayA9IG5ldyBTaW5rKHRoaXMsIGhlYWRlciwgY2FsbGJhY2spXG5cbiAgICBpZiAoYjRhLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICAgIGhlYWRlci5zaXplID0gYnVmZmVyLmJ5dGVMZW5ndGhcbiAgICAgIHNpbmsud3JpdGUoYnVmZmVyKVxuICAgICAgc2luay5lbmQoKVxuICAgICAgcmV0dXJuIHNpbmtcbiAgICB9XG5cbiAgICBpZiAoc2luay5faXNWb2lkKSB7XG4gICAgICByZXR1cm4gc2lua1xuICAgIH1cblxuICAgIHJldHVybiBzaW5rXG4gIH1cblxuICBmaW5hbGl6ZSAoKSB7XG4gICAgaWYgKHRoaXMuX3N0cmVhbSB8fCB0aGlzLl9wZW5kaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX2ZpbmFsaXppbmcgPSB0cnVlXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZmluYWxpemVkKSByZXR1cm5cbiAgICB0aGlzLl9maW5hbGl6ZWQgPSB0cnVlXG5cbiAgICB0aGlzLnB1c2goRU5EX09GX1RBUilcbiAgICB0aGlzLnB1c2gobnVsbClcbiAgfVxuXG4gIF9kb25lIChzdHJlYW0pIHtcbiAgICBpZiAoc3RyZWFtICE9PSB0aGlzLl9zdHJlYW0pIHJldHVyblxuXG4gICAgdGhpcy5fc3RyZWFtID0gbnVsbFxuXG4gICAgaWYgKHRoaXMuX2ZpbmFsaXppbmcpIHRoaXMuZmluYWxpemUoKVxuICAgIGlmICh0aGlzLl9wZW5kaW5nLmxlbmd0aCkgdGhpcy5fcGVuZGluZy5zaGlmdCgpLl9jb250aW51ZU9wZW4oKVxuICB9XG5cbiAgX2VuY29kZSAoaGVhZGVyKSB7XG4gICAgaWYgKCFoZWFkZXIucGF4KSB7XG4gICAgICBjb25zdCBidWYgPSBoZWFkZXJzLmVuY29kZShoZWFkZXIpXG4gICAgICBpZiAoYnVmKSB7XG4gICAgICAgIHRoaXMucHVzaChidWYpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9lbmNvZGVQYXgoaGVhZGVyKVxuICB9XG5cbiAgX2VuY29kZVBheCAoaGVhZGVyKSB7XG4gICAgY29uc3QgcGF4SGVhZGVyID0gaGVhZGVycy5lbmNvZGVQYXgoe1xuICAgICAgbmFtZTogaGVhZGVyLm5hbWUsXG4gICAgICBsaW5rbmFtZTogaGVhZGVyLmxpbmtuYW1lLFxuICAgICAgcGF4OiBoZWFkZXIucGF4XG4gICAgfSlcblxuICAgIGNvbnN0IG5ld0hlYWRlciA9IHtcbiAgICAgIG5hbWU6ICdQYXhIZWFkZXInLFxuICAgICAgbW9kZTogaGVhZGVyLm1vZGUsXG4gICAgICB1aWQ6IGhlYWRlci51aWQsXG4gICAgICBnaWQ6IGhlYWRlci5naWQsXG4gICAgICBzaXplOiBwYXhIZWFkZXIuYnl0ZUxlbmd0aCxcbiAgICAgIG10aW1lOiBoZWFkZXIubXRpbWUsXG4gICAgICB0eXBlOiAncGF4LWhlYWRlcicsXG4gICAgICBsaW5rbmFtZTogaGVhZGVyLmxpbmtuYW1lICYmICdQYXhIZWFkZXInLFxuICAgICAgdW5hbWU6IGhlYWRlci51bmFtZSxcbiAgICAgIGduYW1lOiBoZWFkZXIuZ25hbWUsXG4gICAgICBkZXZtYWpvcjogaGVhZGVyLmRldm1ham9yLFxuICAgICAgZGV2bWlub3I6IGhlYWRlci5kZXZtaW5vclxuICAgIH1cblxuICAgIHRoaXMucHVzaChoZWFkZXJzLmVuY29kZShuZXdIZWFkZXIpKVxuICAgIHRoaXMucHVzaChwYXhIZWFkZXIpXG4gICAgb3ZlcmZsb3codGhpcywgcGF4SGVhZGVyLmJ5dGVMZW5ndGgpXG5cbiAgICBuZXdIZWFkZXIuc2l6ZSA9IGhlYWRlci5zaXplXG4gICAgbmV3SGVhZGVyLnR5cGUgPSBoZWFkZXIudHlwZVxuICAgIHRoaXMucHVzaChoZWFkZXJzLmVuY29kZShuZXdIZWFkZXIpKVxuICB9XG5cbiAgX2RvRHJhaW4gKCkge1xuICAgIGNvbnN0IGRyYWluID0gdGhpcy5fZHJhaW5cbiAgICB0aGlzLl9kcmFpbiA9IG5vb3BcbiAgICBkcmFpbigpXG4gIH1cblxuICBfcHJlZGVzdHJveSAoKSB7XG4gICAgY29uc3QgZXJyID0gZ2V0U3RyZWFtRXJyb3IodGhpcylcblxuICAgIGlmICh0aGlzLl9zdHJlYW0pIHRoaXMuX3N0cmVhbS5kZXN0cm95KGVycilcblxuICAgIHdoaWxlICh0aGlzLl9wZW5kaW5nLmxlbmd0aCkge1xuICAgICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fcGVuZGluZy5zaGlmdCgpXG4gICAgICBzdHJlYW0uZGVzdHJveShlcnIpXG4gICAgICBzdHJlYW0uX2NvbnRpbnVlT3BlbigpXG4gICAgfVxuXG4gICAgdGhpcy5fZG9EcmFpbigpXG4gIH1cblxuICBfcmVhZCAoY2IpIHtcbiAgICB0aGlzLl9kb0RyYWluKClcbiAgICBjYigpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYWNrIChvcHRzKSB7XG4gIHJldHVybiBuZXcgUGFjayhvcHRzKVxufVxuXG5mdW5jdGlvbiBtb2RlVG9UeXBlIChtb2RlKSB7XG4gIHN3aXRjaCAobW9kZSAmIGNvbnN0YW50cy5TX0lGTVQpIHtcbiAgICBjYXNlIGNvbnN0YW50cy5TX0lGQkxLOiByZXR1cm4gJ2Jsb2NrLWRldmljZSdcbiAgICBjYXNlIGNvbnN0YW50cy5TX0lGQ0hSOiByZXR1cm4gJ2NoYXJhY3Rlci1kZXZpY2UnXG4gICAgY2FzZSBjb25zdGFudHMuU19JRkRJUjogcmV0dXJuICdkaXJlY3RvcnknXG4gICAgY2FzZSBjb25zdGFudHMuU19JRklGTzogcmV0dXJuICdmaWZvJ1xuICAgIGNhc2UgY29uc3RhbnRzLlNfSUZMTks6IHJldHVybiAnc3ltbGluaydcbiAgfVxuXG4gIHJldHVybiAnZmlsZSdcbn1cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5mdW5jdGlvbiBvdmVyZmxvdyAoc2VsZiwgc2l6ZSkge1xuICBzaXplICY9IDUxMVxuICBpZiAoc2l6ZSkgc2VsZi5wdXNoKEVORF9PRl9UQVIuc3ViYXJyYXkoMCwgNTEyIC0gc2l6ZSkpXG59XG5cbmZ1bmN0aW9uIG1hcFdyaXRhYmxlIChidWYpIHtcbiAgcmV0dXJuIGI0YS5pc0J1ZmZlcihidWYpID8gYnVmIDogYjRhLmZyb20oYnVmKVxufVxuIiwiY29uc3QgUGFzc1Rocm91Z2hEZWNvZGVyID0gcmVxdWlyZSgnLi9saWIvcGFzcy10aHJvdWdoLWRlY29kZXInKVxuY29uc3QgVVRGOERlY29kZXIgPSByZXF1aXJlKCcuL2xpYi91dGY4LWRlY29kZXInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFRleHREZWNvZGVyIHtcbiAgY29uc3RydWN0b3IgKGVuY29kaW5nID0gJ3V0ZjgnKSB7XG4gICAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKVxuXG4gICAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgICAgdGhpcy5kZWNvZGVyID0gbmV3IFVURjhEZWNvZGVyKClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBlbmNvZGluZzogJyArIHRoaXMuZW5jb2RpbmcpXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmRlY29kZXIgPSBuZXcgUGFzc1Rocm91Z2hEZWNvZGVyKHRoaXMuZW5jb2RpbmcpXG4gICAgfVxuICB9XG5cbiAgZ2V0IHJlbWFpbmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2Rlci5yZW1haW5pbmdcbiAgfVxuXG4gIHB1c2ggKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSByZXR1cm4gZGF0YVxuICAgIHJldHVybiB0aGlzLmRlY29kZXIuZGVjb2RlKGRhdGEpXG4gIH1cblxuICAvLyBGb3IgTm9kZS5qcyBjb21wYXRpYmlsaXR5XG4gIHdyaXRlIChkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMucHVzaChkYXRhKVxuICB9XG5cbiAgZW5kIChkYXRhKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnXG4gICAgaWYgKGRhdGEpIHJlc3VsdCA9IHRoaXMucHVzaChkYXRhKVxuICAgIHJlc3VsdCArPSB0aGlzLmRlY29kZXIuZmx1c2goKVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpXG5cbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiAndXRmOCdcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuICd1dGYxNmxlJ1xuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldHVybiAnbGF0aW4xJ1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXR1cm4gZW5jb2RpbmdcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cbn07XG4iLCJjb25zdCBiNGEgPSByZXF1aXJlKCdiNGEnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFBhc3NUaHJvdWdoRGVjb2RlciB7XG4gIGNvbnN0cnVjdG9yIChlbmNvZGluZykge1xuICAgIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZ1xuICB9XG5cbiAgZ2V0IHJlbWFpbmluZyAoKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGRlY29kZSAodGFpbCkge1xuICAgIHJldHVybiBiNGEudG9TdHJpbmcodGFpbCwgdGhpcy5lbmNvZGluZylcbiAgfVxuXG4gIGZsdXNoICgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxufVxuIiwiY29uc3QgYjRhID0gcmVxdWlyZSgnYjRhJylcblxuLyoqXG4gKiBodHRwczovL2VuY29kaW5nLnNwZWMud2hhdHdnLm9yZy8jdXRmLTgtZGVjb2RlclxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFVURjhEZWNvZGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuY29kZVBvaW50ID0gMFxuICAgIHRoaXMuYnl0ZXNTZWVuID0gMFxuICAgIHRoaXMuYnl0ZXNOZWVkZWQgPSAwXG4gICAgdGhpcy5sb3dlckJvdW5kYXJ5ID0gMHg4MFxuICAgIHRoaXMudXBwZXJCb3VuZGFyeSA9IDB4YmZcbiAgfVxuXG4gIGdldCByZW1haW5pbmcgKCkge1xuICAgIHJldHVybiB0aGlzLmJ5dGVzU2VlblxuICB9XG5cbiAgZGVjb2RlIChkYXRhKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhIGZhc3QgcGF0aCwganVzdCBzbmlmZiBpZiB0aGUgbGFzdCBwYXJ0IGlzIGEgYm91bmRhcnlcbiAgICBpZiAodGhpcy5ieXRlc05lZWRlZCA9PT0gMCkge1xuICAgICAgbGV0IGlzQm91bmRhcnkgPSB0cnVlXG5cbiAgICAgIGZvciAobGV0IGkgPSBNYXRoLm1heCgwLCBkYXRhLmJ5dGVMZW5ndGggLSA0KSwgbiA9IGRhdGEuYnl0ZUxlbmd0aDsgaSA8IG4gJiYgaXNCb3VuZGFyeTsgaSsrKSB7XG4gICAgICAgIGlzQm91bmRhcnkgPSBkYXRhW2ldIDw9IDB4N2ZcbiAgICAgIH1cblxuICAgICAgaWYgKGlzQm91bmRhcnkpIHJldHVybiBiNGEudG9TdHJpbmcoZGF0YSwgJ3V0ZjgnKVxuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSAnJ1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBkYXRhLmJ5dGVMZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIGNvbnN0IGJ5dGUgPSBkYXRhW2ldXG5cbiAgICAgIGlmICh0aGlzLmJ5dGVzTmVlZGVkID09PSAwKSB7XG4gICAgICAgIGlmIChieXRlIDw9IDB4N2YpIHtcbiAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYnl0ZXNTZWVuID0gMVxuXG4gICAgICAgICAgaWYgKGJ5dGUgPj0gMHhjMiAmJiBieXRlIDw9IDB4ZGYpIHtcbiAgICAgICAgICAgIHRoaXMuYnl0ZXNOZWVkZWQgPSAyXG4gICAgICAgICAgICB0aGlzLmNvZGVQb2ludCA9IGJ5dGUgJiAweDFmXG4gICAgICAgICAgfSBlbHNlIGlmIChieXRlID49IDB4ZTAgJiYgYnl0ZSA8PSAweGVmKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZSA9PT0gMHhlMCkgdGhpcy5sb3dlckJvdW5kYXJ5ID0gMHhhMFxuICAgICAgICAgICAgZWxzZSBpZiAoYnl0ZSA9PT0gMHhlZCkgdGhpcy51cHBlckJvdW5kYXJ5ID0gMHg5ZlxuICAgICAgICAgICAgdGhpcy5ieXRlc05lZWRlZCA9IDNcbiAgICAgICAgICAgIHRoaXMuY29kZVBvaW50ID0gYnl0ZSAmIDB4ZlxuICAgICAgICAgIH0gZWxzZSBpZiAoYnl0ZSA+PSAweGYwICYmIGJ5dGUgPD0gMHhmNCkge1xuICAgICAgICAgICAgaWYgKGJ5dGUgPT09IDB4ZjApIHRoaXMubG93ZXJCb3VuZGFyeSA9IDB4OTBcbiAgICAgICAgICAgIGlmIChieXRlID09PSAweGY0KSB0aGlzLnVwcGVyQm91bmRhcnkgPSAweDhmXG4gICAgICAgICAgICB0aGlzLmJ5dGVzTmVlZGVkID0gNFxuICAgICAgICAgICAgdGhpcy5jb2RlUG9pbnQgPSBieXRlICYgMHg3XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFx1ZmZmZCdcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAoYnl0ZSA8IHRoaXMubG93ZXJCb3VuZGFyeSB8fCBieXRlID4gdGhpcy51cHBlckJvdW5kYXJ5KSB7XG4gICAgICAgIHRoaXMuY29kZVBvaW50ID0gMFxuICAgICAgICB0aGlzLmJ5dGVzTmVlZGVkID0gMFxuICAgICAgICB0aGlzLmJ5dGVzU2VlbiA9IDBcbiAgICAgICAgdGhpcy5sb3dlckJvdW5kYXJ5ID0gMHg4MFxuICAgICAgICB0aGlzLnVwcGVyQm91bmRhcnkgPSAweGJmXG5cbiAgICAgICAgcmVzdWx0ICs9ICdcXHVmZmZkJ1xuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHRoaXMubG93ZXJCb3VuZGFyeSA9IDB4ODBcbiAgICAgIHRoaXMudXBwZXJCb3VuZGFyeSA9IDB4YmZcblxuICAgICAgdGhpcy5jb2RlUG9pbnQgPSAodGhpcy5jb2RlUG9pbnQgPDwgNikgfCAoYnl0ZSAmIDB4M2YpXG4gICAgICB0aGlzLmJ5dGVzU2VlbisrXG5cbiAgICAgIGlmICh0aGlzLmJ5dGVzU2VlbiAhPT0gdGhpcy5ieXRlc05lZWRlZCkgY29udGludWVcblxuICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KHRoaXMuY29kZVBvaW50KVxuXG4gICAgICB0aGlzLmNvZGVQb2ludCA9IDBcbiAgICAgIHRoaXMuYnl0ZXNOZWVkZWQgPSAwXG4gICAgICB0aGlzLmJ5dGVzU2VlbiA9IDBcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmbHVzaCAoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5ieXRlc05lZWRlZCA+IDAgPyAnXFx1ZmZmZCcgOiAnJ1xuXG4gICAgdGhpcy5jb2RlUG9pbnQgPSAwXG4gICAgdGhpcy5ieXRlc05lZWRlZCA9IDBcbiAgICB0aGlzLmJ5dGVzU2VlbiA9IDBcbiAgICB0aGlzLmxvd2VyQm91bmRhcnkgPSAweDgwXG4gICAgdGhpcy51cHBlckJvdW5kYXJ5ID0gMHhiZlxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=