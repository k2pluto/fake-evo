"use strict";
exports.id = "vendors-node_modules_yargs_build_lib_utils_apply-extends_js-node_modules_yargs_lib_platform-s-9793a5";
exports.ids = ["vendors-node_modules_yargs_build_lib_utils_apply-extends_js-node_modules_yargs_lib_platform-s-9793a5"];
exports.modules = {

/***/ "./node_modules/cliui/build/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/cliui/build/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UI: () => (/* binding */ UI),
/* harmony export */   cliui: () => (/* binding */ cliui)
/* harmony export */ });

const align = {
    right: alignRight,
    center: alignCenter
};
const top = 0;
const right = 1;
const bottom = 2;
const left = 3;
class UI {
    constructor(opts) {
        var _a;
        this.width = opts.width;
        this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;
        this.rows = [];
    }
    span(...args) {
        const cols = this.div(...args);
        cols.span = true;
    }
    resetOutput() {
        this.rows = [];
    }
    div(...args) {
        if (args.length === 0) {
            this.div('');
        }
        if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === 'string') {
            return this.applyLayoutDSL(args[0]);
        }
        const cols = args.map(arg => {
            if (typeof arg === 'string') {
                return this.colFromString(arg);
            }
            return arg;
        });
        this.rows.push(cols);
        return cols;
    }
    shouldApplyLayoutDSL(...args) {
        return args.length === 1 && typeof args[0] === 'string' &&
            /[\t\n]/.test(args[0]);
    }
    applyLayoutDSL(str) {
        const rows = str.split('\n').map(row => row.split('\t'));
        let leftColumnWidth = 0;
        // simple heuristic for layout, make sure the
        // second column lines up along the left-hand.
        // don't allow the first column to take up more
        // than 50% of the screen.
        rows.forEach(columns => {
            if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {
                leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));
            }
        });
        // generate a table:
        //  replacing ' ' with padding calculations.
        //  using the algorithmically generated width.
        rows.forEach(columns => {
            this.div(...columns.map((r, i) => {
                return {
                    text: r.trim(),
                    padding: this.measurePadding(r),
                    width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined
                };
            }));
        });
        return this.rows[this.rows.length - 1];
    }
    colFromString(text) {
        return {
            text,
            padding: this.measurePadding(text)
        };
    }
    measurePadding(str) {
        // measure padding without ansi escape codes
        const noAnsi = mixin.stripAnsi(str);
        return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
    }
    toString() {
        const lines = [];
        this.rows.forEach(row => {
            this.rowToString(row, lines);
        });
        // don't display any lines with the
        // hidden flag set.
        return lines
            .filter(line => !line.hidden)
            .map(line => line.text)
            .join('\n');
    }
    rowToString(row, lines) {
        this.rasterize(row).forEach((rrow, r) => {
            let str = '';
            rrow.forEach((col, c) => {
                const { width } = row[c]; // the width with padding.
                const wrapWidth = this.negatePadding(row[c]); // the width without padding.
                let ts = col; // temporary string used during alignment/padding.
                if (wrapWidth > mixin.stringWidth(col)) {
                    ts += ' '.repeat(wrapWidth - mixin.stringWidth(col));
                }
                // align the string within its column.
                if (row[c].align && row[c].align !== 'left' && this.wrap) {
                    const fn = align[row[c].align];
                    ts = fn(ts, wrapWidth);
                    if (mixin.stringWidth(ts) < wrapWidth) {
                        ts += ' '.repeat((width || 0) - mixin.stringWidth(ts) - 1);
                    }
                }
                // apply border and padding to string.
                const padding = row[c].padding || [0, 0, 0, 0];
                if (padding[left]) {
                    str += ' '.repeat(padding[left]);
                }
                str += addBorder(row[c], ts, '| ');
                str += ts;
                str += addBorder(row[c], ts, ' |');
                if (padding[right]) {
                    str += ' '.repeat(padding[right]);
                }
                // if prior row is span, try to render the
                // current row on the prior line.
                if (r === 0 && lines.length > 0) {
                    str = this.renderInline(str, lines[lines.length - 1]);
                }
            });
            // remove trailing whitespace.
            lines.push({
                text: str.replace(/ +$/, ''),
                span: row.span
            });
        });
        return lines;
    }
    // if the full 'source' can render in
    // the target line, do so.
    renderInline(source, previousLine) {
        const match = source.match(/^ */);
        const leadingWhitespace = match ? match[0].length : 0;
        const target = previousLine.text;
        const targetTextWidth = mixin.stringWidth(target.trimRight());
        if (!previousLine.span) {
            return source;
        }
        // if we're not applying wrapping logic,
        // just always append to the span.
        if (!this.wrap) {
            previousLine.hidden = true;
            return target + source;
        }
        if (leadingWhitespace < targetTextWidth) {
            return source;
        }
        previousLine.hidden = true;
        return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
    }
    rasterize(row) {
        const rrows = [];
        const widths = this.columnWidths(row);
        let wrapped;
        // word wrap all columns, and create
        // a data-structure that is easy to rasterize.
        row.forEach((col, c) => {
            // leave room for left and right padding.
            col.width = widths[c];
            if (this.wrap) {
                wrapped = mixin.wrap(col.text, this.negatePadding(col), { hard: true }).split('\n');
            }
            else {
                wrapped = col.text.split('\n');
            }
            if (col.border) {
                wrapped.unshift('.' + '-'.repeat(this.negatePadding(col) + 2) + '.');
                wrapped.push("'" + '-'.repeat(this.negatePadding(col) + 2) + "'");
            }
            // add top and bottom padding.
            if (col.padding) {
                wrapped.unshift(...new Array(col.padding[top] || 0).fill(''));
                wrapped.push(...new Array(col.padding[bottom] || 0).fill(''));
            }
            wrapped.forEach((str, r) => {
                if (!rrows[r]) {
                    rrows.push([]);
                }
                const rrow = rrows[r];
                for (let i = 0; i < c; i++) {
                    if (rrow[i] === undefined) {
                        rrow.push('');
                    }
                }
                rrow.push(str);
            });
        });
        return rrows;
    }
    negatePadding(col) {
        let wrapWidth = col.width || 0;
        if (col.padding) {
            wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
        }
        if (col.border) {
            wrapWidth -= 4;
        }
        return wrapWidth;
    }
    columnWidths(row) {
        if (!this.wrap) {
            return row.map(col => {
                return col.width || mixin.stringWidth(col.text);
            });
        }
        let unset = row.length;
        let remainingWidth = this.width;
        // column widths can be set in config.
        const widths = row.map(col => {
            if (col.width) {
                unset--;
                remainingWidth -= col.width;
                return col.width;
            }
            return undefined;
        });
        // any unset widths should be calculated.
        const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
        return widths.map((w, i) => {
            if (w === undefined) {
                return Math.max(unsetWidth, _minWidth(row[i]));
            }
            return w;
        });
    }
}
function addBorder(col, ts, style) {
    if (col.border) {
        if (/[.']-+[.']/.test(ts)) {
            return '';
        }
        if (ts.trim().length !== 0) {
            return style;
        }
        return '  ';
    }
    return '';
}
// calculates the minimum width of
// a column, based on padding preferences.
function _minWidth(col) {
    const padding = col.padding || [];
    const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
    if (col.border) {
        return minWidth + 4;
    }
    return minWidth;
}
function getWindowWidth() {
    /* istanbul ignore next: depends on terminal */
    if (typeof process === 'object' && process.stdout && process.stdout.columns) {
        return process.stdout.columns;
    }
    return 80;
}
function alignRight(str, width) {
    str = str.trim();
    const strWidth = mixin.stringWidth(str);
    if (strWidth < width) {
        return ' '.repeat(width - strWidth) + str;
    }
    return str;
}
function alignCenter(str, width) {
    str = str.trim();
    const strWidth = mixin.stringWidth(str);
    /* istanbul ignore next */
    if (strWidth >= width) {
        return str;
    }
    return ' '.repeat((width - strWidth) >> 1) + str;
}
let mixin;
function cliui(opts, _mixin) {
    mixin = _mixin;
    return new UI({
        width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),
        wrap: opts === null || opts === void 0 ? void 0 : opts.wrap
    });
}


/***/ }),

/***/ "./node_modules/cliui/build/lib/string-utils.js":
/*!******************************************************!*\
  !*** ./node_modules/cliui/build/lib/string-utils.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   stripAnsi: () => (/* binding */ stripAnsi),
/* harmony export */   wrap: () => (/* binding */ wrap)
/* harmony export */ });
// Minimal replacement for ansi string helpers "wrap-ansi" and "strip-ansi".
// to facilitate ESM and Deno modules.
// TODO: look at porting https://www.npmjs.com/package/wrap-ansi to ESM.
// The npm application
// Copyright (c) npm, Inc. and Contributors
// Licensed on the terms of The Artistic License 2.0
// See: https://github.com/npm/cli/blob/4c65cd952bc8627811735bea76b9b110cc4fc80e/lib/utils/ansi-trim.js
const ansi = new RegExp('\x1b(?:\\[(?:\\d+[ABCDEFGJKSTm]|\\d+;\\d+[Hfm]|' +
    '\\d+;\\d+;\\d+m|6n|s|u|\\?25[lh])|\\w)', 'g');
function stripAnsi(str) {
    return str.replace(ansi, '');
}
function wrap(str, width) {
    const [start, end] = str.match(ansi) || ['', ''];
    str = stripAnsi(str);
    let wrapped = '';
    for (let i = 0; i < str.length; i++) {
        if (i !== 0 && (i % width) === 0) {
            wrapped += '\n';
        }
        wrapped += str.charAt(i);
    }
    if (start && end) {
        wrapped = `${start}${wrapped}${end}`;
    }
    return wrapped;
}


/***/ }),

/***/ "./node_modules/cliui/index.mjs":
/*!**************************************!*\
  !*** ./node_modules/cliui/index.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ui)
/* harmony export */ });
/* harmony import */ var _build_lib_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./build/lib/index.js */ "./node_modules/cliui/build/lib/index.js");
/* harmony import */ var _build_lib_string_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./build/lib/string-utils.js */ "./node_modules/cliui/build/lib/string-utils.js");
// Bootstrap cliui with CommonJS dependencies:



function ui (opts) {
  return (0,_build_lib_index_js__WEBPACK_IMPORTED_MODULE_0__.cliui)(opts, {
    stringWidth: (str) => {
      return [...str].length
    },
    stripAnsi: _build_lib_string_utils_js__WEBPACK_IMPORTED_MODULE_1__.stripAnsi,
    wrap: _build_lib_string_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrap
  })
}


/***/ }),

/***/ "./node_modules/escalade/sync/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/escalade/sync/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ "fs");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(start, callback) {
	let dir = (0,path__WEBPACK_IMPORTED_MODULE_0__.resolve)('.', start);
	let tmp, stats = (0,fs__WEBPACK_IMPORTED_MODULE_1__.statSync)(dir);

	if (!stats.isDirectory()) {
		dir = (0,path__WEBPACK_IMPORTED_MODULE_0__.dirname)(dir);
	}

	while (true) {
		tmp = callback(dir, (0,fs__WEBPACK_IMPORTED_MODULE_1__.readdirSync)(dir));
		if (tmp) return (0,path__WEBPACK_IMPORTED_MODULE_0__.resolve)(dir, tmp);
		dir = (0,path__WEBPACK_IMPORTED_MODULE_0__.dirname)(tmp = dir);
		if (tmp === dir) break;
	}
}


/***/ }),

/***/ "./node_modules/y18n/build/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/y18n/build/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   y18n: () => (/* binding */ y18n)
/* harmony export */ });
let shim;
class Y18N {
    constructor(opts) {
        // configurable options.
        opts = opts || {};
        this.directory = opts.directory || './locales';
        this.updateFiles = typeof opts.updateFiles === 'boolean' ? opts.updateFiles : true;
        this.locale = opts.locale || 'en';
        this.fallbackToLanguage = typeof opts.fallbackToLanguage === 'boolean' ? opts.fallbackToLanguage : true;
        // internal stuff.
        this.cache = Object.create(null);
        this.writeQueue = [];
    }
    __(...args) {
        if (typeof arguments[0] !== 'string') {
            return this._taggedLiteral(arguments[0], ...arguments);
        }
        const str = args.shift();
        let cb = function () { }; // start with noop.
        if (typeof args[args.length - 1] === 'function')
            cb = args.pop();
        cb = cb || function () { }; // noop.
        if (!this.cache[this.locale])
            this._readLocaleFile();
        // we've observed a new string, update the language file.
        if (!this.cache[this.locale][str] && this.updateFiles) {
            this.cache[this.locale][str] = str;
            // include the current directory and locale,
            // since these values could change before the
            // write is performed.
            this._enqueueWrite({
                directory: this.directory,
                locale: this.locale,
                cb
            });
        }
        else {
            cb();
        }
        return shim.format.apply(shim.format, [this.cache[this.locale][str] || str].concat(args));
    }
    __n() {
        const args = Array.prototype.slice.call(arguments);
        const singular = args.shift();
        const plural = args.shift();
        const quantity = args.shift();
        let cb = function () { }; // start with noop.
        if (typeof args[args.length - 1] === 'function')
            cb = args.pop();
        if (!this.cache[this.locale])
            this._readLocaleFile();
        let str = quantity === 1 ? singular : plural;
        if (this.cache[this.locale][singular]) {
            const entry = this.cache[this.locale][singular];
            str = entry[quantity === 1 ? 'one' : 'other'];
        }
        // we've observed a new string, update the language file.
        if (!this.cache[this.locale][singular] && this.updateFiles) {
            this.cache[this.locale][singular] = {
                one: singular,
                other: plural
            };
            // include the current directory and locale,
            // since these values could change before the
            // write is performed.
            this._enqueueWrite({
                directory: this.directory,
                locale: this.locale,
                cb
            });
        }
        else {
            cb();
        }
        // if a %d placeholder is provided, add quantity
        // to the arguments expanded by util.format.
        const values = [str];
        if (~str.indexOf('%d'))
            values.push(quantity);
        return shim.format.apply(shim.format, values.concat(args));
    }
    setLocale(locale) {
        this.locale = locale;
    }
    getLocale() {
        return this.locale;
    }
    updateLocale(obj) {
        if (!this.cache[this.locale])
            this._readLocaleFile();
        for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                this.cache[this.locale][key] = obj[key];
            }
        }
    }
    _taggedLiteral(parts, ...args) {
        let str = '';
        parts.forEach(function (part, i) {
            const arg = args[i + 1];
            str += part;
            if (typeof arg !== 'undefined') {
                str += '%s';
            }
        });
        return this.__.apply(this, [str].concat([].slice.call(args, 1)));
    }
    _enqueueWrite(work) {
        this.writeQueue.push(work);
        if (this.writeQueue.length === 1)
            this._processWriteQueue();
    }
    _processWriteQueue() {
        const _this = this;
        const work = this.writeQueue[0];
        // destructure the enqueued work.
        const directory = work.directory;
        const locale = work.locale;
        const cb = work.cb;
        const languageFile = this._resolveLocaleFile(directory, locale);
        const serializedLocale = JSON.stringify(this.cache[locale], null, 2);
        shim.fs.writeFile(languageFile, serializedLocale, 'utf-8', function (err) {
            _this.writeQueue.shift();
            if (_this.writeQueue.length > 0)
                _this._processWriteQueue();
            cb(err);
        });
    }
    _readLocaleFile() {
        let localeLookup = {};
        const languageFile = this._resolveLocaleFile(this.directory, this.locale);
        try {
            // When using a bundler such as webpack, readFileSync may not be defined:
            if (shim.fs.readFileSync) {
                localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, 'utf-8'));
            }
        }
        catch (err) {
            if (err instanceof SyntaxError) {
                err.message = 'syntax error in ' + languageFile;
            }
            if (err.code === 'ENOENT')
                localeLookup = {};
            else
                throw err;
        }
        this.cache[this.locale] = localeLookup;
    }
    _resolveLocaleFile(directory, locale) {
        let file = shim.resolve(directory, './', locale + '.json');
        if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf('_')) {
            // attempt fallback to language only
            const languageFile = shim.resolve(directory, './', locale.split('_')[0] + '.json');
            if (this._fileExistsSync(languageFile))
                file = languageFile;
        }
        return file;
    }
    _fileExistsSync(file) {
        return shim.exists(file);
    }
}
function y18n(opts, _shim) {
    shim = _shim;
    const y18n = new Y18N(opts);
    return {
        __: y18n.__.bind(y18n),
        __n: y18n.__n.bind(y18n),
        setLocale: y18n.setLocale.bind(y18n),
        getLocale: y18n.getLocale.bind(y18n),
        updateLocale: y18n.updateLocale.bind(y18n),
        locale: y18n.locale
    };
}


/***/ }),

/***/ "./node_modules/y18n/build/lib/platform-shims/node.js":
/*!************************************************************!*\
  !*** ./node_modules/y18n/build/lib/platform-shims/node.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! util */ "util");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ "path");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    fs: {
        readFileSync: fs__WEBPACK_IMPORTED_MODULE_0__.readFileSync,
        writeFile: fs__WEBPACK_IMPORTED_MODULE_0__.writeFile
    },
    format: util__WEBPACK_IMPORTED_MODULE_1__.format,
    resolve: path__WEBPACK_IMPORTED_MODULE_2__.resolve,
    exists: (file) => {
        try {
            return (0,fs__WEBPACK_IMPORTED_MODULE_0__.statSync)(file).isFile();
        }
        catch (err) {
            return false;
        }
    }
});


/***/ }),

/***/ "./node_modules/y18n/index.mjs":
/*!*************************************!*\
  !*** ./node_modules/y18n/index.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _build_lib_platform_shims_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./build/lib/platform-shims/node.js */ "./node_modules/y18n/build/lib/platform-shims/node.js");
/* harmony import */ var _build_lib_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./build/lib/index.js */ "./node_modules/y18n/build/lib/index.js");



const y18n = (opts) => {
  return (0,_build_lib_index_js__WEBPACK_IMPORTED_MODULE_1__.y18n)(opts, _build_lib_platform_shims_node_js__WEBPACK_IMPORTED_MODULE_0__["default"])
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (y18n);


/***/ }),

/***/ "./node_modules/yargs-parser/build/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/yargs-parser/build/lib/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ "util");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var _string_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./string-utils.js */ "./node_modules/yargs-parser/build/lib/string-utils.js");
/* harmony import */ var _yargs_parser_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./yargs-parser.js */ "./node_modules/yargs-parser/build/lib/yargs-parser.js");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fs */ "fs");
/**
 * @fileoverview Main entrypoint for libraries using yargs-parser in Node.js
 * CJS and ESM environments.
 *
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
var _a, _b, _c;





// See https://github.com/yargs/yargs-parser#supported-nodejs-versions for our
// version support policy. The YARGS_MIN_NODE_VERSION is used for testing only.
const minNodeVersion = (process && ({"STAGE_ENV":"lemon"}) && ({"STAGE_ENV":"lemon"}).YARGS_MIN_NODE_VERSION)
    ? Number(({"STAGE_ENV":"lemon"}).YARGS_MIN_NODE_VERSION)
    : 12;
const nodeVersion = (_b = (_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node) !== null && _b !== void 0 ? _b : (_c = process === null || process === void 0 ? void 0 : process.version) === null || _c === void 0 ? void 0 : _c.slice(1);
if (nodeVersion) {
    const major = Number(nodeVersion.match(/^([^.]+)/)[1]);
    if (major < minNodeVersion) {
        throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);
    }
}
// Creates a yargs-parser instance using Node.js standard libraries:
const env = process ? ({"STAGE_ENV":"lemon"}) : {};
const parser = new _yargs_parser_js__WEBPACK_IMPORTED_MODULE_3__.YargsParser({
    cwd: process.cwd,
    env: () => {
        return env;
    },
    format: util__WEBPACK_IMPORTED_MODULE_0__.format,
    normalize: path__WEBPACK_IMPORTED_MODULE_1__.normalize,
    resolve: path__WEBPACK_IMPORTED_MODULE_1__.resolve,
    // TODO: figure  out a  way to combine ESM and CJS coverage, such  that
    // we can exercise all the lines below:
    require: (path) => {
        if (typeof require !== 'undefined') {
            return require(path);
        }
        else if (path.match(/\.json$/)) {
            // Addresses: https://github.com/yargs/yargs/issues/2040
            return JSON.parse((0,fs__WEBPACK_IMPORTED_MODULE_4__.readFileSync)(path, 'utf8'));
        }
        else {
            throw Error('only .json config files are supported in ESM');
        }
    }
});
const yargsParser = function Parser(args, opts) {
    const result = parser.parse(args.slice(), opts);
    return result.argv;
};
yargsParser.detailed = function (args, opts) {
    return parser.parse(args.slice(), opts);
};
yargsParser.camelCase = _string_utils_js__WEBPACK_IMPORTED_MODULE_2__.camelCase;
yargsParser.decamelize = _string_utils_js__WEBPACK_IMPORTED_MODULE_2__.decamelize;
yargsParser.looksLikeNumber = _string_utils_js__WEBPACK_IMPORTED_MODULE_2__.looksLikeNumber;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (yargsParser);


/***/ }),

/***/ "./node_modules/yargs-parser/build/lib/string-utils.js":
/*!*************************************************************!*\
  !*** ./node_modules/yargs-parser/build/lib/string-utils.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   camelCase: () => (/* binding */ camelCase),
/* harmony export */   decamelize: () => (/* binding */ decamelize),
/* harmony export */   looksLikeNumber: () => (/* binding */ looksLikeNumber)
/* harmony export */ });
/**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
function camelCase(str) {
    // Handle the case where an argument is provided as camel case, e.g., fooBar.
    // by ensuring that the string isn't already mixed case:
    const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();
    if (!isCamelCase) {
        str = str.toLowerCase();
    }
    if (str.indexOf('-') === -1 && str.indexOf('_') === -1) {
        return str;
    }
    else {
        let camelcase = '';
        let nextChrUpper = false;
        const leadingHyphens = str.match(/^-+/);
        for (let i = leadingHyphens ? leadingHyphens[0].length : 0; i < str.length; i++) {
            let chr = str.charAt(i);
            if (nextChrUpper) {
                nextChrUpper = false;
                chr = chr.toUpperCase();
            }
            if (i !== 0 && (chr === '-' || chr === '_')) {
                nextChrUpper = true;
            }
            else if (chr !== '-' && chr !== '_') {
                camelcase += chr;
            }
        }
        return camelcase;
    }
}
function decamelize(str, joinString) {
    const lowercase = str.toLowerCase();
    joinString = joinString || '-';
    let notCamelcase = '';
    for (let i = 0; i < str.length; i++) {
        const chrLower = lowercase.charAt(i);
        const chrString = str.charAt(i);
        if (chrLower !== chrString && i > 0) {
            notCamelcase += `${joinString}${lowercase.charAt(i)}`;
        }
        else {
            notCamelcase += chrString;
        }
    }
    return notCamelcase;
}
function looksLikeNumber(x) {
    if (x === null || x === undefined)
        return false;
    // if loaded from config, may already be a number.
    if (typeof x === 'number')
        return true;
    // hexadecimal.
    if (/^0x[0-9a-f]+$/i.test(x))
        return true;
    // don't treat 0123 as a number; as it drops the leading '0'.
    if (/^0[^.]/.test(x))
        return false;
    return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}


/***/ }),

/***/ "./node_modules/yargs-parser/build/lib/tokenize-arg-string.js":
/*!********************************************************************!*\
  !*** ./node_modules/yargs-parser/build/lib/tokenize-arg-string.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tokenizeArgString: () => (/* binding */ tokenizeArgString)
/* harmony export */ });
/**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
// take an un-split argv string and tokenize it.
function tokenizeArgString(argString) {
    if (Array.isArray(argString)) {
        return argString.map(e => typeof e !== 'string' ? e + '' : e);
    }
    argString = argString.trim();
    let i = 0;
    let prevC = null;
    let c = null;
    let opening = null;
    const args = [];
    for (let ii = 0; ii < argString.length; ii++) {
        prevC = c;
        c = argString.charAt(ii);
        // split on spaces unless we're in quotes.
        if (c === ' ' && !opening) {
            if (!(prevC === ' ')) {
                i++;
            }
            continue;
        }
        // don't split the string if we're in matching
        // opening or closing single and double quotes.
        if (c === opening) {
            opening = null;
        }
        else if ((c === "'" || c === '"') && !opening) {
            opening = c;
        }
        if (!args[i])
            args[i] = '';
        args[i] += c;
    }
    return args;
}


/***/ }),

/***/ "./node_modules/yargs-parser/build/lib/yargs-parser-types.js":
/*!*******************************************************************!*\
  !*** ./node_modules/yargs-parser/build/lib/yargs-parser-types.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultValuesForTypeKey: () => (/* binding */ DefaultValuesForTypeKey)
/* harmony export */ });
/**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
var DefaultValuesForTypeKey;
(function (DefaultValuesForTypeKey) {
    DefaultValuesForTypeKey["BOOLEAN"] = "boolean";
    DefaultValuesForTypeKey["STRING"] = "string";
    DefaultValuesForTypeKey["NUMBER"] = "number";
    DefaultValuesForTypeKey["ARRAY"] = "array";
})(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));


/***/ }),

/***/ "./node_modules/yargs-parser/build/lib/yargs-parser.js":
/*!*************************************************************!*\
  !*** ./node_modules/yargs-parser/build/lib/yargs-parser.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   YargsParser: () => (/* binding */ YargsParser)
/* harmony export */ });
/* harmony import */ var _tokenize_arg_string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tokenize-arg-string.js */ "./node_modules/yargs-parser/build/lib/tokenize-arg-string.js");
/* harmony import */ var _yargs_parser_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./yargs-parser-types.js */ "./node_modules/yargs-parser/build/lib/yargs-parser-types.js");
/* harmony import */ var _string_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./string-utils.js */ "./node_modules/yargs-parser/build/lib/string-utils.js");
/**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */



let mixin;
class YargsParser {
    constructor(_mixin) {
        mixin = _mixin;
    }
    parse(argsInput, options) {
        const opts = Object.assign({
            alias: undefined,
            array: undefined,
            boolean: undefined,
            config: undefined,
            configObjects: undefined,
            configuration: undefined,
            coerce: undefined,
            count: undefined,
            default: undefined,
            envPrefix: undefined,
            narg: undefined,
            normalize: undefined,
            string: undefined,
            number: undefined,
            __: undefined,
            key: undefined
        }, options);
        // allow a string argument to be passed in rather
        // than an argv array.
        const args = (0,_tokenize_arg_string_js__WEBPACK_IMPORTED_MODULE_0__.tokenizeArgString)(argsInput);
        // tokenizeArgString adds extra quotes to args if argsInput is a string
        // only strip those extra quotes in processValue if argsInput is a string
        const inputIsString = typeof argsInput === 'string';
        // aliases might have transitive relationships, normalize this.
        const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));
        const configuration = Object.assign({
            'boolean-negation': true,
            'camel-case-expansion': true,
            'combine-arrays': false,
            'dot-notation': true,
            'duplicate-arguments-array': true,
            'flatten-duplicate-arrays': true,
            'greedy-arrays': true,
            'halt-at-non-option': false,
            'nargs-eats-options': false,
            'negation-prefix': 'no-',
            'parse-numbers': true,
            'parse-positional-numbers': true,
            'populate--': false,
            'set-placeholder-key': false,
            'short-option-groups': true,
            'strip-aliased': false,
            'strip-dashed': false,
            'unknown-options-as-args': false
        }, opts.configuration);
        const defaults = Object.assign(Object.create(null), opts.default);
        const configObjects = opts.configObjects || [];
        const envPrefix = opts.envPrefix;
        const notFlagsOption = configuration['populate--'];
        const notFlagsArgv = notFlagsOption ? '--' : '_';
        const newAliases = Object.create(null);
        const defaulted = Object.create(null);
        // allow a i18n handler to be passed in, default to a fake one (util.format).
        const __ = opts.__ || mixin.format;
        const flags = {
            aliases: Object.create(null),
            arrays: Object.create(null),
            bools: Object.create(null),
            strings: Object.create(null),
            numbers: Object.create(null),
            counts: Object.create(null),
            normalize: Object.create(null),
            configs: Object.create(null),
            nargs: Object.create(null),
            coercions: Object.create(null),
            keys: []
        };
        const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
        const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');
        [].concat(opts.array || []).filter(Boolean).forEach(function (opt) {
            const key = typeof opt === 'object' ? opt.key : opt;
            // assign to flags[bools|strings|numbers]
            const assignment = Object.keys(opt).map(function (key) {
                const arrayFlagKeys = {
                    boolean: 'bools',
                    string: 'strings',
                    number: 'numbers'
                };
                return arrayFlagKeys[key];
            }).filter(Boolean).pop();
            // assign key to be coerced
            if (assignment) {
                flags[assignment][key] = true;
            }
            flags.arrays[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.boolean || []).filter(Boolean).forEach(function (key) {
            flags.bools[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.string || []).filter(Boolean).forEach(function (key) {
            flags.strings[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.number || []).filter(Boolean).forEach(function (key) {
            flags.numbers[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.count || []).filter(Boolean).forEach(function (key) {
            flags.counts[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.normalize || []).filter(Boolean).forEach(function (key) {
            flags.normalize[key] = true;
            flags.keys.push(key);
        });
        if (typeof opts.narg === 'object') {
            Object.entries(opts.narg).forEach(([key, value]) => {
                if (typeof value === 'number') {
                    flags.nargs[key] = value;
                    flags.keys.push(key);
                }
            });
        }
        if (typeof opts.coerce === 'object') {
            Object.entries(opts.coerce).forEach(([key, value]) => {
                if (typeof value === 'function') {
                    flags.coercions[key] = value;
                    flags.keys.push(key);
                }
            });
        }
        if (typeof opts.config !== 'undefined') {
            if (Array.isArray(opts.config) || typeof opts.config === 'string') {
                ;
                [].concat(opts.config).filter(Boolean).forEach(function (key) {
                    flags.configs[key] = true;
                });
            }
            else if (typeof opts.config === 'object') {
                Object.entries(opts.config).forEach(([key, value]) => {
                    if (typeof value === 'boolean' || typeof value === 'function') {
                        flags.configs[key] = value;
                    }
                });
            }
        }
        // create a lookup table that takes into account all
        // combinations of aliases: {f: ['foo'], foo: ['f']}
        extendAliases(opts.key, aliases, opts.default, flags.arrays);
        // apply default values to all aliases.
        Object.keys(defaults).forEach(function (key) {
            (flags.aliases[key] || []).forEach(function (alias) {
                defaults[alias] = defaults[key];
            });
        });
        let error = null;
        checkConfiguration();
        let notFlags = [];
        const argv = Object.assign(Object.create(null), { _: [] });
        // TODO(bcoe): for the first pass at removing object prototype  we didn't
        // remove all prototypes from objects returned by this API, we might want
        // to gradually move towards doing so.
        const argvReturn = {};
        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            const truncatedArg = arg.replace(/^-{3,}/, '---');
            let broken;
            let key;
            let letters;
            let m;
            let next;
            let value;
            // any unknown option (except for end-of-options, "--")
            if (arg !== '--' && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {
                pushPositional(arg);
                // ---, ---=, ----, etc,
            }
            else if (truncatedArg.match(/^---+(=|$)/)) {
                // options without key name are invalid.
                pushPositional(arg);
                continue;
                // -- separated by =
            }
            else if (arg.match(/^--.+=/) || (!configuration['short-option-groups'] && arg.match(/^-.+=/))) {
                // Using [\s\S] instead of . because js doesn't support the
                // 'dotall' regex modifier. See:
                // http://stackoverflow.com/a/1068308/13216
                m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
                // arrays format = '--f=a b c'
                if (m !== null && Array.isArray(m) && m.length >= 3) {
                    if (checkAllAliases(m[1], flags.arrays)) {
                        i = eatArray(i, m[1], args, m[2]);
                    }
                    else if (checkAllAliases(m[1], flags.nargs) !== false) {
                        // nargs format = '--f=monkey washing cat'
                        i = eatNargs(i, m[1], args, m[2]);
                    }
                    else {
                        setArg(m[1], m[2], true);
                    }
                }
            }
            else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {
                m = arg.match(negatedBoolean);
                if (m !== null && Array.isArray(m) && m.length >= 2) {
                    key = m[1];
                    setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
                }
                // -- separated by space.
            }
            else if (arg.match(/^--.+/) || (!configuration['short-option-groups'] && arg.match(/^-[^-]+/))) {
                m = arg.match(/^--?(.+)/);
                if (m !== null && Array.isArray(m) && m.length >= 2) {
                    key = m[1];
                    if (checkAllAliases(key, flags.arrays)) {
                        // array format = '--foo a b c'
                        i = eatArray(i, key, args);
                    }
                    else if (checkAllAliases(key, flags.nargs) !== false) {
                        // nargs format = '--foo a b c'
                        // should be truthy even if: flags.nargs[key] === 0
                        i = eatNargs(i, key, args);
                    }
                    else {
                        next = args[i + 1];
                        if (next !== undefined && (!next.match(/^-/) ||
                            next.match(negative)) &&
                            !checkAllAliases(key, flags.bools) &&
                            !checkAllAliases(key, flags.counts)) {
                            setArg(key, next);
                            i++;
                        }
                        else if (/^(true|false)$/.test(next)) {
                            setArg(key, next);
                            i++;
                        }
                        else {
                            setArg(key, defaultValue(key));
                        }
                    }
                }
                // dot-notation flag separated by '='.
            }
            else if (arg.match(/^-.\..+=/)) {
                m = arg.match(/^-([^=]+)=([\s\S]*)$/);
                if (m !== null && Array.isArray(m) && m.length >= 3) {
                    setArg(m[1], m[2]);
                }
                // dot-notation flag separated by space.
            }
            else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
                next = args[i + 1];
                m = arg.match(/^-(.\..+)/);
                if (m !== null && Array.isArray(m) && m.length >= 2) {
                    key = m[1];
                    if (next !== undefined && !next.match(/^-/) &&
                        !checkAllAliases(key, flags.bools) &&
                        !checkAllAliases(key, flags.counts)) {
                        setArg(key, next);
                        i++;
                    }
                    else {
                        setArg(key, defaultValue(key));
                    }
                }
            }
            else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
                letters = arg.slice(1, -1).split('');
                broken = false;
                for (let j = 0; j < letters.length; j++) {
                    next = arg.slice(j + 2);
                    if (letters[j + 1] && letters[j + 1] === '=') {
                        value = arg.slice(j + 3);
                        key = letters[j];
                        if (checkAllAliases(key, flags.arrays)) {
                            // array format = '-f=a b c'
                            i = eatArray(i, key, args, value);
                        }
                        else if (checkAllAliases(key, flags.nargs) !== false) {
                            // nargs format = '-f=monkey washing cat'
                            i = eatNargs(i, key, args, value);
                        }
                        else {
                            setArg(key, value);
                        }
                        broken = true;
                        break;
                    }
                    if (next === '-') {
                        setArg(letters[j], next);
                        continue;
                    }
                    // current letter is an alphabetic character and next value is a number
                    if (/[A-Za-z]/.test(letters[j]) &&
                        /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) &&
                        checkAllAliases(next, flags.bools) === false) {
                        setArg(letters[j], next);
                        broken = true;
                        break;
                    }
                    if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                        setArg(letters[j], next);
                        broken = true;
                        break;
                    }
                    else {
                        setArg(letters[j], defaultValue(letters[j]));
                    }
                }
                key = arg.slice(-1)[0];
                if (!broken && key !== '-') {
                    if (checkAllAliases(key, flags.arrays)) {
                        // array format = '-f a b c'
                        i = eatArray(i, key, args);
                    }
                    else if (checkAllAliases(key, flags.nargs) !== false) {
                        // nargs format = '-f a b c'
                        // should be truthy even if: flags.nargs[key] === 0
                        i = eatNargs(i, key, args);
                    }
                    else {
                        next = args[i + 1];
                        if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||
                            next.match(negative)) &&
                            !checkAllAliases(key, flags.bools) &&
                            !checkAllAliases(key, flags.counts)) {
                            setArg(key, next);
                            i++;
                        }
                        else if (/^(true|false)$/.test(next)) {
                            setArg(key, next);
                            i++;
                        }
                        else {
                            setArg(key, defaultValue(key));
                        }
                    }
                }
            }
            else if (arg.match(/^-[0-9]$/) &&
                arg.match(negative) &&
                checkAllAliases(arg.slice(1), flags.bools)) {
                // single-digit boolean alias, e.g: xargs -0
                key = arg.slice(1);
                setArg(key, defaultValue(key));
            }
            else if (arg === '--') {
                notFlags = args.slice(i + 1);
                break;
            }
            else if (configuration['halt-at-non-option']) {
                notFlags = args.slice(i);
                break;
            }
            else {
                pushPositional(arg);
            }
        }
        // order of precedence:
        // 1. command line arg
        // 2. value from env var
        // 3. value from config file
        // 4. value from config objects
        // 5. configured default value
        applyEnvVars(argv, true); // special case: check env vars that point to config file
        applyEnvVars(argv, false);
        setConfig(argv);
        setConfigObjects();
        applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
        applyCoercions(argv);
        if (configuration['set-placeholder-key'])
            setPlaceholderKeys(argv);
        // for any counts either not in args or without an explicit default, set to 0
        Object.keys(flags.counts).forEach(function (key) {
            if (!hasKey(argv, key.split('.')))
                setArg(key, 0);
        });
        // '--' defaults to undefined.
        if (notFlagsOption && notFlags.length)
            argv[notFlagsArgv] = [];
        notFlags.forEach(function (key) {
            argv[notFlagsArgv].push(key);
        });
        if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {
            Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {
                delete argv[key];
            });
        }
        if (configuration['strip-aliased']) {
            ;
            [].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {
                if (configuration['camel-case-expansion'] && alias.includes('-')) {
                    delete argv[alias.split('.').map(prop => (0,_string_utils_js__WEBPACK_IMPORTED_MODULE_2__.camelCase)(prop)).join('.')];
                }
                delete argv[alias];
            });
        }
        // Push argument into positional array, applying numeric coercion:
        function pushPositional(arg) {
            const maybeCoercedNumber = maybeCoerceNumber('_', arg);
            if (typeof maybeCoercedNumber === 'string' || typeof maybeCoercedNumber === 'number') {
                argv._.push(maybeCoercedNumber);
            }
        }
        // how many arguments should we consume, based
        // on the nargs option?
        function eatNargs(i, key, args, argAfterEqualSign) {
            let ii;
            let toEat = checkAllAliases(key, flags.nargs);
            // NaN has a special meaning for the array type, indicating that one or
            // more values are expected.
            toEat = typeof toEat !== 'number' || isNaN(toEat) ? 1 : toEat;
            if (toEat === 0) {
                if (!isUndefined(argAfterEqualSign)) {
                    error = Error(__('Argument unexpected for: %s', key));
                }
                setArg(key, defaultValue(key));
                return i;
            }
            let available = isUndefined(argAfterEqualSign) ? 0 : 1;
            if (configuration['nargs-eats-options']) {
                // classic behavior, yargs eats positional and dash arguments.
                if (args.length - (i + 1) + available < toEat) {
                    error = Error(__('Not enough arguments following: %s', key));
                }
                available = toEat;
            }
            else {
                // nargs will not consume flag arguments, e.g., -abc, --foo,
                // and terminates when one is observed.
                for (ii = i + 1; ii < args.length; ii++) {
                    if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii]))
                        available++;
                    else
                        break;
                }
                if (available < toEat)
                    error = Error(__('Not enough arguments following: %s', key));
            }
            let consumed = Math.min(available, toEat);
            if (!isUndefined(argAfterEqualSign) && consumed > 0) {
                setArg(key, argAfterEqualSign);
                consumed--;
            }
            for (ii = i + 1; ii < (consumed + i + 1); ii++) {
                setArg(key, args[ii]);
            }
            return (i + consumed);
        }
        // if an option is an array, eat all non-hyphenated arguments
        // following it... YUM!
        // e.g., --foo apple banana cat becomes ["apple", "banana", "cat"]
        function eatArray(i, key, args, argAfterEqualSign) {
            let argsToSet = [];
            let next = argAfterEqualSign || args[i + 1];
            // If both array and nargs are configured, enforce the nargs count:
            const nargsCount = checkAllAliases(key, flags.nargs);
            if (checkAllAliases(key, flags.bools) && !(/^(true|false)$/.test(next))) {
                argsToSet.push(true);
            }
            else if (isUndefined(next) ||
                (isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))) {
                // for keys without value ==> argsToSet remains an empty []
                // set user default value, if available
                if (defaults[key] !== undefined) {
                    const defVal = defaults[key];
                    argsToSet = Array.isArray(defVal) ? defVal : [defVal];
                }
            }
            else {
                // value in --option=value is eaten as is
                if (!isUndefined(argAfterEqualSign)) {
                    argsToSet.push(processValue(key, argAfterEqualSign, true));
                }
                for (let ii = i + 1; ii < args.length; ii++) {
                    if ((!configuration['greedy-arrays'] && argsToSet.length > 0) ||
                        (nargsCount && typeof nargsCount === 'number' && argsToSet.length >= nargsCount))
                        break;
                    next = args[ii];
                    if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))
                        break;
                    i = ii;
                    argsToSet.push(processValue(key, next, inputIsString));
                }
            }
            // If both array and nargs are configured, create an error if less than
            // nargs positionals were found. NaN has special meaning, indicating
            // that at least one value is required (more are okay).
            if (typeof nargsCount === 'number' && ((nargsCount && argsToSet.length < nargsCount) ||
                (isNaN(nargsCount) && argsToSet.length === 0))) {
                error = Error(__('Not enough arguments following: %s', key));
            }
            setArg(key, argsToSet);
            return i;
        }
        function setArg(key, val, shouldStripQuotes = inputIsString) {
            if (/-/.test(key) && configuration['camel-case-expansion']) {
                const alias = key.split('.').map(function (prop) {
                    return (0,_string_utils_js__WEBPACK_IMPORTED_MODULE_2__.camelCase)(prop);
                }).join('.');
                addNewAlias(key, alias);
            }
            const value = processValue(key, val, shouldStripQuotes);
            const splitKey = key.split('.');
            setKey(argv, splitKey, value);
            // handle populating aliases of the full key
            if (flags.aliases[key]) {
                flags.aliases[key].forEach(function (x) {
                    const keyProperties = x.split('.');
                    setKey(argv, keyProperties, value);
                });
            }
            // handle populating aliases of the first element of the dot-notation key
            if (splitKey.length > 1 && configuration['dot-notation']) {
                ;
                (flags.aliases[splitKey[0]] || []).forEach(function (x) {
                    let keyProperties = x.split('.');
                    // expand alias with nested objects in key
                    const a = [].concat(splitKey);
                    a.shift(); // nuke the old key.
                    keyProperties = keyProperties.concat(a);
                    // populate alias only if is not already an alias of the full key
                    // (already populated above)
                    if (!(flags.aliases[key] || []).includes(keyProperties.join('.'))) {
                        setKey(argv, keyProperties, value);
                    }
                });
            }
            // Set normalize getter and setter when key is in 'normalize' but isn't an array
            if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
                const keys = [key].concat(flags.aliases[key] || []);
                keys.forEach(function (key) {
                    Object.defineProperty(argvReturn, key, {
                        enumerable: true,
                        get() {
                            return val;
                        },
                        set(value) {
                            val = typeof value === 'string' ? mixin.normalize(value) : value;
                        }
                    });
                });
            }
        }
        function addNewAlias(key, alias) {
            if (!(flags.aliases[key] && flags.aliases[key].length)) {
                flags.aliases[key] = [alias];
                newAliases[alias] = true;
            }
            if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
                addNewAlias(alias, key);
            }
        }
        function processValue(key, val, shouldStripQuotes) {
            // strings may be quoted, clean this up as we assign values.
            if (shouldStripQuotes) {
                val = stripQuotes(val);
            }
            // handle parsing boolean arguments --foo=true --bar false.
            if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
                if (typeof val === 'string')
                    val = val === 'true';
            }
            let value = Array.isArray(val)
                ? val.map(function (v) { return maybeCoerceNumber(key, v); })
                : maybeCoerceNumber(key, val);
            // increment a count given as arg (either no value or value parsed as boolean)
            if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {
                value = increment();
            }
            // Set normalized value when key is in 'normalize' and in 'arrays'
            if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
                if (Array.isArray(val))
                    value = val.map((val) => { return mixin.normalize(val); });
                else
                    value = mixin.normalize(val);
            }
            return value;
        }
        function maybeCoerceNumber(key, value) {
            if (!configuration['parse-positional-numbers'] && key === '_')
                return value;
            if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
                const shouldCoerceNumber = (0,_string_utils_js__WEBPACK_IMPORTED_MODULE_2__.looksLikeNumber)(value) && configuration['parse-numbers'] && (Number.isSafeInteger(Math.floor(parseFloat(`${value}`))));
                if (shouldCoerceNumber || (!isUndefined(value) && checkAllAliases(key, flags.numbers))) {
                    value = Number(value);
                }
            }
            return value;
        }
        // set args from config.json file, this should be
        // applied last so that defaults can be applied.
        function setConfig(argv) {
            const configLookup = Object.create(null);
            // expand defaults/aliases, in-case any happen to reference
            // the config.json file.
            applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
            Object.keys(flags.configs).forEach(function (configKey) {
                const configPath = argv[configKey] || configLookup[configKey];
                if (configPath) {
                    try {
                        let config = null;
                        const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);
                        const resolveConfig = flags.configs[configKey];
                        if (typeof resolveConfig === 'function') {
                            try {
                                config = resolveConfig(resolvedConfigPath);
                            }
                            catch (e) {
                                config = e;
                            }
                            if (config instanceof Error) {
                                error = config;
                                return;
                            }
                        }
                        else {
                            config = mixin.require(resolvedConfigPath);
                        }
                        setConfigObject(config);
                    }
                    catch (ex) {
                        // Deno will receive a PermissionDenied error if an attempt is
                        // made to load config without the --allow-read flag:
                        if (ex.name === 'PermissionDenied')
                            error = ex;
                        else if (argv[configKey])
                            error = Error(__('Invalid JSON config file: %s', configPath));
                    }
                }
            });
        }
        // set args from config object.
        // it recursively checks nested objects.
        function setConfigObject(config, prev) {
            Object.keys(config).forEach(function (key) {
                const value = config[key];
                const fullKey = prev ? prev + '.' + key : key;
                // if the value is an inner object and we have dot-notation
                // enabled, treat inner objects in config the same as
                // heavily nested dot notations (foo.bar.apple).
                if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {
                    // if the value is an object but not an array, check nested object
                    setConfigObject(value, fullKey);
                }
                else {
                    // setting arguments via CLI takes precedence over
                    // values within the config file.
                    if (!hasKey(argv, fullKey.split('.')) || (checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays'])) {
                        setArg(fullKey, value);
                    }
                }
            });
        }
        // set all config objects passed in opts
        function setConfigObjects() {
            if (typeof configObjects !== 'undefined') {
                configObjects.forEach(function (configObject) {
                    setConfigObject(configObject);
                });
            }
        }
        function applyEnvVars(argv, configOnly) {
            if (typeof envPrefix === 'undefined')
                return;
            const prefix = typeof envPrefix === 'string' ? envPrefix : '';
            const env = mixin.env();
            Object.keys(env).forEach(function (envVar) {
                if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {
                    // get array of nested keys and convert them to camel case
                    const keys = envVar.split('__').map(function (key, i) {
                        if (i === 0) {
                            key = key.substring(prefix.length);
                        }
                        return (0,_string_utils_js__WEBPACK_IMPORTED_MODULE_2__.camelCase)(key);
                    });
                    if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && !hasKey(argv, keys)) {
                        setArg(keys.join('.'), env[envVar]);
                    }
                }
            });
        }
        function applyCoercions(argv) {
            let coerce;
            const applied = new Set();
            Object.keys(argv).forEach(function (key) {
                if (!applied.has(key)) { // If we haven't already coerced this option via one of its aliases
                    coerce = checkAllAliases(key, flags.coercions);
                    if (typeof coerce === 'function') {
                        try {
                            const value = maybeCoerceNumber(key, coerce(argv[key]));
                            ([].concat(flags.aliases[key] || [], key)).forEach(ali => {
                                applied.add(ali);
                                argv[ali] = value;
                            });
                        }
                        catch (err) {
                            error = err;
                        }
                    }
                }
            });
        }
        function setPlaceholderKeys(argv) {
            flags.keys.forEach((key) => {
                // don't set placeholder keys for dot notation options 'foo.bar'.
                if (~key.indexOf('.'))
                    return;
                if (typeof argv[key] === 'undefined')
                    argv[key] = undefined;
            });
            return argv;
        }
        function applyDefaultsAndAliases(obj, aliases, defaults, canLog = false) {
            Object.keys(defaults).forEach(function (key) {
                if (!hasKey(obj, key.split('.'))) {
                    setKey(obj, key.split('.'), defaults[key]);
                    if (canLog)
                        defaulted[key] = true;
                    (aliases[key] || []).forEach(function (x) {
                        if (hasKey(obj, x.split('.')))
                            return;
                        setKey(obj, x.split('.'), defaults[key]);
                    });
                }
            });
        }
        function hasKey(obj, keys) {
            let o = obj;
            if (!configuration['dot-notation'])
                keys = [keys.join('.')];
            keys.slice(0, -1).forEach(function (key) {
                o = (o[key] || {});
            });
            const key = keys[keys.length - 1];
            if (typeof o !== 'object')
                return false;
            else
                return key in o;
        }
        function setKey(obj, keys, value) {
            let o = obj;
            if (!configuration['dot-notation'])
                keys = [keys.join('.')];
            keys.slice(0, -1).forEach(function (key) {
                // TODO(bcoe): in the next major version of yargs, switch to
                // Object.create(null) for dot notation:
                key = sanitizeKey(key);
                if (typeof o === 'object' && o[key] === undefined) {
                    o[key] = {};
                }
                if (typeof o[key] !== 'object' || Array.isArray(o[key])) {
                    // ensure that o[key] is an array, and that the last item is an empty object.
                    if (Array.isArray(o[key])) {
                        o[key].push({});
                    }
                    else {
                        o[key] = [o[key], {}];
                    }
                    // we want to update the empty object at the end of the o[key] array, so set o to that object
                    o = o[key][o[key].length - 1];
                }
                else {
                    o = o[key];
                }
            });
            // TODO(bcoe): in the next major version of yargs, switch to
            // Object.create(null) for dot notation:
            const key = sanitizeKey(keys[keys.length - 1]);
            const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);
            const isValueArray = Array.isArray(value);
            let duplicate = configuration['duplicate-arguments-array'];
            // nargs has higher priority than duplicate
            if (!duplicate && checkAllAliases(key, flags.nargs)) {
                duplicate = true;
                if ((!isUndefined(o[key]) && flags.nargs[key] === 1) || (Array.isArray(o[key]) && o[key].length === flags.nargs[key])) {
                    o[key] = undefined;
                }
            }
            if (value === increment()) {
                o[key] = increment(o[key]);
            }
            else if (Array.isArray(o[key])) {
                if (duplicate && isTypeArray && isValueArray) {
                    o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);
                }
                else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
                    o[key] = value;
                }
                else {
                    o[key] = o[key].concat([value]);
                }
            }
            else if (o[key] === undefined && isTypeArray) {
                o[key] = isValueArray ? value : [value];
            }
            else if (duplicate && !(o[key] === undefined ||
                checkAllAliases(key, flags.counts) ||
                checkAllAliases(key, flags.bools))) {
                o[key] = [o[key], value];
            }
            else {
                o[key] = value;
            }
        }
        // extend the aliases list with inferred aliases.
        function extendAliases(...args) {
            args.forEach(function (obj) {
                Object.keys(obj || {}).forEach(function (key) {
                    // short-circuit if we've already added a key
                    // to the aliases array, for example it might
                    // exist in both 'opts.default' and 'opts.key'.
                    if (flags.aliases[key])
                        return;
                    flags.aliases[key] = [].concat(aliases[key] || []);
                    // For "--option-name", also set argv.optionName
                    flags.aliases[key].concat(key).forEach(function (x) {
                        if (/-/.test(x) && configuration['camel-case-expansion']) {
                            const c = (0,_string_utils_js__WEBPACK_IMPORTED_MODULE_2__.camelCase)(x);
                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                                flags.aliases[key].push(c);
                                newAliases[c] = true;
                            }
                        }
                    });
                    // For "--optionName", also set argv['option-name']
                    flags.aliases[key].concat(key).forEach(function (x) {
                        if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {
                            const c = (0,_string_utils_js__WEBPACK_IMPORTED_MODULE_2__.decamelize)(x, '-');
                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                                flags.aliases[key].push(c);
                                newAliases[c] = true;
                            }
                        }
                    });
                    flags.aliases[key].forEach(function (x) {
                        flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {
                            return x !== y;
                        }));
                    });
                });
            });
        }
        function checkAllAliases(key, flag) {
            const toCheck = [].concat(flags.aliases[key] || [], key);
            const keys = Object.keys(flag);
            const setAlias = toCheck.find(key => keys.includes(key));
            return setAlias ? flag[setAlias] : false;
        }
        function hasAnyFlag(key) {
            const flagsKeys = Object.keys(flags);
            const toCheck = [].concat(flagsKeys.map(k => flags[k]));
            return toCheck.some(function (flag) {
                return Array.isArray(flag) ? flag.includes(key) : flag[key];
            });
        }
        function hasFlagsMatching(arg, ...patterns) {
            const toCheck = [].concat(...patterns);
            return toCheck.some(function (pattern) {
                const match = arg.match(pattern);
                return match && hasAnyFlag(match[1]);
            });
        }
        // based on a simplified version of the short flag group parsing logic
        function hasAllShortFlags(arg) {
            // if this is a negative number, or doesn't start with a single hyphen, it's not a short flag group
            if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
                return false;
            }
            let hasAllFlags = true;
            let next;
            const letters = arg.slice(1).split('');
            for (let j = 0; j < letters.length; j++) {
                next = arg.slice(j + 2);
                if (!hasAnyFlag(letters[j])) {
                    hasAllFlags = false;
                    break;
                }
                if ((letters[j + 1] && letters[j + 1] === '=') ||
                    next === '-' ||
                    (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) ||
                    (letters[j + 1] && letters[j + 1].match(/\W/))) {
                    break;
                }
            }
            return hasAllFlags;
        }
        function isUnknownOptionAsArg(arg) {
            return configuration['unknown-options-as-args'] && isUnknownOption(arg);
        }
        function isUnknownOption(arg) {
            arg = arg.replace(/^-{3,}/, '--');
            // ignore negative numbers
            if (arg.match(negative)) {
                return false;
            }
            // if this is a short option group and all of them are configured, it isn't unknown
            if (hasAllShortFlags(arg)) {
                return false;
            }
            // e.g. '--count=2'
            const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
            // e.g. '-a' or '--arg'
            const normalFlag = /^-+([^=]+?)$/;
            // e.g. '-a-'
            const flagEndingInHyphen = /^-+([^=]+?)-$/;
            // e.g. '-abc123'
            const flagEndingInDigits = /^-+([^=]+?\d+)$/;
            // e.g. '-a/usr/local'
            const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
            // check the different types of flag styles, including negatedBoolean, a pattern defined near the start of the parse method
            return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
        }
        // make a best effort to pick a default value
        // for an option based on name and type.
        function defaultValue(key) {
            if (!checkAllAliases(key, flags.bools) &&
                !checkAllAliases(key, flags.counts) &&
                `${key}` in defaults) {
                return defaults[key];
            }
            else {
                return defaultForType(guessType(key));
            }
        }
        // return a default value, given the type of a flag.,
        function defaultForType(type) {
            const def = {
                [_yargs_parser_types_js__WEBPACK_IMPORTED_MODULE_1__.DefaultValuesForTypeKey.BOOLEAN]: true,
                [_yargs_parser_types_js__WEBPACK_IMPORTED_MODULE_1__.DefaultValuesForTypeKey.STRING]: '',
                [_yargs_parser_types_js__WEBPACK_IMPORTED_MODULE_1__.DefaultValuesForTypeKey.NUMBER]: undefined,
                [_yargs_parser_types_js__WEBPACK_IMPORTED_MODULE_1__.DefaultValuesForTypeKey.ARRAY]: []
            };
            return def[type];
        }
        // given a flag, enforce a default type.
        function guessType(key) {
            let type = _yargs_parser_types_js__WEBPACK_IMPORTED_MODULE_1__.DefaultValuesForTypeKey.BOOLEAN;
            if (checkAllAliases(key, flags.strings))
                type = _yargs_parser_types_js__WEBPACK_IMPORTED_MODULE_1__.DefaultValuesForTypeKey.STRING;
            else if (checkAllAliases(key, flags.numbers))
                type = _yargs_parser_types_js__WEBPACK_IMPORTED_MODULE_1__.DefaultValuesForTypeKey.NUMBER;
            else if (checkAllAliases(key, flags.bools))
                type = _yargs_parser_types_js__WEBPACK_IMPORTED_MODULE_1__.DefaultValuesForTypeKey.BOOLEAN;
            else if (checkAllAliases(key, flags.arrays))
                type = _yargs_parser_types_js__WEBPACK_IMPORTED_MODULE_1__.DefaultValuesForTypeKey.ARRAY;
            return type;
        }
        function isUndefined(num) {
            return num === undefined;
        }
        // check user configuration settings for inconsistencies
        function checkConfiguration() {
            // count keys should not be set as array/narg
            Object.keys(flags.counts).find(key => {
                if (checkAllAliases(key, flags.arrays)) {
                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));
                    return true;
                }
                else if (checkAllAliases(key, flags.nargs)) {
                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));
                    return true;
                }
                return false;
            });
        }
        return {
            aliases: Object.assign({}, flags.aliases),
            argv: Object.assign(argvReturn, argv),
            configuration: configuration,
            defaulted: Object.assign({}, defaulted),
            error: error,
            newAliases: Object.assign({}, newAliases)
        };
    }
}
// if any aliases reference each other, we should
// merge them together.
function combineAliases(aliases) {
    const aliasArrays = [];
    const combined = Object.create(null);
    let change = true;
    // turn alias lookup hash {key: ['alias1', 'alias2']} into
    // a simple array ['key', 'alias1', 'alias2']
    Object.keys(aliases).forEach(function (key) {
        aliasArrays.push([].concat(aliases[key], key));
    });
    // combine arrays until zero changes are
    // made in an iteration.
    while (change) {
        change = false;
        for (let i = 0; i < aliasArrays.length; i++) {
            for (let ii = i + 1; ii < aliasArrays.length; ii++) {
                const intersect = aliasArrays[i].filter(function (v) {
                    return aliasArrays[ii].indexOf(v) !== -1;
                });
                if (intersect.length) {
                    aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
                    aliasArrays.splice(ii, 1);
                    change = true;
                    break;
                }
            }
        }
    }
    // map arrays back to the hash-lookup (de-dupe while
    // we're at it).
    aliasArrays.forEach(function (aliasArray) {
        aliasArray = aliasArray.filter(function (v, i, self) {
            return self.indexOf(v) === i;
        });
        const lastAlias = aliasArray.pop();
        if (lastAlias !== undefined && typeof lastAlias === 'string') {
            combined[lastAlias] = aliasArray;
        }
    });
    return combined;
}
// this function should only be called when a count is given as an arg
// it is NOT called to set a default value
// thus we can start the count at 1 instead of 0
function increment(orig) {
    return orig !== undefined ? orig + 1 : 1;
}
// TODO(bcoe): in the next major version of yargs, switch to
// Object.create(null) for dot notation:
function sanitizeKey(key) {
    if (key === '__proto__')
        return '___proto___';
    return key;
}
function stripQuotes(val) {
    return (typeof val === 'string' &&
        (val[0] === "'" || val[0] === '"') &&
        val[val.length - 1] === val[0])
        ? val.substring(1, val.length - 1)
        : val;
}


/***/ }),

/***/ "./node_modules/yargs/build/lib/utils/apply-extends.js":
/*!*************************************************************!*\
  !*** ./node_modules/yargs/build/lib/utils/apply-extends.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyExtends: () => (/* binding */ applyExtends)
/* harmony export */ });
/* harmony import */ var _yerror_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../yerror.js */ "./node_modules/yargs/build/lib/yerror.js");

let previouslyVisitedConfigs = [];
let shim;
function applyExtends(config, cwd, mergeExtends, _shim) {
    shim = _shim;
    let defaultConfig = {};
    if (Object.prototype.hasOwnProperty.call(config, 'extends')) {
        if (typeof config.extends !== 'string')
            return defaultConfig;
        const isPath = /\.json|\..*rc$/.test(config.extends);
        let pathToDefault = null;
        if (!isPath) {
            try {
                pathToDefault = require.resolve(config.extends);
            }
            catch (_err) {
                return config;
            }
        }
        else {
            pathToDefault = getPathToDefaultConfig(cwd, config.extends);
        }
        checkForCircularExtends(pathToDefault);
        previouslyVisitedConfigs.push(pathToDefault);
        defaultConfig = isPath
            ? JSON.parse(shim.readFileSync(pathToDefault, 'utf8'))
            : require(config.extends);
        delete config.extends;
        defaultConfig = applyExtends(defaultConfig, shim.path.dirname(pathToDefault), mergeExtends, shim);
    }
    previouslyVisitedConfigs = [];
    return mergeExtends
        ? mergeDeep(defaultConfig, config)
        : Object.assign({}, defaultConfig, config);
}
function checkForCircularExtends(cfgPath) {
    if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {
        throw new _yerror_js__WEBPACK_IMPORTED_MODULE_0__.YError(`Circular extended configurations: '${cfgPath}'.`);
    }
}
function getPathToDefaultConfig(cwd, pathToExtend) {
    return shim.path.resolve(cwd, pathToExtend);
}
function mergeDeep(config1, config2) {
    const target = {};
    function isObject(obj) {
        return obj && typeof obj === 'object' && !Array.isArray(obj);
    }
    Object.assign(target, config1);
    for (const key of Object.keys(config2)) {
        if (isObject(config2[key]) && isObject(target[key])) {
            target[key] = mergeDeep(config1[key], config2[key]);
        }
        else {
            target[key] = config2[key];
        }
    }
    return target;
}


/***/ }),

/***/ "./node_modules/yargs/build/lib/utils/process-argv.js":
/*!************************************************************!*\
  !*** ./node_modules/yargs/build/lib/utils/process-argv.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getProcessArgvBin: () => (/* binding */ getProcessArgvBin),
/* harmony export */   hideBin: () => (/* binding */ hideBin)
/* harmony export */ });
function getProcessArgvBinIndex() {
    if (isBundledElectronApp())
        return 0;
    return 1;
}
function isBundledElectronApp() {
    return isElectronApp() && !process.defaultApp;
}
function isElectronApp() {
    return !!process.versions.electron;
}
function hideBin(argv) {
    return argv.slice(getProcessArgvBinIndex() + 1);
}
function getProcessArgvBin() {
    return process.argv[getProcessArgvBinIndex()];
}


/***/ }),

/***/ "./node_modules/yargs/build/lib/yerror.js":
/*!************************************************!*\
  !*** ./node_modules/yargs/build/lib/yerror.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   YError: () => (/* binding */ YError)
/* harmony export */ });
class YError extends Error {
    constructor(msg) {
        super(msg || 'yargs error');
        this.name = 'YError';
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, YError);
        }
    }
}


/***/ }),

/***/ "./node_modules/yargs/lib/platform-shims/esm.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/yargs/lib/platform-shims/esm.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! assert */ "assert");
/* harmony import */ var cliui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cliui */ "./node_modules/cliui/index.mjs");
/* harmony import */ var escalade_sync__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! escalade/sync */ "./node_modules/escalade/sync/index.mjs");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ "util");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! url */ "url");
/* harmony import */ var yargs_parser__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! yargs-parser */ "./node_modules/yargs-parser/build/lib/index.js");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var _build_lib_utils_process_argv_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../build/lib/utils/process-argv.js */ "./node_modules/yargs/build/lib/utils/process-argv.js");
/* harmony import */ var _build_lib_yerror_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../build/lib/yerror.js */ "./node_modules/yargs/build/lib/yerror.js");
/* harmony import */ var y18n__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! y18n */ "./node_modules/y18n/index.mjs");


;











const REQUIRE_ERROR = 'require is not supported by ESM'
const REQUIRE_DIRECTORY_ERROR = 'loading a directory of commands is not supported yet for ESM'

let __dirname;
try {
  __dirname = (0,url__WEBPACK_IMPORTED_MODULE_5__.fileURLToPath)("file:///Users/iin-yong/Project/Evolution/fake-evo/fake-node/node_modules/yargs/lib/platform-shims/esm.mjs");
} catch (e) {
  __dirname = process.cwd();
}
const mainFilename = __dirname.substring(0, __dirname.lastIndexOf('node_modules'));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  assert: {
    notStrictEqual: assert__WEBPACK_IMPORTED_MODULE_0__.notStrictEqual,
    strictEqual: assert__WEBPACK_IMPORTED_MODULE_0__.strictEqual
  },
  cliui: cliui__WEBPACK_IMPORTED_MODULE_1__["default"],
  findUp: escalade_sync__WEBPACK_IMPORTED_MODULE_2__["default"],
  getEnv: (key) => {
    return ({"STAGE_ENV":"lemon"})[key]
  },
  inspect: util__WEBPACK_IMPORTED_MODULE_3__.inspect,
  getCallerFile: () => {
    throw new _build_lib_yerror_js__WEBPACK_IMPORTED_MODULE_9__.YError(REQUIRE_DIRECTORY_ERROR)
  },
  getProcessArgvBin: _build_lib_utils_process_argv_js__WEBPACK_IMPORTED_MODULE_8__.getProcessArgvBin,
  mainFilename: mainFilename || process.cwd(),
  Parser: yargs_parser__WEBPACK_IMPORTED_MODULE_6__["default"],
  path: {
    basename: path__WEBPACK_IMPORTED_MODULE_7__.basename,
    dirname: path__WEBPACK_IMPORTED_MODULE_7__.dirname,
    extname: path__WEBPACK_IMPORTED_MODULE_7__.extname,
    relative: path__WEBPACK_IMPORTED_MODULE_7__.relative,
    resolve: path__WEBPACK_IMPORTED_MODULE_7__.resolve
  },
  process: {
    argv: () => process.argv,
    cwd: process.cwd,
    emitWarning: (warning, type) => process.emitWarning(warning, type),
    execPath: () => process.execPath,
    exit: process.exit,
    nextTick: process.nextTick,
    stdColumns: typeof process.stdout.columns !== 'undefined' ? process.stdout.columns : null
  },
  readFileSync: fs__WEBPACK_IMPORTED_MODULE_4__.readFileSync,
  require: () => {
    throw new _build_lib_yerror_js__WEBPACK_IMPORTED_MODULE_9__.YError(REQUIRE_ERROR)
  },
  requireDirectory: () => {
    throw new _build_lib_yerror_js__WEBPACK_IMPORTED_MODULE_9__.YError(REQUIRE_DIRECTORY_ERROR)
  },
  stringWidth: (str) => {
    return [...str].length
  },
  y18n: (0,y18n__WEBPACK_IMPORTED_MODULE_10__["default"])({
    directory: (0,path__WEBPACK_IMPORTED_MODULE_7__.resolve)(__dirname, '../../../locales'),
    updateFiles: false
  })
});


/***/ })

};
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfeWFyZ3NfYnVpbGRfbGliX3V0aWxzX2FwcGx5LWV4dGVuZHNfanMtbm9kZV9tb2R1bGVzX3lhcmdzX2xpYl9wbGF0Zm9ybS1zLTk3OTNhNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRLFVBQVU7QUFDMUMsOERBQThEO0FBQzlELDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLFlBQVk7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsVUFBVSxLQUFLO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYztBQUNkO0FBQ0EsY0FBYyx3REFBTTtBQUNwQixHQUFHO0FBQ0g7QUFDQSxjQUFjLHdEQUFNO0FBQ3BCLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILFFBQVEsaURBQUk7QUFDWixlQUFlLDZDQUFPO0FBQ3RCO0FBQ0EsR0FBRztBQUNILENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYWtlLW5vZGUvLi9ub2RlX21vZHVsZXMvY2xpdWkvYnVpbGQvbGliL2luZGV4LmpzIiwid2VicGFjazovL2Zha2Utbm9kZS8uL25vZGVfbW9kdWxlcy9jbGl1aS9idWlsZC9saWIvc3RyaW5nLXV0aWxzLmpzIiwid2VicGFjazovL2Zha2Utbm9kZS8uL25vZGVfbW9kdWxlcy9jbGl1aS9pbmRleC5tanMiLCJ3ZWJwYWNrOi8vZmFrZS1ub2RlLy4vbm9kZV9tb2R1bGVzL2VzY2FsYWRlL3N5bmMvaW5kZXgubWpzIiwid2VicGFjazovL2Zha2Utbm9kZS8uL25vZGVfbW9kdWxlcy95MThuL2J1aWxkL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9mYWtlLW5vZGUvLi9ub2RlX21vZHVsZXMveTE4bi9idWlsZC9saWIvcGxhdGZvcm0tc2hpbXMvbm9kZS5qcyIsIndlYnBhY2s6Ly9mYWtlLW5vZGUvLi9ub2RlX21vZHVsZXMveTE4bi9pbmRleC5tanMiLCJ3ZWJwYWNrOi8vZmFrZS1ub2RlLy4vbm9kZV9tb2R1bGVzL3lhcmdzLXBhcnNlci9idWlsZC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmFrZS1ub2RlLy4vbm9kZV9tb2R1bGVzL3lhcmdzLXBhcnNlci9idWlsZC9saWIvc3RyaW5nLXV0aWxzLmpzIiwid2VicGFjazovL2Zha2Utbm9kZS8uL25vZGVfbW9kdWxlcy95YXJncy1wYXJzZXIvYnVpbGQvbGliL3Rva2VuaXplLWFyZy1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vZmFrZS1ub2RlLy4vbm9kZV9tb2R1bGVzL3lhcmdzLXBhcnNlci9idWlsZC9saWIveWFyZ3MtcGFyc2VyLXR5cGVzLmpzIiwid2VicGFjazovL2Zha2Utbm9kZS8uL25vZGVfbW9kdWxlcy95YXJncy1wYXJzZXIvYnVpbGQvbGliL3lhcmdzLXBhcnNlci5qcyIsIndlYnBhY2s6Ly9mYWtlLW5vZGUvLi9ub2RlX21vZHVsZXMveWFyZ3MvYnVpbGQvbGliL3V0aWxzL2FwcGx5LWV4dGVuZHMuanMiLCJ3ZWJwYWNrOi8vZmFrZS1ub2RlLy4vbm9kZV9tb2R1bGVzL3lhcmdzL2J1aWxkL2xpYi91dGlscy9wcm9jZXNzLWFyZ3YuanMiLCJ3ZWJwYWNrOi8vZmFrZS1ub2RlLy4vbm9kZV9tb2R1bGVzL3lhcmdzL2J1aWxkL2xpYi95ZXJyb3IuanMiLCJ3ZWJwYWNrOi8vZmFrZS1ub2RlLy4vbm9kZV9tb2R1bGVzL3lhcmdzL2xpYi9wbGF0Zm9ybS1zaGltcy9lc20ubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGFsaWduID0ge1xuICAgIHJpZ2h0OiBhbGlnblJpZ2h0LFxuICAgIGNlbnRlcjogYWxpZ25DZW50ZXJcbn07XG5jb25zdCB0b3AgPSAwO1xuY29uc3QgcmlnaHQgPSAxO1xuY29uc3QgYm90dG9tID0gMjtcbmNvbnN0IGxlZnQgPSAzO1xuZXhwb3J0IGNsYXNzIFVJIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy53aWR0aCA9IG9wdHMud2lkdGg7XG4gICAgICAgIHRoaXMud3JhcCA9IChfYSA9IG9wdHMud3JhcCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZTtcbiAgICAgICAgdGhpcy5yb3dzID0gW107XG4gICAgfVxuICAgIHNwYW4oLi4uYXJncykge1xuICAgICAgICBjb25zdCBjb2xzID0gdGhpcy5kaXYoLi4uYXJncyk7XG4gICAgICAgIGNvbHMuc3BhbiA9IHRydWU7XG4gICAgfVxuICAgIHJlc2V0T3V0cHV0KCkge1xuICAgICAgICB0aGlzLnJvd3MgPSBbXTtcbiAgICB9XG4gICAgZGl2KC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRpdignJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMud3JhcCAmJiB0aGlzLnNob3VsZEFwcGx5TGF5b3V0RFNMKC4uLmFyZ3MpICYmIHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlMYXlvdXREU0woYXJnc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29scyA9IGFyZ3MubWFwKGFyZyA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2xGcm9tU3RyaW5nKGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yb3dzLnB1c2goY29scyk7XG4gICAgICAgIHJldHVybiBjb2xzO1xuICAgIH1cbiAgICBzaG91bGRBcHBseUxheW91dERTTCguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIC9bXFx0XFxuXS8udGVzdChhcmdzWzBdKTtcbiAgICB9XG4gICAgYXBwbHlMYXlvdXREU0woc3RyKSB7XG4gICAgICAgIGNvbnN0IHJvd3MgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChyb3cgPT4gcm93LnNwbGl0KCdcXHQnKSk7XG4gICAgICAgIGxldCBsZWZ0Q29sdW1uV2lkdGggPSAwO1xuICAgICAgICAvLyBzaW1wbGUgaGV1cmlzdGljIGZvciBsYXlvdXQsIG1ha2Ugc3VyZSB0aGVcbiAgICAgICAgLy8gc2Vjb25kIGNvbHVtbiBsaW5lcyB1cCBhbG9uZyB0aGUgbGVmdC1oYW5kLlxuICAgICAgICAvLyBkb24ndCBhbGxvdyB0aGUgZmlyc3QgY29sdW1uIHRvIHRha2UgdXAgbW9yZVxuICAgICAgICAvLyB0aGFuIDUwJSBvZiB0aGUgc2NyZWVuLlxuICAgICAgICByb3dzLmZvckVhY2goY29sdW1ucyA9PiB7XG4gICAgICAgICAgICBpZiAoY29sdW1ucy5sZW5ndGggPiAxICYmIG1peGluLnN0cmluZ1dpZHRoKGNvbHVtbnNbMF0pID4gbGVmdENvbHVtbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgbGVmdENvbHVtbldpZHRoID0gTWF0aC5taW4oTWF0aC5mbG9vcih0aGlzLndpZHRoICogMC41KSwgbWl4aW4uc3RyaW5nV2lkdGgoY29sdW1uc1swXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZ2VuZXJhdGUgYSB0YWJsZTpcbiAgICAgICAgLy8gIHJlcGxhY2luZyAnICcgd2l0aCBwYWRkaW5nIGNhbGN1bGF0aW9ucy5cbiAgICAgICAgLy8gIHVzaW5nIHRoZSBhbGdvcml0aG1pY2FsbHkgZ2VuZXJhdGVkIHdpZHRoLlxuICAgICAgICByb3dzLmZvckVhY2goY29sdW1ucyA9PiB7XG4gICAgICAgICAgICB0aGlzLmRpdiguLi5jb2x1bW5zLm1hcCgociwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHIudHJpbSgpLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiB0aGlzLm1lYXN1cmVQYWRkaW5nKHIpLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogKGkgPT09IDAgJiYgY29sdW1ucy5sZW5ndGggPiAxKSA/IGxlZnRDb2x1bW5XaWR0aCA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dzW3RoaXMucm93cy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgY29sRnJvbVN0cmluZyh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgcGFkZGluZzogdGhpcy5tZWFzdXJlUGFkZGluZyh0ZXh0KVxuICAgICAgICB9O1xuICAgIH1cbiAgICBtZWFzdXJlUGFkZGluZyhzdHIpIHtcbiAgICAgICAgLy8gbWVhc3VyZSBwYWRkaW5nIHdpdGhvdXQgYW5zaSBlc2NhcGUgY29kZXNcbiAgICAgICAgY29uc3Qgbm9BbnNpID0gbWl4aW4uc3RyaXBBbnNpKHN0cik7XG4gICAgICAgIHJldHVybiBbMCwgbm9BbnNpLm1hdGNoKC9cXHMqJC8pWzBdLmxlbmd0aCwgMCwgbm9BbnNpLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aF07XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBsaW5lcyA9IFtdO1xuICAgICAgICB0aGlzLnJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICAgICAgdGhpcy5yb3dUb1N0cmluZyhyb3csIGxpbmVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGRvbid0IGRpc3BsYXkgYW55IGxpbmVzIHdpdGggdGhlXG4gICAgICAgIC8vIGhpZGRlbiBmbGFnIHNldC5cbiAgICAgICAgcmV0dXJuIGxpbmVzXG4gICAgICAgICAgICAuZmlsdGVyKGxpbmUgPT4gIWxpbmUuaGlkZGVuKVxuICAgICAgICAgICAgLm1hcChsaW5lID0+IGxpbmUudGV4dClcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgcm93VG9TdHJpbmcocm93LCBsaW5lcykge1xuICAgICAgICB0aGlzLnJhc3Rlcml6ZShyb3cpLmZvckVhY2goKHJyb3csIHIpID0+IHtcbiAgICAgICAgICAgIGxldCBzdHIgPSAnJztcbiAgICAgICAgICAgIHJyb3cuZm9yRWFjaCgoY29sLCBjKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB3aWR0aCB9ID0gcm93W2NdOyAvLyB0aGUgd2lkdGggd2l0aCBwYWRkaW5nLlxuICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBXaWR0aCA9IHRoaXMubmVnYXRlUGFkZGluZyhyb3dbY10pOyAvLyB0aGUgd2lkdGggd2l0aG91dCBwYWRkaW5nLlxuICAgICAgICAgICAgICAgIGxldCB0cyA9IGNvbDsgLy8gdGVtcG9yYXJ5IHN0cmluZyB1c2VkIGR1cmluZyBhbGlnbm1lbnQvcGFkZGluZy5cbiAgICAgICAgICAgICAgICBpZiAod3JhcFdpZHRoID4gbWl4aW4uc3RyaW5nV2lkdGgoY29sKSkge1xuICAgICAgICAgICAgICAgICAgICB0cyArPSAnICcucmVwZWF0KHdyYXBXaWR0aCAtIG1peGluLnN0cmluZ1dpZHRoKGNvbCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhbGlnbiB0aGUgc3RyaW5nIHdpdGhpbiBpdHMgY29sdW1uLlxuICAgICAgICAgICAgICAgIGlmIChyb3dbY10uYWxpZ24gJiYgcm93W2NdLmFsaWduICE9PSAnbGVmdCcgJiYgdGhpcy53cmFwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZuID0gYWxpZ25bcm93W2NdLmFsaWduXTtcbiAgICAgICAgICAgICAgICAgICAgdHMgPSBmbih0cywgd3JhcFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1peGluLnN0cmluZ1dpZHRoKHRzKSA8IHdyYXBXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHMgKz0gJyAnLnJlcGVhdCgod2lkdGggfHwgMCkgLSBtaXhpbi5zdHJpbmdXaWR0aCh0cykgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhcHBseSBib3JkZXIgYW5kIHBhZGRpbmcgdG8gc3RyaW5nLlxuICAgICAgICAgICAgICAgIGNvbnN0IHBhZGRpbmcgPSByb3dbY10ucGFkZGluZyB8fCBbMCwgMCwgMCwgMF07XG4gICAgICAgICAgICAgICAgaWYgKHBhZGRpbmdbbGVmdF0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyICs9ICcgJy5yZXBlYXQocGFkZGluZ1tsZWZ0XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0ciArPSBhZGRCb3JkZXIocm93W2NdLCB0cywgJ3wgJyk7XG4gICAgICAgICAgICAgICAgc3RyICs9IHRzO1xuICAgICAgICAgICAgICAgIHN0ciArPSBhZGRCb3JkZXIocm93W2NdLCB0cywgJyB8Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHBhZGRpbmdbcmlnaHRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSAnICcucmVwZWF0KHBhZGRpbmdbcmlnaHRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgcHJpb3Igcm93IGlzIHNwYW4sIHRyeSB0byByZW5kZXIgdGhlXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCByb3cgb24gdGhlIHByaW9yIGxpbmUuXG4gICAgICAgICAgICAgICAgaWYgKHIgPT09IDAgJiYgbGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSB0aGlzLnJlbmRlcklubGluZShzdHIsIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgbGluZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgdGV4dDogc3RyLnJlcGxhY2UoLyArJC8sICcnKSxcbiAgICAgICAgICAgICAgICBzcGFuOiByb3cuc3BhblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgfVxuICAgIC8vIGlmIHRoZSBmdWxsICdzb3VyY2UnIGNhbiByZW5kZXIgaW5cbiAgICAvLyB0aGUgdGFyZ2V0IGxpbmUsIGRvIHNvLlxuICAgIHJlbmRlcklubGluZShzb3VyY2UsIHByZXZpb3VzTGluZSkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHNvdXJjZS5tYXRjaCgvXiAqLyk7XG4gICAgICAgIGNvbnN0IGxlYWRpbmdXaGl0ZXNwYWNlID0gbWF0Y2ggPyBtYXRjaFswXS5sZW5ndGggOiAwO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBwcmV2aW91c0xpbmUudGV4dDtcbiAgICAgICAgY29uc3QgdGFyZ2V0VGV4dFdpZHRoID0gbWl4aW4uc3RyaW5nV2lkdGgodGFyZ2V0LnRyaW1SaWdodCgpKTtcbiAgICAgICAgaWYgKCFwcmV2aW91c0xpbmUuc3Bhbikge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSdyZSBub3QgYXBwbHlpbmcgd3JhcHBpbmcgbG9naWMsXG4gICAgICAgIC8vIGp1c3QgYWx3YXlzIGFwcGVuZCB0byB0aGUgc3Bhbi5cbiAgICAgICAgaWYgKCF0aGlzLndyYXApIHtcbiAgICAgICAgICAgIHByZXZpb3VzTGluZS5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldCArIHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVhZGluZ1doaXRlc3BhY2UgPCB0YXJnZXRUZXh0V2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNMaW5lLmhpZGRlbiA9IHRydWU7XG4gICAgICAgIHJldHVybiB0YXJnZXQudHJpbVJpZ2h0KCkgKyAnICcucmVwZWF0KGxlYWRpbmdXaGl0ZXNwYWNlIC0gdGFyZ2V0VGV4dFdpZHRoKSArIHNvdXJjZS50cmltTGVmdCgpO1xuICAgIH1cbiAgICByYXN0ZXJpemUocm93KSB7XG4gICAgICAgIGNvbnN0IHJyb3dzID0gW107XG4gICAgICAgIGNvbnN0IHdpZHRocyA9IHRoaXMuY29sdW1uV2lkdGhzKHJvdyk7XG4gICAgICAgIGxldCB3cmFwcGVkO1xuICAgICAgICAvLyB3b3JkIHdyYXAgYWxsIGNvbHVtbnMsIGFuZCBjcmVhdGVcbiAgICAgICAgLy8gYSBkYXRhLXN0cnVjdHVyZSB0aGF0IGlzIGVhc3kgdG8gcmFzdGVyaXplLlxuICAgICAgICByb3cuZm9yRWFjaCgoY29sLCBjKSA9PiB7XG4gICAgICAgICAgICAvLyBsZWF2ZSByb29tIGZvciBsZWZ0IGFuZCByaWdodCBwYWRkaW5nLlxuICAgICAgICAgICAgY29sLndpZHRoID0gd2lkdGhzW2NdO1xuICAgICAgICAgICAgaWYgKHRoaXMud3JhcCkge1xuICAgICAgICAgICAgICAgIHdyYXBwZWQgPSBtaXhpbi53cmFwKGNvbC50ZXh0LCB0aGlzLm5lZ2F0ZVBhZGRpbmcoY29sKSwgeyBoYXJkOiB0cnVlIH0pLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdyYXBwZWQgPSBjb2wudGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sLmJvcmRlcikge1xuICAgICAgICAgICAgICAgIHdyYXBwZWQudW5zaGlmdCgnLicgKyAnLScucmVwZWF0KHRoaXMubmVnYXRlUGFkZGluZyhjb2wpICsgMikgKyAnLicpO1xuICAgICAgICAgICAgICAgIHdyYXBwZWQucHVzaChcIidcIiArICctJy5yZXBlYXQodGhpcy5uZWdhdGVQYWRkaW5nKGNvbCkgKyAyKSArIFwiJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCB0b3AgYW5kIGJvdHRvbSBwYWRkaW5nLlxuICAgICAgICAgICAgaWYgKGNvbC5wYWRkaW5nKSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlZC51bnNoaWZ0KC4uLm5ldyBBcnJheShjb2wucGFkZGluZ1t0b3BdIHx8IDApLmZpbGwoJycpKTtcbiAgICAgICAgICAgICAgICB3cmFwcGVkLnB1c2goLi4ubmV3IEFycmF5KGNvbC5wYWRkaW5nW2JvdHRvbV0gfHwgMCkuZmlsbCgnJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JhcHBlZC5mb3JFYWNoKChzdHIsIHIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJyb3dzW3JdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJyb3dzLnB1c2goW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBycm93ID0gcnJvd3Nbcl07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJyb3dbaV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnJvdy5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBycm93LnB1c2goc3RyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJyb3dzO1xuICAgIH1cbiAgICBuZWdhdGVQYWRkaW5nKGNvbCkge1xuICAgICAgICBsZXQgd3JhcFdpZHRoID0gY29sLndpZHRoIHx8IDA7XG4gICAgICAgIGlmIChjb2wucGFkZGluZykge1xuICAgICAgICAgICAgd3JhcFdpZHRoIC09IChjb2wucGFkZGluZ1tsZWZ0XSB8fCAwKSArIChjb2wucGFkZGluZ1tyaWdodF0gfHwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbC5ib3JkZXIpIHtcbiAgICAgICAgICAgIHdyYXBXaWR0aCAtPSA0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cmFwV2lkdGg7XG4gICAgfVxuICAgIGNvbHVtbldpZHRocyhyb3cpIHtcbiAgICAgICAgaWYgKCF0aGlzLndyYXApIHtcbiAgICAgICAgICAgIHJldHVybiByb3cubWFwKGNvbCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbC53aWR0aCB8fCBtaXhpbi5zdHJpbmdXaWR0aChjb2wudGV4dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdW5zZXQgPSByb3cubGVuZ3RoO1xuICAgICAgICBsZXQgcmVtYWluaW5nV2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICAvLyBjb2x1bW4gd2lkdGhzIGNhbiBiZSBzZXQgaW4gY29uZmlnLlxuICAgICAgICBjb25zdCB3aWR0aHMgPSByb3cubWFwKGNvbCA9PiB7XG4gICAgICAgICAgICBpZiAoY29sLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgdW5zZXQtLTtcbiAgICAgICAgICAgICAgICByZW1haW5pbmdXaWR0aCAtPSBjb2wud2lkdGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbC53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBhbnkgdW5zZXQgd2lkdGhzIHNob3VsZCBiZSBjYWxjdWxhdGVkLlxuICAgICAgICBjb25zdCB1bnNldFdpZHRoID0gdW5zZXQgPyBNYXRoLmZsb29yKHJlbWFpbmluZ1dpZHRoIC8gdW5zZXQpIDogMDtcbiAgICAgICAgcmV0dXJuIHdpZHRocy5tYXAoKHcsIGkpID0+IHtcbiAgICAgICAgICAgIGlmICh3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodW5zZXRXaWR0aCwgX21pbldpZHRoKHJvd1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZEJvcmRlcihjb2wsIHRzLCBzdHlsZSkge1xuICAgIGlmIChjb2wuYm9yZGVyKSB7XG4gICAgICAgIGlmICgvWy4nXS0rWy4nXS8udGVzdCh0cykpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHMudHJpbSgpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnICAnO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG4vLyBjYWxjdWxhdGVzIHRoZSBtaW5pbXVtIHdpZHRoIG9mXG4vLyBhIGNvbHVtbiwgYmFzZWQgb24gcGFkZGluZyBwcmVmZXJlbmNlcy5cbmZ1bmN0aW9uIF9taW5XaWR0aChjb2wpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gY29sLnBhZGRpbmcgfHwgW107XG4gICAgY29uc3QgbWluV2lkdGggPSAxICsgKHBhZGRpbmdbbGVmdF0gfHwgMCkgKyAocGFkZGluZ1tyaWdodF0gfHwgMCk7XG4gICAgaWYgKGNvbC5ib3JkZXIpIHtcbiAgICAgICAgcmV0dXJuIG1pbldpZHRoICsgNDtcbiAgICB9XG4gICAgcmV0dXJuIG1pbldpZHRoO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93V2lkdGgoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGRlcGVuZHMgb24gdGVybWluYWwgKi9cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3Muc3Rkb3V0ICYmIHByb2Nlc3Muc3Rkb3V0LmNvbHVtbnMpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3Muc3Rkb3V0LmNvbHVtbnM7XG4gICAgfVxuICAgIHJldHVybiA4MDtcbn1cbmZ1bmN0aW9uIGFsaWduUmlnaHQoc3RyLCB3aWR0aCkge1xuICAgIHN0ciA9IHN0ci50cmltKCk7XG4gICAgY29uc3Qgc3RyV2lkdGggPSBtaXhpbi5zdHJpbmdXaWR0aChzdHIpO1xuICAgIGlmIChzdHJXaWR0aCA8IHdpZHRoKSB7XG4gICAgICAgIHJldHVybiAnICcucmVwZWF0KHdpZHRoIC0gc3RyV2lkdGgpICsgc3RyO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gYWxpZ25DZW50ZXIoc3RyLCB3aWR0aCkge1xuICAgIHN0ciA9IHN0ci50cmltKCk7XG4gICAgY29uc3Qgc3RyV2lkdGggPSBtaXhpbi5zdHJpbmdXaWR0aChzdHIpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHN0cldpZHRoID49IHdpZHRoKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHJldHVybiAnICcucmVwZWF0KCh3aWR0aCAtIHN0cldpZHRoKSA+PiAxKSArIHN0cjtcbn1cbmxldCBtaXhpbjtcbmV4cG9ydCBmdW5jdGlvbiBjbGl1aShvcHRzLCBfbWl4aW4pIHtcbiAgICBtaXhpbiA9IF9taXhpbjtcbiAgICByZXR1cm4gbmV3IFVJKHtcbiAgICAgICAgd2lkdGg6IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMud2lkdGgpIHx8IGdldFdpbmRvd1dpZHRoKCksXG4gICAgICAgIHdyYXA6IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy53cmFwXG4gICAgfSk7XG59XG4iLCIvLyBNaW5pbWFsIHJlcGxhY2VtZW50IGZvciBhbnNpIHN0cmluZyBoZWxwZXJzIFwid3JhcC1hbnNpXCIgYW5kIFwic3RyaXAtYW5zaVwiLlxuLy8gdG8gZmFjaWxpdGF0ZSBFU00gYW5kIERlbm8gbW9kdWxlcy5cbi8vIFRPRE86IGxvb2sgYXQgcG9ydGluZyBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS93cmFwLWFuc2kgdG8gRVNNLlxuLy8gVGhlIG5wbSBhcHBsaWNhdGlvblxuLy8gQ29weXJpZ2h0IChjKSBucG0sIEluYy4gYW5kIENvbnRyaWJ1dG9yc1xuLy8gTGljZW5zZWQgb24gdGhlIHRlcm1zIG9mIFRoZSBBcnRpc3RpYyBMaWNlbnNlIDIuMFxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbnBtL2NsaS9ibG9iLzRjNjVjZDk1MmJjODYyNzgxMTczNWJlYTc2YjliMTEwY2M0ZmM4MGUvbGliL3V0aWxzL2Fuc2ktdHJpbS5qc1xuY29uc3QgYW5zaSA9IG5ldyBSZWdFeHAoJ1xceDFiKD86XFxcXFsoPzpcXFxcZCtbQUJDREVGR0pLU1RtXXxcXFxcZCs7XFxcXGQrW0hmbV18JyArXG4gICAgJ1xcXFxkKztcXFxcZCs7XFxcXGQrbXw2bnxzfHV8XFxcXD8yNVtsaF0pfFxcXFx3KScsICdnJyk7XG5leHBvcnQgZnVuY3Rpb24gc3RyaXBBbnNpKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShhbnNpLCAnJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcChzdHIsIHdpZHRoKSB7XG4gICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gc3RyLm1hdGNoKGFuc2kpIHx8IFsnJywgJyddO1xuICAgIHN0ciA9IHN0cmlwQW5zaShzdHIpO1xuICAgIGxldCB3cmFwcGVkID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgIT09IDAgJiYgKGkgJSB3aWR0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHdyYXBwZWQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgd3JhcHBlZCArPSBzdHIuY2hhckF0KGkpO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgJiYgZW5kKSB7XG4gICAgICAgIHdyYXBwZWQgPSBgJHtzdGFydH0ke3dyYXBwZWR9JHtlbmR9YDtcbiAgICB9XG4gICAgcmV0dXJuIHdyYXBwZWQ7XG59XG4iLCIvLyBCb290c3RyYXAgY2xpdWkgd2l0aCBDb21tb25KUyBkZXBlbmRlbmNpZXM6XG5pbXBvcnQgeyBjbGl1aSB9IGZyb20gJy4vYnVpbGQvbGliL2luZGV4LmpzJ1xuaW1wb3J0IHsgd3JhcCwgc3RyaXBBbnNpIH0gZnJvbSAnLi9idWlsZC9saWIvc3RyaW5nLXV0aWxzLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1aSAob3B0cykge1xuICByZXR1cm4gY2xpdWkob3B0cywge1xuICAgIHN0cmluZ1dpZHRoOiAoc3RyKSA9PiB7XG4gICAgICByZXR1cm4gWy4uLnN0cl0ubGVuZ3RoXG4gICAgfSxcbiAgICBzdHJpcEFuc2ksXG4gICAgd3JhcFxuICB9KVxufVxuIiwiaW1wb3J0IHsgZGlybmFtZSwgcmVzb2x2ZSB9IGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgcmVhZGRpclN5bmMsIHN0YXRTeW5jIH0gZnJvbSAnZnMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoc3RhcnQsIGNhbGxiYWNrKSB7XG5cdGxldCBkaXIgPSByZXNvbHZlKCcuJywgc3RhcnQpO1xuXHRsZXQgdG1wLCBzdGF0cyA9IHN0YXRTeW5jKGRpcik7XG5cblx0aWYgKCFzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG5cdFx0ZGlyID0gZGlybmFtZShkaXIpO1xuXHR9XG5cblx0d2hpbGUgKHRydWUpIHtcblx0XHR0bXAgPSBjYWxsYmFjayhkaXIsIHJlYWRkaXJTeW5jKGRpcikpO1xuXHRcdGlmICh0bXApIHJldHVybiByZXNvbHZlKGRpciwgdG1wKTtcblx0XHRkaXIgPSBkaXJuYW1lKHRtcCA9IGRpcik7XG5cdFx0aWYgKHRtcCA9PT0gZGlyKSBicmVhaztcblx0fVxufVxuIiwibGV0IHNoaW07XG5jbGFzcyBZMThOIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIC8vIGNvbmZpZ3VyYWJsZSBvcHRpb25zLlxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgdGhpcy5kaXJlY3RvcnkgPSBvcHRzLmRpcmVjdG9yeSB8fCAnLi9sb2NhbGVzJztcbiAgICAgICAgdGhpcy51cGRhdGVGaWxlcyA9IHR5cGVvZiBvcHRzLnVwZGF0ZUZpbGVzID09PSAnYm9vbGVhbicgPyBvcHRzLnVwZGF0ZUZpbGVzIDogdHJ1ZTtcbiAgICAgICAgdGhpcy5sb2NhbGUgPSBvcHRzLmxvY2FsZSB8fCAnZW4nO1xuICAgICAgICB0aGlzLmZhbGxiYWNrVG9MYW5ndWFnZSA9IHR5cGVvZiBvcHRzLmZhbGxiYWNrVG9MYW5ndWFnZSA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5mYWxsYmFja1RvTGFuZ3VhZ2UgOiB0cnVlO1xuICAgICAgICAvLyBpbnRlcm5hbCBzdHVmZi5cbiAgICAgICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMud3JpdGVRdWV1ZSA9IFtdO1xuICAgIH1cbiAgICBfXyguLi5hcmdzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RhZ2dlZExpdGVyYWwoYXJndW1lbnRzWzBdLCAuLi5hcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0ciA9IGFyZ3Muc2hpZnQoKTtcbiAgICAgICAgbGV0IGNiID0gZnVuY3Rpb24gKCkgeyB9OyAvLyBzdGFydCB3aXRoIG5vb3AuXG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IgPSBhcmdzLnBvcCgpO1xuICAgICAgICBjYiA9IGNiIHx8IGZ1bmN0aW9uICgpIHsgfTsgLy8gbm9vcC5cbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlW3RoaXMubG9jYWxlXSlcbiAgICAgICAgICAgIHRoaXMuX3JlYWRMb2NhbGVGaWxlKCk7XG4gICAgICAgIC8vIHdlJ3ZlIG9ic2VydmVkIGEgbmV3IHN0cmluZywgdXBkYXRlIHRoZSBsYW5ndWFnZSBmaWxlLlxuICAgICAgICBpZiAoIXRoaXMuY2FjaGVbdGhpcy5sb2NhbGVdW3N0cl0gJiYgdGhpcy51cGRhdGVGaWxlcykge1xuICAgICAgICAgICAgdGhpcy5jYWNoZVt0aGlzLmxvY2FsZV1bc3RyXSA9IHN0cjtcbiAgICAgICAgICAgIC8vIGluY2x1ZGUgdGhlIGN1cnJlbnQgZGlyZWN0b3J5IGFuZCBsb2NhbGUsXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGVzZSB2YWx1ZXMgY291bGQgY2hhbmdlIGJlZm9yZSB0aGVcbiAgICAgICAgICAgIC8vIHdyaXRlIGlzIHBlcmZvcm1lZC5cbiAgICAgICAgICAgIHRoaXMuX2VucXVldWVXcml0ZSh7XG4gICAgICAgICAgICAgICAgZGlyZWN0b3J5OiB0aGlzLmRpcmVjdG9yeSxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLFxuICAgICAgICAgICAgICAgIGNiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNoaW0uZm9ybWF0LmFwcGx5KHNoaW0uZm9ybWF0LCBbdGhpcy5jYWNoZVt0aGlzLmxvY2FsZV1bc3RyXSB8fCBzdHJdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICAgIF9fbigpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnN0IHNpbmd1bGFyID0gYXJncy5zaGlmdCgpO1xuICAgICAgICBjb25zdCBwbHVyYWwgPSBhcmdzLnNoaWZ0KCk7XG4gICAgICAgIGNvbnN0IHF1YW50aXR5ID0gYXJncy5zaGlmdCgpO1xuICAgICAgICBsZXQgY2IgPSBmdW5jdGlvbiAoKSB7IH07IC8vIHN0YXJ0IHdpdGggbm9vcC5cbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYiA9IGFyZ3MucG9wKCk7XG4gICAgICAgIGlmICghdGhpcy5jYWNoZVt0aGlzLmxvY2FsZV0pXG4gICAgICAgICAgICB0aGlzLl9yZWFkTG9jYWxlRmlsZSgpO1xuICAgICAgICBsZXQgc3RyID0gcXVhbnRpdHkgPT09IDEgPyBzaW5ndWxhciA6IHBsdXJhbDtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGVbdGhpcy5sb2NhbGVdW3Npbmd1bGFyXSkge1xuICAgICAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmNhY2hlW3RoaXMubG9jYWxlXVtzaW5ndWxhcl07XG4gICAgICAgICAgICBzdHIgPSBlbnRyeVtxdWFudGl0eSA9PT0gMSA/ICdvbmUnIDogJ290aGVyJ107XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UndmUgb2JzZXJ2ZWQgYSBuZXcgc3RyaW5nLCB1cGRhdGUgdGhlIGxhbmd1YWdlIGZpbGUuXG4gICAgICAgIGlmICghdGhpcy5jYWNoZVt0aGlzLmxvY2FsZV1bc2luZ3VsYXJdICYmIHRoaXMudXBkYXRlRmlsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVbdGhpcy5sb2NhbGVdW3Npbmd1bGFyXSA9IHtcbiAgICAgICAgICAgICAgICBvbmU6IHNpbmd1bGFyLFxuICAgICAgICAgICAgICAgIG90aGVyOiBwbHVyYWxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBpbmNsdWRlIHRoZSBjdXJyZW50IGRpcmVjdG9yeSBhbmQgbG9jYWxlLFxuICAgICAgICAgICAgLy8gc2luY2UgdGhlc2UgdmFsdWVzIGNvdWxkIGNoYW5nZSBiZWZvcmUgdGhlXG4gICAgICAgICAgICAvLyB3cml0ZSBpcyBwZXJmb3JtZWQuXG4gICAgICAgICAgICB0aGlzLl9lbnF1ZXVlV3JpdGUoe1xuICAgICAgICAgICAgICAgIGRpcmVjdG9yeTogdGhpcy5kaXJlY3RvcnksXG4gICAgICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZSxcbiAgICAgICAgICAgICAgICBjYlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGEgJWQgcGxhY2Vob2xkZXIgaXMgcHJvdmlkZWQsIGFkZCBxdWFudGl0eVxuICAgICAgICAvLyB0byB0aGUgYXJndW1lbnRzIGV4cGFuZGVkIGJ5IHV0aWwuZm9ybWF0LlxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbc3RyXTtcbiAgICAgICAgaWYgKH5zdHIuaW5kZXhPZignJWQnKSlcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHF1YW50aXR5KTtcbiAgICAgICAgcmV0dXJuIHNoaW0uZm9ybWF0LmFwcGx5KHNoaW0uZm9ybWF0LCB2YWx1ZXMuY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gICAgc2V0TG9jYWxlKGxvY2FsZSkge1xuICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgICB9XG4gICAgZ2V0TG9jYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGU7XG4gICAgfVxuICAgIHVwZGF0ZUxvY2FsZShvYmopIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlW3RoaXMubG9jYWxlXSlcbiAgICAgICAgICAgIHRoaXMuX3JlYWRMb2NhbGVGaWxlKCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlW3RoaXMubG9jYWxlXVtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3RhZ2dlZExpdGVyYWwocGFydHMsIC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IHN0ciA9ICcnO1xuICAgICAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0LCBpKSB7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2kgKyAxXTtcbiAgICAgICAgICAgIHN0ciArPSBwYXJ0O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9ICclcyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fXy5hcHBseSh0aGlzLCBbc3RyXS5jb25jYXQoW10uc2xpY2UuY2FsbChhcmdzLCAxKSkpO1xuICAgIH1cbiAgICBfZW5xdWV1ZVdyaXRlKHdvcmspIHtcbiAgICAgICAgdGhpcy53cml0ZVF1ZXVlLnB1c2god29yayk7XG4gICAgICAgIGlmICh0aGlzLndyaXRlUXVldWUubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc1dyaXRlUXVldWUoKTtcbiAgICB9XG4gICAgX3Byb2Nlc3NXcml0ZVF1ZXVlKCkge1xuICAgICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHdvcmsgPSB0aGlzLndyaXRlUXVldWVbMF07XG4gICAgICAgIC8vIGRlc3RydWN0dXJlIHRoZSBlbnF1ZXVlZCB3b3JrLlxuICAgICAgICBjb25zdCBkaXJlY3RvcnkgPSB3b3JrLmRpcmVjdG9yeTtcbiAgICAgICAgY29uc3QgbG9jYWxlID0gd29yay5sb2NhbGU7XG4gICAgICAgIGNvbnN0IGNiID0gd29yay5jYjtcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2VGaWxlID0gdGhpcy5fcmVzb2x2ZUxvY2FsZUZpbGUoZGlyZWN0b3J5LCBsb2NhbGUpO1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkTG9jYWxlID0gSlNPTi5zdHJpbmdpZnkodGhpcy5jYWNoZVtsb2NhbGVdLCBudWxsLCAyKTtcbiAgICAgICAgc2hpbS5mcy53cml0ZUZpbGUobGFuZ3VhZ2VGaWxlLCBzZXJpYWxpemVkTG9jYWxlLCAndXRmLTgnLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBfdGhpcy53cml0ZVF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMud3JpdGVRdWV1ZS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIF90aGlzLl9wcm9jZXNzV3JpdGVRdWV1ZSgpO1xuICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9yZWFkTG9jYWxlRmlsZSgpIHtcbiAgICAgICAgbGV0IGxvY2FsZUxvb2t1cCA9IHt9O1xuICAgICAgICBjb25zdCBsYW5ndWFnZUZpbGUgPSB0aGlzLl9yZXNvbHZlTG9jYWxlRmlsZSh0aGlzLmRpcmVjdG9yeSwgdGhpcy5sb2NhbGUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB1c2luZyBhIGJ1bmRsZXIgc3VjaCBhcyB3ZWJwYWNrLCByZWFkRmlsZVN5bmMgbWF5IG5vdCBiZSBkZWZpbmVkOlxuICAgICAgICAgICAgaWYgKHNoaW0uZnMucmVhZEZpbGVTeW5jKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlTG9va3VwID0gSlNPTi5wYXJzZShzaGltLmZzLnJlYWRGaWxlU3luYyhsYW5ndWFnZUZpbGUsICd1dGYtOCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgU3ludGF4RXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9ICdzeW50YXggZXJyb3IgaW4gJyArIGxhbmd1YWdlRmlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpXG4gICAgICAgICAgICAgICAgbG9jYWxlTG9va3VwID0ge307XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGVbdGhpcy5sb2NhbGVdID0gbG9jYWxlTG9va3VwO1xuICAgIH1cbiAgICBfcmVzb2x2ZUxvY2FsZUZpbGUoZGlyZWN0b3J5LCBsb2NhbGUpIHtcbiAgICAgICAgbGV0IGZpbGUgPSBzaGltLnJlc29sdmUoZGlyZWN0b3J5LCAnLi8nLCBsb2NhbGUgKyAnLmpzb24nKTtcbiAgICAgICAgaWYgKHRoaXMuZmFsbGJhY2tUb0xhbmd1YWdlICYmICF0aGlzLl9maWxlRXhpc3RzU3luYyhmaWxlKSAmJiB+bG9jYWxlLmxhc3RJbmRleE9mKCdfJykpIHtcbiAgICAgICAgICAgIC8vIGF0dGVtcHQgZmFsbGJhY2sgdG8gbGFuZ3VhZ2Ugb25seVxuICAgICAgICAgICAgY29uc3QgbGFuZ3VhZ2VGaWxlID0gc2hpbS5yZXNvbHZlKGRpcmVjdG9yeSwgJy4vJywgbG9jYWxlLnNwbGl0KCdfJylbMF0gKyAnLmpzb24nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9maWxlRXhpc3RzU3luYyhsYW5ndWFnZUZpbGUpKVxuICAgICAgICAgICAgICAgIGZpbGUgPSBsYW5ndWFnZUZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgfVxuICAgIF9maWxlRXhpc3RzU3luYyhmaWxlKSB7XG4gICAgICAgIHJldHVybiBzaGltLmV4aXN0cyhmaWxlKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24geTE4bihvcHRzLCBfc2hpbSkge1xuICAgIHNoaW0gPSBfc2hpbTtcbiAgICBjb25zdCB5MThuID0gbmV3IFkxOE4ob3B0cyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgX186IHkxOG4uX18uYmluZCh5MThuKSxcbiAgICAgICAgX19uOiB5MThuLl9fbi5iaW5kKHkxOG4pLFxuICAgICAgICBzZXRMb2NhbGU6IHkxOG4uc2V0TG9jYWxlLmJpbmQoeTE4biksXG4gICAgICAgIGdldExvY2FsZTogeTE4bi5nZXRMb2NhbGUuYmluZCh5MThuKSxcbiAgICAgICAgdXBkYXRlTG9jYWxlOiB5MThuLnVwZGF0ZUxvY2FsZS5iaW5kKHkxOG4pLFxuICAgICAgICBsb2NhbGU6IHkxOG4ubG9jYWxlXG4gICAgfTtcbn1cbiIsImltcG9ydCB7IHJlYWRGaWxlU3luYywgc3RhdFN5bmMsIHdyaXRlRmlsZSB9IGZyb20gJ2ZzJztcbmltcG9ydCB7IGZvcm1hdCB9IGZyb20gJ3V0aWwnO1xuaW1wb3J0IHsgcmVzb2x2ZSB9IGZyb20gJ3BhdGgnO1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIGZzOiB7XG4gICAgICAgIHJlYWRGaWxlU3luYyxcbiAgICAgICAgd3JpdGVGaWxlXG4gICAgfSxcbiAgICBmb3JtYXQsXG4gICAgcmVzb2x2ZSxcbiAgICBleGlzdHM6IChmaWxlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdFN5bmMoZmlsZSkuaXNGaWxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsImltcG9ydCBzaGltIGZyb20gJy4vYnVpbGQvbGliL3BsYXRmb3JtLXNoaW1zL25vZGUuanMnXG5pbXBvcnQgeyB5MThuIGFzIF95MThuIH0gZnJvbSAnLi9idWlsZC9saWIvaW5kZXguanMnXG5cbmNvbnN0IHkxOG4gPSAob3B0cykgPT4ge1xuICByZXR1cm4gX3kxOG4ob3B0cywgc2hpbSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgeTE4blxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1haW4gZW50cnlwb2ludCBmb3IgbGlicmFyaWVzIHVzaW5nIHlhcmdzLXBhcnNlciBpbiBOb2RlLmpzXG4gKiBDSlMgYW5kIEVTTSBlbnZpcm9ubWVudHMuXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNiwgQ29udHJpYnV0b3JzXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogSVNDXG4gKi9cbnZhciBfYSwgX2IsIF9jO1xuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAndXRpbCc7XG5pbXBvcnQgeyBub3JtYWxpemUsIHJlc29sdmUgfSBmcm9tICdwYXRoJztcbmltcG9ydCB7IGNhbWVsQ2FzZSwgZGVjYW1lbGl6ZSwgbG9va3NMaWtlTnVtYmVyIH0gZnJvbSAnLi9zdHJpbmctdXRpbHMuanMnO1xuaW1wb3J0IHsgWWFyZ3NQYXJzZXIgfSBmcm9tICcuL3lhcmdzLXBhcnNlci5qcyc7XG5pbXBvcnQgeyByZWFkRmlsZVN5bmMgfSBmcm9tICdmcyc7XG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3lhcmdzL3lhcmdzLXBhcnNlciNzdXBwb3J0ZWQtbm9kZWpzLXZlcnNpb25zIGZvciBvdXJcbi8vIHZlcnNpb24gc3VwcG9ydCBwb2xpY3kuIFRoZSBZQVJHU19NSU5fTk9ERV9WRVJTSU9OIGlzIHVzZWQgZm9yIHRlc3Rpbmcgb25seS5cbmNvbnN0IG1pbk5vZGVWZXJzaW9uID0gKHByb2Nlc3MgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuWUFSR1NfTUlOX05PREVfVkVSU0lPTilcbiAgICA/IE51bWJlcihwcm9jZXNzLmVudi5ZQVJHU19NSU5fTk9ERV9WRVJTSU9OKVxuICAgIDogMTI7XG5jb25zdCBub2RlVmVyc2lvbiA9IChfYiA9IChfYSA9IHByb2Nlc3MgPT09IG51bGwgfHwgcHJvY2VzcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvY2Vzcy52ZXJzaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vZGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChfYyA9IHByb2Nlc3MgPT09IG51bGwgfHwgcHJvY2VzcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvY2Vzcy52ZXJzaW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc2xpY2UoMSk7XG5pZiAobm9kZVZlcnNpb24pIHtcbiAgICBjb25zdCBtYWpvciA9IE51bWJlcihub2RlVmVyc2lvbi5tYXRjaCgvXihbXi5dKykvKVsxXSk7XG4gICAgaWYgKG1ham9yIDwgbWluTm9kZVZlcnNpb24pIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYHlhcmdzIHBhcnNlciBzdXBwb3J0cyBhIG1pbmltdW0gTm9kZS5qcyB2ZXJzaW9uIG9mICR7bWluTm9kZVZlcnNpb259LiBSZWFkIG91ciB2ZXJzaW9uIHN1cHBvcnQgcG9saWN5OiBodHRwczovL2dpdGh1Yi5jb20veWFyZ3MveWFyZ3MtcGFyc2VyI3N1cHBvcnRlZC1ub2RlanMtdmVyc2lvbnNgKTtcbiAgICB9XG59XG4vLyBDcmVhdGVzIGEgeWFyZ3MtcGFyc2VyIGluc3RhbmNlIHVzaW5nIE5vZGUuanMgc3RhbmRhcmQgbGlicmFyaWVzOlxuY29uc3QgZW52ID0gcHJvY2VzcyA/IHByb2Nlc3MuZW52IDoge307XG5jb25zdCBwYXJzZXIgPSBuZXcgWWFyZ3NQYXJzZXIoe1xuICAgIGN3ZDogcHJvY2Vzcy5jd2QsXG4gICAgZW52OiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBlbnY7XG4gICAgfSxcbiAgICBmb3JtYXQsXG4gICAgbm9ybWFsaXplLFxuICAgIHJlc29sdmUsXG4gICAgLy8gVE9ETzogZmlndXJlICBvdXQgYSAgd2F5IHRvIGNvbWJpbmUgRVNNIGFuZCBDSlMgY292ZXJhZ2UsIHN1Y2ggIHRoYXRcbiAgICAvLyB3ZSBjYW4gZXhlcmNpc2UgYWxsIHRoZSBsaW5lcyBiZWxvdzpcbiAgICByZXF1aXJlOiAocGF0aCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWlyZShwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXRoLm1hdGNoKC9cXC5qc29uJC8pKSB7XG4gICAgICAgICAgICAvLyBBZGRyZXNzZXM6IGh0dHBzOi8vZ2l0aHViLmNvbS95YXJncy95YXJncy9pc3N1ZXMvMjA0MFxuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVhZEZpbGVTeW5jKHBhdGgsICd1dGY4JykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ29ubHkgLmpzb24gY29uZmlnIGZpbGVzIGFyZSBzdXBwb3J0ZWQgaW4gRVNNJyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbmNvbnN0IHlhcmdzUGFyc2VyID0gZnVuY3Rpb24gUGFyc2VyKGFyZ3MsIG9wdHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIucGFyc2UoYXJncy5zbGljZSgpLCBvcHRzKTtcbiAgICByZXR1cm4gcmVzdWx0LmFyZ3Y7XG59O1xueWFyZ3NQYXJzZXIuZGV0YWlsZWQgPSBmdW5jdGlvbiAoYXJncywgb3B0cykge1xuICAgIHJldHVybiBwYXJzZXIucGFyc2UoYXJncy5zbGljZSgpLCBvcHRzKTtcbn07XG55YXJnc1BhcnNlci5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG55YXJnc1BhcnNlci5kZWNhbWVsaXplID0gZGVjYW1lbGl6ZTtcbnlhcmdzUGFyc2VyLmxvb2tzTGlrZU51bWJlciA9IGxvb2tzTGlrZU51bWJlcjtcbmV4cG9ydCBkZWZhdWx0IHlhcmdzUGFyc2VyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE2LCBDb250cmlidXRvcnNcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBJU0NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbWVsQ2FzZShzdHIpIHtcbiAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgYW4gYXJndW1lbnQgaXMgcHJvdmlkZWQgYXMgY2FtZWwgY2FzZSwgZS5nLiwgZm9vQmFyLlxuICAgIC8vIGJ5IGVuc3VyaW5nIHRoYXQgdGhlIHN0cmluZyBpc24ndCBhbHJlYWR5IG1peGVkIGNhc2U6XG4gICAgY29uc3QgaXNDYW1lbENhc2UgPSBzdHIgIT09IHN0ci50b0xvd2VyQ2FzZSgpICYmIHN0ciAhPT0gc3RyLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKCFpc0NhbWVsQ2FzZSkge1xuICAgICAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgaWYgKHN0ci5pbmRleE9mKCctJykgPT09IC0xICYmIHN0ci5pbmRleE9mKCdfJykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgY2FtZWxjYXNlID0gJyc7XG4gICAgICAgIGxldCBuZXh0Q2hyVXBwZXIgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbGVhZGluZ0h5cGhlbnMgPSBzdHIubWF0Y2goL14tKy8pO1xuICAgICAgICBmb3IgKGxldCBpID0gbGVhZGluZ0h5cGhlbnMgPyBsZWFkaW5nSHlwaGVuc1swXS5sZW5ndGggOiAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hyID0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChuZXh0Q2hyVXBwZXIpIHtcbiAgICAgICAgICAgICAgICBuZXh0Q2hyVXBwZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjaHIgPSBjaHIudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpICE9PSAwICYmIChjaHIgPT09ICctJyB8fCBjaHIgPT09ICdfJykpIHtcbiAgICAgICAgICAgICAgICBuZXh0Q2hyVXBwZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hyICE9PSAnLScgJiYgY2hyICE9PSAnXycpIHtcbiAgICAgICAgICAgICAgICBjYW1lbGNhc2UgKz0gY2hyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW1lbGNhc2U7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY2FtZWxpemUoc3RyLCBqb2luU3RyaW5nKSB7XG4gICAgY29uc3QgbG93ZXJjYXNlID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgam9pblN0cmluZyA9IGpvaW5TdHJpbmcgfHwgJy0nO1xuICAgIGxldCBub3RDYW1lbGNhc2UgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaHJMb3dlciA9IGxvd2VyY2FzZS5jaGFyQXQoaSk7XG4gICAgICAgIGNvbnN0IGNoclN0cmluZyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIGlmIChjaHJMb3dlciAhPT0gY2hyU3RyaW5nICYmIGkgPiAwKSB7XG4gICAgICAgICAgICBub3RDYW1lbGNhc2UgKz0gYCR7am9pblN0cmluZ30ke2xvd2VyY2FzZS5jaGFyQXQoaSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vdENhbWVsY2FzZSArPSBjaHJTdHJpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vdENhbWVsY2FzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsb29rc0xpa2VOdW1iZXIoeCkge1xuICAgIGlmICh4ID09PSBudWxsIHx8IHggPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGlmIGxvYWRlZCBmcm9tIGNvbmZpZywgbWF5IGFscmVhZHkgYmUgYSBudW1iZXIuXG4gICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gaGV4YWRlY2ltYWwuXG4gICAgaWYgKC9eMHhbMC05YS1mXSskL2kudGVzdCh4KSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gZG9uJ3QgdHJlYXQgMDEyMyBhcyBhIG51bWJlcjsgYXMgaXQgZHJvcHMgdGhlIGxlYWRpbmcgJzAnLlxuICAgIGlmICgvXjBbXi5dLy50ZXN0KHgpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIC9eWy1dPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoZVstK10/XFxkKyk/JC8udGVzdCh4KTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNiwgQ29udHJpYnV0b3JzXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogSVNDXG4gKi9cbi8vIHRha2UgYW4gdW4tc3BsaXQgYXJndiBzdHJpbmcgYW5kIHRva2VuaXplIGl0LlxuZXhwb3J0IGZ1bmN0aW9uIHRva2VuaXplQXJnU3RyaW5nKGFyZ1N0cmluZykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ1N0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIGFyZ1N0cmluZy5tYXAoZSA9PiB0eXBlb2YgZSAhPT0gJ3N0cmluZycgPyBlICsgJycgOiBlKTtcbiAgICB9XG4gICAgYXJnU3RyaW5nID0gYXJnU3RyaW5nLnRyaW0oKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IHByZXZDID0gbnVsbDtcbiAgICBsZXQgYyA9IG51bGw7XG4gICAgbGV0IG9wZW5pbmcgPSBudWxsO1xuICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgYXJnU3RyaW5nLmxlbmd0aDsgaWkrKykge1xuICAgICAgICBwcmV2QyA9IGM7XG4gICAgICAgIGMgPSBhcmdTdHJpbmcuY2hhckF0KGlpKTtcbiAgICAgICAgLy8gc3BsaXQgb24gc3BhY2VzIHVubGVzcyB3ZSdyZSBpbiBxdW90ZXMuXG4gICAgICAgIGlmIChjID09PSAnICcgJiYgIW9wZW5pbmcpIHtcbiAgICAgICAgICAgIGlmICghKHByZXZDID09PSAnICcpKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uJ3Qgc3BsaXQgdGhlIHN0cmluZyBpZiB3ZSdyZSBpbiBtYXRjaGluZ1xuICAgICAgICAvLyBvcGVuaW5nIG9yIGNsb3Npbmcgc2luZ2xlIGFuZCBkb3VibGUgcXVvdGVzLlxuICAgICAgICBpZiAoYyA9PT0gb3BlbmluZykge1xuICAgICAgICAgICAgb3BlbmluZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgPT09IFwiJ1wiIHx8IGMgPT09ICdcIicpICYmICFvcGVuaW5nKSB7XG4gICAgICAgICAgICBvcGVuaW5nID0gYztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFyZ3NbaV0pXG4gICAgICAgICAgICBhcmdzW2ldID0gJyc7XG4gICAgICAgIGFyZ3NbaV0gKz0gYztcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3M7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYsIENvbnRyaWJ1dG9yc1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IElTQ1xuICovXG5leHBvcnQgdmFyIERlZmF1bHRWYWx1ZXNGb3JUeXBlS2V5O1xuKGZ1bmN0aW9uIChEZWZhdWx0VmFsdWVzRm9yVHlwZUtleSkge1xuICAgIERlZmF1bHRWYWx1ZXNGb3JUeXBlS2V5W1wiQk9PTEVBTlwiXSA9IFwiYm9vbGVhblwiO1xuICAgIERlZmF1bHRWYWx1ZXNGb3JUeXBlS2V5W1wiU1RSSU5HXCJdID0gXCJzdHJpbmdcIjtcbiAgICBEZWZhdWx0VmFsdWVzRm9yVHlwZUtleVtcIk5VTUJFUlwiXSA9IFwibnVtYmVyXCI7XG4gICAgRGVmYXVsdFZhbHVlc0ZvclR5cGVLZXlbXCJBUlJBWVwiXSA9IFwiYXJyYXlcIjtcbn0pKERlZmF1bHRWYWx1ZXNGb3JUeXBlS2V5IHx8IChEZWZhdWx0VmFsdWVzRm9yVHlwZUtleSA9IHt9KSk7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYsIENvbnRyaWJ1dG9yc1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IElTQ1xuICovXG5pbXBvcnQgeyB0b2tlbml6ZUFyZ1N0cmluZyB9IGZyb20gJy4vdG9rZW5pemUtYXJnLXN0cmluZy5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0VmFsdWVzRm9yVHlwZUtleSB9IGZyb20gJy4veWFyZ3MtcGFyc2VyLXR5cGVzLmpzJztcbmltcG9ydCB7IGNhbWVsQ2FzZSwgZGVjYW1lbGl6ZSwgbG9va3NMaWtlTnVtYmVyIH0gZnJvbSAnLi9zdHJpbmctdXRpbHMuanMnO1xubGV0IG1peGluO1xuZXhwb3J0IGNsYXNzIFlhcmdzUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihfbWl4aW4pIHtcbiAgICAgICAgbWl4aW4gPSBfbWl4aW47XG4gICAgfVxuICAgIHBhcnNlKGFyZ3NJbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBhbGlhczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYXJyYXk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGJvb2xlYW46IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbmZpZzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29uZmlnT2JqZWN0czogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29uZmlndXJhdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29lcmNlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb3VudDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZW52UHJlZml4OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBuYXJnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBub3JtYWxpemU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHN0cmluZzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbnVtYmVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBfXzogdW5kZWZpbmVkLFxuICAgICAgICAgICAga2V5OiB1bmRlZmluZWRcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIC8vIGFsbG93IGEgc3RyaW5nIGFyZ3VtZW50IHRvIGJlIHBhc3NlZCBpbiByYXRoZXJcbiAgICAgICAgLy8gdGhhbiBhbiBhcmd2IGFycmF5LlxuICAgICAgICBjb25zdCBhcmdzID0gdG9rZW5pemVBcmdTdHJpbmcoYXJnc0lucHV0KTtcbiAgICAgICAgLy8gdG9rZW5pemVBcmdTdHJpbmcgYWRkcyBleHRyYSBxdW90ZXMgdG8gYXJncyBpZiBhcmdzSW5wdXQgaXMgYSBzdHJpbmdcbiAgICAgICAgLy8gb25seSBzdHJpcCB0aG9zZSBleHRyYSBxdW90ZXMgaW4gcHJvY2Vzc1ZhbHVlIGlmIGFyZ3NJbnB1dCBpcyBhIHN0cmluZ1xuICAgICAgICBjb25zdCBpbnB1dElzU3RyaW5nID0gdHlwZW9mIGFyZ3NJbnB1dCA9PT0gJ3N0cmluZyc7XG4gICAgICAgIC8vIGFsaWFzZXMgbWlnaHQgaGF2ZSB0cmFuc2l0aXZlIHJlbGF0aW9uc2hpcHMsIG5vcm1hbGl6ZSB0aGlzLlxuICAgICAgICBjb25zdCBhbGlhc2VzID0gY29tYmluZUFsaWFzZXMoT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBvcHRzLmFsaWFzKSk7XG4gICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICdib29sZWFuLW5lZ2F0aW9uJzogdHJ1ZSxcbiAgICAgICAgICAgICdjYW1lbC1jYXNlLWV4cGFuc2lvbic6IHRydWUsXG4gICAgICAgICAgICAnY29tYmluZS1hcnJheXMnOiBmYWxzZSxcbiAgICAgICAgICAgICdkb3Qtbm90YXRpb24nOiB0cnVlLFxuICAgICAgICAgICAgJ2R1cGxpY2F0ZS1hcmd1bWVudHMtYXJyYXknOiB0cnVlLFxuICAgICAgICAgICAgJ2ZsYXR0ZW4tZHVwbGljYXRlLWFycmF5cyc6IHRydWUsXG4gICAgICAgICAgICAnZ3JlZWR5LWFycmF5cyc6IHRydWUsXG4gICAgICAgICAgICAnaGFsdC1hdC1ub24tb3B0aW9uJzogZmFsc2UsXG4gICAgICAgICAgICAnbmFyZ3MtZWF0cy1vcHRpb25zJzogZmFsc2UsXG4gICAgICAgICAgICAnbmVnYXRpb24tcHJlZml4JzogJ25vLScsXG4gICAgICAgICAgICAncGFyc2UtbnVtYmVycyc6IHRydWUsXG4gICAgICAgICAgICAncGFyc2UtcG9zaXRpb25hbC1udW1iZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdwb3B1bGF0ZS0tJzogZmFsc2UsXG4gICAgICAgICAgICAnc2V0LXBsYWNlaG9sZGVyLWtleSc6IGZhbHNlLFxuICAgICAgICAgICAgJ3Nob3J0LW9wdGlvbi1ncm91cHMnOiB0cnVlLFxuICAgICAgICAgICAgJ3N0cmlwLWFsaWFzZWQnOiBmYWxzZSxcbiAgICAgICAgICAgICdzdHJpcC1kYXNoZWQnOiBmYWxzZSxcbiAgICAgICAgICAgICd1bmtub3duLW9wdGlvbnMtYXMtYXJncyc6IGZhbHNlXG4gICAgICAgIH0sIG9wdHMuY29uZmlndXJhdGlvbik7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBvcHRzLmRlZmF1bHQpO1xuICAgICAgICBjb25zdCBjb25maWdPYmplY3RzID0gb3B0cy5jb25maWdPYmplY3RzIHx8IFtdO1xuICAgICAgICBjb25zdCBlbnZQcmVmaXggPSBvcHRzLmVudlByZWZpeDtcbiAgICAgICAgY29uc3Qgbm90RmxhZ3NPcHRpb24gPSBjb25maWd1cmF0aW9uWydwb3B1bGF0ZS0tJ107XG4gICAgICAgIGNvbnN0IG5vdEZsYWdzQXJndiA9IG5vdEZsYWdzT3B0aW9uID8gJy0tJyA6ICdfJztcbiAgICAgICAgY29uc3QgbmV3QWxpYXNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIC8vIGFsbG93IGEgaTE4biBoYW5kbGVyIHRvIGJlIHBhc3NlZCBpbiwgZGVmYXVsdCB0byBhIGZha2Ugb25lICh1dGlsLmZvcm1hdCkuXG4gICAgICAgIGNvbnN0IF9fID0gb3B0cy5fXyB8fCBtaXhpbi5mb3JtYXQ7XG4gICAgICAgIGNvbnN0IGZsYWdzID0ge1xuICAgICAgICAgICAgYWxpYXNlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgIGFycmF5czogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgIGJvb2xzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgc3RyaW5nczogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgIG51bWJlcnM6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICBjb3VudHM6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICBub3JtYWxpemU6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICBjb25maWdzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgbmFyZ3M6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICBjb2VyY2lvbnM6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICBrZXlzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBuZWdhdGl2ZSA9IC9eLShbMC05XSsoXFwuWzAtOV0rKT98XFwuWzAtOV0rKSQvO1xuICAgICAgICBjb25zdCBuZWdhdGVkQm9vbGVhbiA9IG5ldyBSZWdFeHAoJ14tLScgKyBjb25maWd1cmF0aW9uWyduZWdhdGlvbi1wcmVmaXgnXSArICcoLispJyk7XG4gICAgICAgIFtdLmNvbmNhdChvcHRzLmFycmF5IHx8IFtdKS5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaChmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0eXBlb2Ygb3B0ID09PSAnb2JqZWN0JyA/IG9wdC5rZXkgOiBvcHQ7XG4gICAgICAgICAgICAvLyBhc3NpZ24gdG8gZmxhZ3NbYm9vbHN8c3RyaW5nc3xudW1iZXJzXVxuICAgICAgICAgICAgY29uc3QgYXNzaWdubWVudCA9IE9iamVjdC5rZXlzKG9wdCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnJheUZsYWdLZXlzID0ge1xuICAgICAgICAgICAgICAgICAgICBib29sZWFuOiAnYm9vbHMnLFxuICAgICAgICAgICAgICAgICAgICBzdHJpbmc6ICdzdHJpbmdzJyxcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyOiAnbnVtYmVycydcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheUZsYWdLZXlzW2tleV07XG4gICAgICAgICAgICB9KS5maWx0ZXIoQm9vbGVhbikucG9wKCk7XG4gICAgICAgICAgICAvLyBhc3NpZ24ga2V5IHRvIGJlIGNvZXJjZWRcbiAgICAgICAgICAgIGlmIChhc3NpZ25tZW50KSB7XG4gICAgICAgICAgICAgICAgZmxhZ3NbYXNzaWdubWVudF1ba2V5XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbGFncy5hcnJheXNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICBmbGFncy5rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIFtdLmNvbmNhdChvcHRzLmJvb2xlYW4gfHwgW10pLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGZsYWdzLmJvb2xzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgZmxhZ3Mua2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBbXS5jb25jYXQob3B0cy5zdHJpbmcgfHwgW10pLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGZsYWdzLnN0cmluZ3Nba2V5XSA9IHRydWU7XG4gICAgICAgICAgICBmbGFncy5rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIFtdLmNvbmNhdChvcHRzLm51bWJlciB8fCBbXSkuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgZmxhZ3MubnVtYmVyc1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIGZsYWdzLmtleXMucHVzaChrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgW10uY29uY2F0KG9wdHMuY291bnQgfHwgW10pLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGZsYWdzLmNvdW50c1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIGZsYWdzLmtleXMucHVzaChrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgW10uY29uY2F0KG9wdHMubm9ybWFsaXplIHx8IFtdKS5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBmbGFncy5ub3JtYWxpemVba2V5XSA9IHRydWU7XG4gICAgICAgICAgICBmbGFncy5rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5uYXJnID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMob3B0cy5uYXJnKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBmbGFncy5uYXJnc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5jb2VyY2UgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhvcHRzLmNvZXJjZSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBmbGFncy5jb2VyY2lvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBmbGFncy5rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdHMuY29uZmlnICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0cy5jb25maWcpIHx8IHR5cGVvZiBvcHRzLmNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgW10uY29uY2F0KG9wdHMuY29uZmlnKS5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmNvbmZpZ3Nba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0cy5jb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMob3B0cy5jb25maWcpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFncy5jb25maWdzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSBhIGxvb2t1cCB0YWJsZSB0aGF0IHRha2VzIGludG8gYWNjb3VudCBhbGxcbiAgICAgICAgLy8gY29tYmluYXRpb25zIG9mIGFsaWFzZXM6IHtmOiBbJ2ZvbyddLCBmb286IFsnZiddfVxuICAgICAgICBleHRlbmRBbGlhc2VzKG9wdHMua2V5LCBhbGlhc2VzLCBvcHRzLmRlZmF1bHQsIGZsYWdzLmFycmF5cyk7XG4gICAgICAgIC8vIGFwcGx5IGRlZmF1bHQgdmFsdWVzIHRvIGFsbCBhbGlhc2VzLlxuICAgICAgICBPYmplY3Qua2V5cyhkZWZhdWx0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAoZmxhZ3MuYWxpYXNlc1trZXldIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRzW2FsaWFzXSA9IGRlZmF1bHRzW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgICAgIGNoZWNrQ29uZmlndXJhdGlvbigpO1xuICAgICAgICBsZXQgbm90RmxhZ3MgPSBbXTtcbiAgICAgICAgY29uc3QgYXJndiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgeyBfOiBbXSB9KTtcbiAgICAgICAgLy8gVE9ETyhiY29lKTogZm9yIHRoZSBmaXJzdCBwYXNzIGF0IHJlbW92aW5nIG9iamVjdCBwcm90b3R5cGUgIHdlIGRpZG4ndFxuICAgICAgICAvLyByZW1vdmUgYWxsIHByb3RvdHlwZXMgZnJvbSBvYmplY3RzIHJldHVybmVkIGJ5IHRoaXMgQVBJLCB3ZSBtaWdodCB3YW50XG4gICAgICAgIC8vIHRvIGdyYWR1YWxseSBtb3ZlIHRvd2FyZHMgZG9pbmcgc28uXG4gICAgICAgIGNvbnN0IGFyZ3ZSZXR1cm4gPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2ldO1xuICAgICAgICAgICAgY29uc3QgdHJ1bmNhdGVkQXJnID0gYXJnLnJlcGxhY2UoL14tezMsfS8sICctLS0nKTtcbiAgICAgICAgICAgIGxldCBicm9rZW47XG4gICAgICAgICAgICBsZXQga2V5O1xuICAgICAgICAgICAgbGV0IGxldHRlcnM7XG4gICAgICAgICAgICBsZXQgbTtcbiAgICAgICAgICAgIGxldCBuZXh0O1xuICAgICAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICAgICAgLy8gYW55IHVua25vd24gb3B0aW9uIChleGNlcHQgZm9yIGVuZC1vZi1vcHRpb25zLCBcIi0tXCIpXG4gICAgICAgICAgICBpZiAoYXJnICE9PSAnLS0nICYmIC9eLS8udGVzdChhcmcpICYmIGlzVW5rbm93bk9wdGlvbkFzQXJnKGFyZykpIHtcbiAgICAgICAgICAgICAgICBwdXNoUG9zaXRpb25hbChhcmcpO1xuICAgICAgICAgICAgICAgIC8vIC0tLSwgLS0tPSwgLS0tLSwgZXRjLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHJ1bmNhdGVkQXJnLm1hdGNoKC9eLS0tKyg9fCQpLykpIHtcbiAgICAgICAgICAgICAgICAvLyBvcHRpb25zIHdpdGhvdXQga2V5IG5hbWUgYXJlIGludmFsaWQuXG4gICAgICAgICAgICAgICAgcHVzaFBvc2l0aW9uYWwoYXJnKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAvLyAtLSBzZXBhcmF0ZWQgYnkgPVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXJnLm1hdGNoKC9eLS0uKz0vKSB8fCAoIWNvbmZpZ3VyYXRpb25bJ3Nob3J0LW9wdGlvbi1ncm91cHMnXSAmJiBhcmcubWF0Y2goL14tLis9LykpKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNpbmcgW1xcc1xcU10gaW5zdGVhZCBvZiAuIGJlY2F1c2UganMgZG9lc24ndCBzdXBwb3J0IHRoZVxuICAgICAgICAgICAgICAgIC8vICdkb3RhbGwnIHJlZ2V4IG1vZGlmaWVyLiBTZWU6XG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTA2ODMwOC8xMzIxNlxuICAgICAgICAgICAgICAgIG0gPSBhcmcubWF0Y2goL14tLT8oW149XSspPShbXFxzXFxTXSopJC8pO1xuICAgICAgICAgICAgICAgIC8vIGFycmF5cyBmb3JtYXQgPSAnLS1mPWEgYiBjJ1xuICAgICAgICAgICAgICAgIGlmIChtICE9PSBudWxsICYmIEFycmF5LmlzQXJyYXkobSkgJiYgbS5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tBbGxBbGlhc2VzKG1bMV0sIGZsYWdzLmFycmF5cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBlYXRBcnJheShpLCBtWzFdLCBhcmdzLCBtWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGVja0FsbEFsaWFzZXMobVsxXSwgZmxhZ3MubmFyZ3MpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmFyZ3MgZm9ybWF0ID0gJy0tZj1tb25rZXkgd2FzaGluZyBjYXQnXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gZWF0TmFyZ3MoaSwgbVsxXSwgYXJncywgbVsyXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBcmcobVsxXSwgbVsyXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcmcubWF0Y2gobmVnYXRlZEJvb2xlYW4pICYmIGNvbmZpZ3VyYXRpb25bJ2Jvb2xlYW4tbmVnYXRpb24nXSkge1xuICAgICAgICAgICAgICAgIG0gPSBhcmcubWF0Y2gobmVnYXRlZEJvb2xlYW4pO1xuICAgICAgICAgICAgICAgIGlmIChtICE9PSBudWxsICYmIEFycmF5LmlzQXJyYXkobSkgJiYgbS5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBtWzFdO1xuICAgICAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5hcnJheXMpID8gW2ZhbHNlXSA6IGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gLS0gc2VwYXJhdGVkIGJ5IHNwYWNlLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXJnLm1hdGNoKC9eLS0uKy8pIHx8ICghY29uZmlndXJhdGlvblsnc2hvcnQtb3B0aW9uLWdyb3VwcyddICYmIGFyZy5tYXRjaCgvXi1bXi1dKy8pKSkge1xuICAgICAgICAgICAgICAgIG0gPSBhcmcubWF0Y2goL14tLT8oLispLyk7XG4gICAgICAgICAgICAgICAgaWYgKG0gIT09IG51bGwgJiYgQXJyYXkuaXNBcnJheShtKSAmJiBtLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG1bMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5hcnJheXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcnJheSBmb3JtYXQgPSAnLS1mb28gYSBiIGMnXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gZWF0QXJyYXkoaSwga2V5LCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5uYXJncykgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuYXJncyBmb3JtYXQgPSAnLS1mb28gYSBiIGMnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgdHJ1dGh5IGV2ZW4gaWY6IGZsYWdzLm5hcmdzW2tleV0gPT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBlYXROYXJncyhpLCBrZXksIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGFyZ3NbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCAmJiAoIW5leHQubWF0Y2goL14tLykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Lm1hdGNoKG5lZ2F0aXZlKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYm9vbHMpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmNvdW50cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvXih0cnVlfGZhbHNlKSQvLnRlc3QobmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBkZWZhdWx0VmFsdWUoa2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZG90LW5vdGF0aW9uIGZsYWcgc2VwYXJhdGVkIGJ5ICc9Jy5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZy5tYXRjaCgvXi0uXFwuLis9LykpIHtcbiAgICAgICAgICAgICAgICBtID0gYXJnLm1hdGNoKC9eLShbXj1dKyk9KFtcXHNcXFNdKikkLyk7XG4gICAgICAgICAgICAgICAgaWYgKG0gIT09IG51bGwgJiYgQXJyYXkuaXNBcnJheShtKSAmJiBtLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEFyZyhtWzFdLCBtWzJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZG90LW5vdGF0aW9uIGZsYWcgc2VwYXJhdGVkIGJ5IHNwYWNlLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXJnLm1hdGNoKC9eLS5cXC4uKy8pICYmICFhcmcubWF0Y2gobmVnYXRpdmUpKSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IGFyZ3NbaSArIDFdO1xuICAgICAgICAgICAgICAgIG0gPSBhcmcubWF0Y2goL14tKC5cXC4uKykvKTtcbiAgICAgICAgICAgICAgICBpZiAobSAhPT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KG0pICYmIG0ubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gbVsxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCAmJiAhbmV4dC5tYXRjaCgvXi0vKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmJvb2xzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmNvdW50cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEFyZyhrZXksIG5leHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgZGVmYXVsdFZhbHVlKGtleSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXJnLm1hdGNoKC9eLVteLV0rLykgJiYgIWFyZy5tYXRjaChuZWdhdGl2ZSkpIHtcbiAgICAgICAgICAgICAgICBsZXR0ZXJzID0gYXJnLnNsaWNlKDEsIC0xKS5zcGxpdCgnJyk7XG4gICAgICAgICAgICAgICAgYnJva2VuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZXR0ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBhcmcuc2xpY2UoaiArIDIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGV0dGVyc1tqICsgMV0gJiYgbGV0dGVyc1tqICsgMV0gPT09ICc9Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhcmcuc2xpY2UoaiArIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gbGV0dGVyc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5hcnJheXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXkgZm9ybWF0ID0gJy1mPWEgYiBjJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBlYXRBcnJheShpLCBrZXksIGFyZ3MsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLm5hcmdzKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuYXJncyBmb3JtYXQgPSAnLWY9bW9ua2V5IHdhc2hpbmcgY2F0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBlYXROYXJncyhpLCBrZXksIGFyZ3MsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEFyZyhrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyb2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBcmcobGV0dGVyc1tqXSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGxldHRlciBpcyBhbiBhbHBoYWJldGljIGNoYXJhY3RlciBhbmQgbmV4dCB2YWx1ZSBpcyBhIG51bWJlclxuICAgICAgICAgICAgICAgICAgICBpZiAoL1tBLVphLXpdLy50ZXN0KGxldHRlcnNbal0pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAvXi0/XFxkKyhcXC5cXGQqKT8oZS0/XFxkKyk/JC8udGVzdChuZXh0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tBbGxBbGlhc2VzKG5leHQsIGZsYWdzLmJvb2xzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEFyZyhsZXR0ZXJzW2pdLCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyb2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobGV0dGVyc1tqICsgMV0gJiYgbGV0dGVyc1tqICsgMV0ubWF0Y2goL1xcVy8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBcmcobGV0dGVyc1tqXSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicm9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBcmcobGV0dGVyc1tqXSwgZGVmYXVsdFZhbHVlKGxldHRlcnNbal0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrZXkgPSBhcmcuc2xpY2UoLTEpWzBdO1xuICAgICAgICAgICAgICAgIGlmICghYnJva2VuICYmIGtleSAhPT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5hcnJheXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcnJheSBmb3JtYXQgPSAnLWYgYSBiIGMnXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gZWF0QXJyYXkoaSwga2V5LCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5uYXJncykgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuYXJncyBmb3JtYXQgPSAnLWYgYSBiIGMnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgdHJ1dGh5IGV2ZW4gaWY6IGZsYWdzLm5hcmdzW2tleV0gPT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBlYXROYXJncyhpLCBrZXksIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGFyZ3NbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCAmJiAoIS9eKC18LS0pW14tXS8udGVzdChuZXh0KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQubWF0Y2gobmVnYXRpdmUpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5ib29scykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuY291bnRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEFyZyhrZXksIG5leHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9eKHRydWV8ZmFsc2UpJC8udGVzdChuZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEFyZyhrZXksIG5leHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEFyZyhrZXksIGRlZmF1bHRWYWx1ZShrZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZy5tYXRjaCgvXi1bMC05XSQvKSAmJlxuICAgICAgICAgICAgICAgIGFyZy5tYXRjaChuZWdhdGl2ZSkgJiZcbiAgICAgICAgICAgICAgICBjaGVja0FsbEFsaWFzZXMoYXJnLnNsaWNlKDEpLCBmbGFncy5ib29scykpIHtcbiAgICAgICAgICAgICAgICAvLyBzaW5nbGUtZGlnaXQgYm9vbGVhbiBhbGlhcywgZS5nOiB4YXJncyAtMFxuICAgICAgICAgICAgICAgIGtleSA9IGFyZy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBkZWZhdWx0VmFsdWUoa2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcmcgPT09ICctLScpIHtcbiAgICAgICAgICAgICAgICBub3RGbGFncyA9IGFyZ3Muc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlndXJhdGlvblsnaGFsdC1hdC1ub24tb3B0aW9uJ10pIHtcbiAgICAgICAgICAgICAgICBub3RGbGFncyA9IGFyZ3Muc2xpY2UoaSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwdXNoUG9zaXRpb25hbChhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG9yZGVyIG9mIHByZWNlZGVuY2U6XG4gICAgICAgIC8vIDEuIGNvbW1hbmQgbGluZSBhcmdcbiAgICAgICAgLy8gMi4gdmFsdWUgZnJvbSBlbnYgdmFyXG4gICAgICAgIC8vIDMuIHZhbHVlIGZyb20gY29uZmlnIGZpbGVcbiAgICAgICAgLy8gNC4gdmFsdWUgZnJvbSBjb25maWcgb2JqZWN0c1xuICAgICAgICAvLyA1LiBjb25maWd1cmVkIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgYXBwbHlFbnZWYXJzKGFyZ3YsIHRydWUpOyAvLyBzcGVjaWFsIGNhc2U6IGNoZWNrIGVudiB2YXJzIHRoYXQgcG9pbnQgdG8gY29uZmlnIGZpbGVcbiAgICAgICAgYXBwbHlFbnZWYXJzKGFyZ3YsIGZhbHNlKTtcbiAgICAgICAgc2V0Q29uZmlnKGFyZ3YpO1xuICAgICAgICBzZXRDb25maWdPYmplY3RzKCk7XG4gICAgICAgIGFwcGx5RGVmYXVsdHNBbmRBbGlhc2VzKGFyZ3YsIGZsYWdzLmFsaWFzZXMsIGRlZmF1bHRzLCB0cnVlKTtcbiAgICAgICAgYXBwbHlDb2VyY2lvbnMoYXJndik7XG4gICAgICAgIGlmIChjb25maWd1cmF0aW9uWydzZXQtcGxhY2Vob2xkZXIta2V5J10pXG4gICAgICAgICAgICBzZXRQbGFjZWhvbGRlcktleXMoYXJndik7XG4gICAgICAgIC8vIGZvciBhbnkgY291bnRzIGVpdGhlciBub3QgaW4gYXJncyBvciB3aXRob3V0IGFuIGV4cGxpY2l0IGRlZmF1bHQsIHNldCB0byAwXG4gICAgICAgIE9iamVjdC5rZXlzKGZsYWdzLmNvdW50cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoIWhhc0tleShhcmd2LCBrZXkuc3BsaXQoJy4nKSkpXG4gICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgMCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyAnLS0nIGRlZmF1bHRzIHRvIHVuZGVmaW5lZC5cbiAgICAgICAgaWYgKG5vdEZsYWdzT3B0aW9uICYmIG5vdEZsYWdzLmxlbmd0aClcbiAgICAgICAgICAgIGFyZ3Zbbm90RmxhZ3NBcmd2XSA9IFtdO1xuICAgICAgICBub3RGbGFncy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGFyZ3Zbbm90RmxhZ3NBcmd2XS5wdXNoKGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY29uZmlndXJhdGlvblsnY2FtZWwtY2FzZS1leHBhbnNpb24nXSAmJiBjb25maWd1cmF0aW9uWydzdHJpcC1kYXNoZWQnXSkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXJndikuZmlsdGVyKGtleSA9PiBrZXkgIT09ICctLScgJiYga2V5LmluY2x1ZGVzKCctJykpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBkZWxldGUgYXJndltrZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb25bJ3N0cmlwLWFsaWFzZWQnXSkge1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgW10uY29uY2F0KC4uLk9iamVjdC5rZXlzKGFsaWFzZXMpLm1hcChrID0+IGFsaWFzZXNba10pKS5mb3JFYWNoKGFsaWFzID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvblsnY2FtZWwtY2FzZS1leHBhbnNpb24nXSAmJiBhbGlhcy5pbmNsdWRlcygnLScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhcmd2W2FsaWFzLnNwbGl0KCcuJykubWFwKHByb3AgPT4gY2FtZWxDYXNlKHByb3ApKS5qb2luKCcuJyldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgYXJndlthbGlhc107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQdXNoIGFyZ3VtZW50IGludG8gcG9zaXRpb25hbCBhcnJheSwgYXBwbHlpbmcgbnVtZXJpYyBjb2VyY2lvbjpcbiAgICAgICAgZnVuY3Rpb24gcHVzaFBvc2l0aW9uYWwoYXJnKSB7XG4gICAgICAgICAgICBjb25zdCBtYXliZUNvZXJjZWROdW1iZXIgPSBtYXliZUNvZXJjZU51bWJlcignXycsIGFyZyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1heWJlQ29lcmNlZE51bWJlciA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG1heWJlQ29lcmNlZE51bWJlciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBhcmd2Ll8ucHVzaChtYXliZUNvZXJjZWROdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGhvdyBtYW55IGFyZ3VtZW50cyBzaG91bGQgd2UgY29uc3VtZSwgYmFzZWRcbiAgICAgICAgLy8gb24gdGhlIG5hcmdzIG9wdGlvbj9cbiAgICAgICAgZnVuY3Rpb24gZWF0TmFyZ3MoaSwga2V5LCBhcmdzLCBhcmdBZnRlckVxdWFsU2lnbikge1xuICAgICAgICAgICAgbGV0IGlpO1xuICAgICAgICAgICAgbGV0IHRvRWF0ID0gY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MubmFyZ3MpO1xuICAgICAgICAgICAgLy8gTmFOIGhhcyBhIHNwZWNpYWwgbWVhbmluZyBmb3IgdGhlIGFycmF5IHR5cGUsIGluZGljYXRpbmcgdGhhdCBvbmUgb3JcbiAgICAgICAgICAgIC8vIG1vcmUgdmFsdWVzIGFyZSBleHBlY3RlZC5cbiAgICAgICAgICAgIHRvRWF0ID0gdHlwZW9mIHRvRWF0ICE9PSAnbnVtYmVyJyB8fCBpc05hTih0b0VhdCkgPyAxIDogdG9FYXQ7XG4gICAgICAgICAgICBpZiAodG9FYXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGFyZ0FmdGVyRXF1YWxTaWduKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IEVycm9yKF9fKCdBcmd1bWVudCB1bmV4cGVjdGVkIGZvcjogJXMnLCBrZXkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgZGVmYXVsdFZhbHVlKGtleSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGF2YWlsYWJsZSA9IGlzVW5kZWZpbmVkKGFyZ0FmdGVyRXF1YWxTaWduKSA/IDAgOiAxO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb25bJ25hcmdzLWVhdHMtb3B0aW9ucyddKSB7XG4gICAgICAgICAgICAgICAgLy8gY2xhc3NpYyBiZWhhdmlvciwgeWFyZ3MgZWF0cyBwb3NpdGlvbmFsIGFuZCBkYXNoIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggLSAoaSArIDEpICsgYXZhaWxhYmxlIDwgdG9FYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBFcnJvcihfXygnTm90IGVub3VnaCBhcmd1bWVudHMgZm9sbG93aW5nOiAlcycsIGtleSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhdmFpbGFibGUgPSB0b0VhdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5hcmdzIHdpbGwgbm90IGNvbnN1bWUgZmxhZyBhcmd1bWVudHMsIGUuZy4sIC1hYmMsIC0tZm9vLFxuICAgICAgICAgICAgICAgIC8vIGFuZCB0ZXJtaW5hdGVzIHdoZW4gb25lIGlzIG9ic2VydmVkLlxuICAgICAgICAgICAgICAgIGZvciAoaWkgPSBpICsgMTsgaWkgPCBhcmdzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFyZ3NbaWldLm1hdGNoKC9eLVteMC05XS8pIHx8IGFyZ3NbaWldLm1hdGNoKG5lZ2F0aXZlKSB8fCBpc1Vua25vd25PcHRpb25Bc0FyZyhhcmdzW2lpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGUrKztcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhdmFpbGFibGUgPCB0b0VhdClcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBFcnJvcihfXygnTm90IGVub3VnaCBhcmd1bWVudHMgZm9sbG93aW5nOiAlcycsIGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNvbnN1bWVkID0gTWF0aC5taW4oYXZhaWxhYmxlLCB0b0VhdCk7XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGFyZ0FmdGVyRXF1YWxTaWduKSAmJiBjb25zdW1lZCA+IDApIHtcbiAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBhcmdBZnRlckVxdWFsU2lnbik7XG4gICAgICAgICAgICAgICAgY29uc3VtZWQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaWkgPSBpICsgMTsgaWkgPCAoY29uc3VtZWQgKyBpICsgMSk7IGlpKyspIHtcbiAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBhcmdzW2lpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGkgKyBjb25zdW1lZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYW4gb3B0aW9uIGlzIGFuIGFycmF5LCBlYXQgYWxsIG5vbi1oeXBoZW5hdGVkIGFyZ3VtZW50c1xuICAgICAgICAvLyBmb2xsb3dpbmcgaXQuLi4gWVVNIVxuICAgICAgICAvLyBlLmcuLCAtLWZvbyBhcHBsZSBiYW5hbmEgY2F0IGJlY29tZXMgW1wiYXBwbGVcIiwgXCJiYW5hbmFcIiwgXCJjYXRcIl1cbiAgICAgICAgZnVuY3Rpb24gZWF0QXJyYXkoaSwga2V5LCBhcmdzLCBhcmdBZnRlckVxdWFsU2lnbikge1xuICAgICAgICAgICAgbGV0IGFyZ3NUb1NldCA9IFtdO1xuICAgICAgICAgICAgbGV0IG5leHQgPSBhcmdBZnRlckVxdWFsU2lnbiB8fCBhcmdzW2kgKyAxXTtcbiAgICAgICAgICAgIC8vIElmIGJvdGggYXJyYXkgYW5kIG5hcmdzIGFyZSBjb25maWd1cmVkLCBlbmZvcmNlIHRoZSBuYXJncyBjb3VudDpcbiAgICAgICAgICAgIGNvbnN0IG5hcmdzQ291bnQgPSBjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5uYXJncyk7XG4gICAgICAgICAgICBpZiAoY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYm9vbHMpICYmICEoL14odHJ1ZXxmYWxzZSkkLy50ZXN0KG5leHQpKSkge1xuICAgICAgICAgICAgICAgIGFyZ3NUb1NldC5wdXNoKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNVbmRlZmluZWQobmV4dCkgfHxcbiAgICAgICAgICAgICAgICAoaXNVbmRlZmluZWQoYXJnQWZ0ZXJFcXVhbFNpZ24pICYmIC9eLS8udGVzdChuZXh0KSAmJiAhbmVnYXRpdmUudGVzdChuZXh0KSAmJiAhaXNVbmtub3duT3B0aW9uQXNBcmcobmV4dCkpKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGtleXMgd2l0aG91dCB2YWx1ZSA9PT4gYXJnc1RvU2V0IHJlbWFpbnMgYW4gZW1wdHkgW11cbiAgICAgICAgICAgICAgICAvLyBzZXQgdXNlciBkZWZhdWx0IHZhbHVlLCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdHNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZlZhbCA9IGRlZmF1bHRzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NUb1NldCA9IEFycmF5LmlzQXJyYXkoZGVmVmFsKSA/IGRlZlZhbCA6IFtkZWZWYWxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHZhbHVlIGluIC0tb3B0aW9uPXZhbHVlIGlzIGVhdGVuIGFzIGlzXG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChhcmdBZnRlckVxdWFsU2lnbikpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1RvU2V0LnB1c2gocHJvY2Vzc1ZhbHVlKGtleSwgYXJnQWZ0ZXJFcXVhbFNpZ24sIHRydWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaWkgPSBpICsgMTsgaWkgPCBhcmdzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKCFjb25maWd1cmF0aW9uWydncmVlZHktYXJyYXlzJ10gJiYgYXJnc1RvU2V0Lmxlbmd0aCA+IDApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAobmFyZ3NDb3VudCAmJiB0eXBlb2YgbmFyZ3NDb3VudCA9PT0gJ251bWJlcicgJiYgYXJnc1RvU2V0Lmxlbmd0aCA+PSBuYXJnc0NvdW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gYXJnc1tpaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICgvXi0vLnRlc3QobmV4dCkgJiYgIW5lZ2F0aXZlLnRlc3QobmV4dCkgJiYgIWlzVW5rbm93bk9wdGlvbkFzQXJnKG5leHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBpaTtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1RvU2V0LnB1c2gocHJvY2Vzc1ZhbHVlKGtleSwgbmV4dCwgaW5wdXRJc1N0cmluZykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGJvdGggYXJyYXkgYW5kIG5hcmdzIGFyZSBjb25maWd1cmVkLCBjcmVhdGUgYW4gZXJyb3IgaWYgbGVzcyB0aGFuXG4gICAgICAgICAgICAvLyBuYXJncyBwb3NpdGlvbmFscyB3ZXJlIGZvdW5kLiBOYU4gaGFzIHNwZWNpYWwgbWVhbmluZywgaW5kaWNhdGluZ1xuICAgICAgICAgICAgLy8gdGhhdCBhdCBsZWFzdCBvbmUgdmFsdWUgaXMgcmVxdWlyZWQgKG1vcmUgYXJlIG9rYXkpLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYXJnc0NvdW50ID09PSAnbnVtYmVyJyAmJiAoKG5hcmdzQ291bnQgJiYgYXJnc1RvU2V0Lmxlbmd0aCA8IG5hcmdzQ291bnQpIHx8XG4gICAgICAgICAgICAgICAgKGlzTmFOKG5hcmdzQ291bnQpICYmIGFyZ3NUb1NldC5sZW5ndGggPT09IDApKSkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gRXJyb3IoX18oJ05vdCBlbm91Z2ggYXJndW1lbnRzIGZvbGxvd2luZzogJXMnLCBrZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEFyZyhrZXksIGFyZ3NUb1NldCk7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXRBcmcoa2V5LCB2YWwsIHNob3VsZFN0cmlwUXVvdGVzID0gaW5wdXRJc1N0cmluZykge1xuICAgICAgICAgICAgaWYgKC8tLy50ZXN0KGtleSkgJiYgY29uZmlndXJhdGlvblsnY2FtZWwtY2FzZS1leHBhbnNpb24nXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsaWFzID0ga2V5LnNwbGl0KCcuJykubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYW1lbENhc2UocHJvcCk7XG4gICAgICAgICAgICAgICAgfSkuam9pbignLicpO1xuICAgICAgICAgICAgICAgIGFkZE5ld0FsaWFzKGtleSwgYWxpYXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwcm9jZXNzVmFsdWUoa2V5LCB2YWwsIHNob3VsZFN0cmlwUXVvdGVzKTtcbiAgICAgICAgICAgIGNvbnN0IHNwbGl0S2V5ID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBzZXRLZXkoYXJndiwgc3BsaXRLZXksIHZhbHVlKTtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBwb3B1bGF0aW5nIGFsaWFzZXMgb2YgdGhlIGZ1bGwga2V5XG4gICAgICAgICAgICBpZiAoZmxhZ3MuYWxpYXNlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MuYWxpYXNlc1trZXldLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5UHJvcGVydGllcyA9IHguc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0S2V5KGFyZ3YsIGtleVByb3BlcnRpZXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhhbmRsZSBwb3B1bGF0aW5nIGFsaWFzZXMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGRvdC1ub3RhdGlvbiBrZXlcbiAgICAgICAgICAgIGlmIChzcGxpdEtleS5sZW5ndGggPiAxICYmIGNvbmZpZ3VyYXRpb25bJ2RvdC1ub3RhdGlvbiddKSB7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIChmbGFncy5hbGlhc2VzW3NwbGl0S2V5WzBdXSB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQga2V5UHJvcGVydGllcyA9IHguc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhwYW5kIGFsaWFzIHdpdGggbmVzdGVkIG9iamVjdHMgaW4ga2V5XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBbXS5jb25jYXQoc3BsaXRLZXkpO1xuICAgICAgICAgICAgICAgICAgICBhLnNoaWZ0KCk7IC8vIG51a2UgdGhlIG9sZCBrZXkuXG4gICAgICAgICAgICAgICAgICAgIGtleVByb3BlcnRpZXMgPSBrZXlQcm9wZXJ0aWVzLmNvbmNhdChhKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9wdWxhdGUgYWxpYXMgb25seSBpZiBpcyBub3QgYWxyZWFkeSBhbiBhbGlhcyBvZiB0aGUgZnVsbCBrZXlcbiAgICAgICAgICAgICAgICAgICAgLy8gKGFscmVhZHkgcG9wdWxhdGVkIGFib3ZlKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIShmbGFncy5hbGlhc2VzW2tleV0gfHwgW10pLmluY2x1ZGVzKGtleVByb3BlcnRpZXMuam9pbignLicpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0S2V5KGFyZ3YsIGtleVByb3BlcnRpZXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0IG5vcm1hbGl6ZSBnZXR0ZXIgYW5kIHNldHRlciB3aGVuIGtleSBpcyBpbiAnbm9ybWFsaXplJyBidXQgaXNuJ3QgYW4gYXJyYXlcbiAgICAgICAgICAgIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5ub3JtYWxpemUpICYmICFjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5hcnJheXMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IFtrZXldLmNvbmNhdChmbGFncy5hbGlhc2VzW2tleV0gfHwgW10pO1xuICAgICAgICAgICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcmd2UmV0dXJuLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gbWl4aW4ubm9ybWFsaXplKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGROZXdBbGlhcyhrZXksIGFsaWFzKSB7XG4gICAgICAgICAgICBpZiAoIShmbGFncy5hbGlhc2VzW2tleV0gJiYgZmxhZ3MuYWxpYXNlc1trZXldLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBmbGFncy5hbGlhc2VzW2tleV0gPSBbYWxpYXNdO1xuICAgICAgICAgICAgICAgIG5ld0FsaWFzZXNbYWxpYXNdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKGZsYWdzLmFsaWFzZXNbYWxpYXNdICYmIGZsYWdzLmFsaWFzZXNbYWxpYXNdLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBhZGROZXdBbGlhcyhhbGlhcywga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzVmFsdWUoa2V5LCB2YWwsIHNob3VsZFN0cmlwUXVvdGVzKSB7XG4gICAgICAgICAgICAvLyBzdHJpbmdzIG1heSBiZSBxdW90ZWQsIGNsZWFuIHRoaXMgdXAgYXMgd2UgYXNzaWduIHZhbHVlcy5cbiAgICAgICAgICAgIGlmIChzaG91bGRTdHJpcFF1b3Rlcykge1xuICAgICAgICAgICAgICAgIHZhbCA9IHN0cmlwUXVvdGVzKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYW5kbGUgcGFyc2luZyBib29sZWFuIGFyZ3VtZW50cyAtLWZvbz10cnVlIC0tYmFyIGZhbHNlLlxuICAgICAgICAgICAgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmJvb2xzKSB8fCBjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5jb3VudHMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWwgPT09ICd0cnVlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IEFycmF5LmlzQXJyYXkodmFsKVxuICAgICAgICAgICAgICAgID8gdmFsLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gbWF5YmVDb2VyY2VOdW1iZXIoa2V5LCB2KTsgfSlcbiAgICAgICAgICAgICAgICA6IG1heWJlQ29lcmNlTnVtYmVyKGtleSwgdmFsKTtcbiAgICAgICAgICAgIC8vIGluY3JlbWVudCBhIGNvdW50IGdpdmVuIGFzIGFyZyAoZWl0aGVyIG5vIHZhbHVlIG9yIHZhbHVlIHBhcnNlZCBhcyBib29sZWFuKVxuICAgICAgICAgICAgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmNvdW50cykgJiYgKGlzVW5kZWZpbmVkKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGluY3JlbWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0IG5vcm1hbGl6ZWQgdmFsdWUgd2hlbiBrZXkgaXMgaW4gJ25vcm1hbGl6ZScgYW5kIGluICdhcnJheXMnXG4gICAgICAgICAgICBpZiAoY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3Mubm9ybWFsaXplKSAmJiBjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5hcnJheXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWwubWFwKCh2YWwpID0+IHsgcmV0dXJuIG1peGluLm5vcm1hbGl6ZSh2YWwpOyB9KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWl4aW4ubm9ybWFsaXplKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWF5YmVDb2VyY2VOdW1iZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFjb25maWd1cmF0aW9uWydwYXJzZS1wb3NpdGlvbmFsLW51bWJlcnMnXSAmJiBrZXkgPT09ICdfJylcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBpZiAoIWNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLnN0cmluZ3MpICYmICFjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5ib29scykgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkQ29lcmNlTnVtYmVyID0gbG9va3NMaWtlTnVtYmVyKHZhbHVlKSAmJiBjb25maWd1cmF0aW9uWydwYXJzZS1udW1iZXJzJ10gJiYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKE1hdGguZmxvb3IocGFyc2VGbG9hdChgJHt2YWx1ZX1gKSkpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQ29lcmNlTnVtYmVyIHx8ICghaXNVbmRlZmluZWQodmFsdWUpICYmIGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLm51bWJlcnMpKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBhcmdzIGZyb20gY29uZmlnLmpzb24gZmlsZSwgdGhpcyBzaG91bGQgYmVcbiAgICAgICAgLy8gYXBwbGllZCBsYXN0IHNvIHRoYXQgZGVmYXVsdHMgY2FuIGJlIGFwcGxpZWQuXG4gICAgICAgIGZ1bmN0aW9uIHNldENvbmZpZyhhcmd2KSB7XG4gICAgICAgICAgICBjb25zdCBjb25maWdMb29rdXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgLy8gZXhwYW5kIGRlZmF1bHRzL2FsaWFzZXMsIGluLWNhc2UgYW55IGhhcHBlbiB0byByZWZlcmVuY2VcbiAgICAgICAgICAgIC8vIHRoZSBjb25maWcuanNvbiBmaWxlLlxuICAgICAgICAgICAgYXBwbHlEZWZhdWx0c0FuZEFsaWFzZXMoY29uZmlnTG9va3VwLCBmbGFncy5hbGlhc2VzLCBkZWZhdWx0cyk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhmbGFncy5jb25maWdzKS5mb3JFYWNoKGZ1bmN0aW9uIChjb25maWdLZXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25maWdQYXRoID0gYXJndltjb25maWdLZXldIHx8IGNvbmZpZ0xvb2t1cFtjb25maWdLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWdQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29uZmlnID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkQ29uZmlnUGF0aCA9IG1peGluLnJlc29sdmUobWl4aW4uY3dkKCksIGNvbmZpZ1BhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZUNvbmZpZyA9IGZsYWdzLmNvbmZpZ3NbY29uZmlnS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZUNvbmZpZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IHJlc29sdmVDb25maWcocmVzb2x2ZWRDb25maWdQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZyBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gbWl4aW4ucmVxdWlyZShyZXNvbHZlZENvbmZpZ1BhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q29uZmlnT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZW5vIHdpbGwgcmVjZWl2ZSBhIFBlcm1pc3Npb25EZW5pZWQgZXJyb3IgaWYgYW4gYXR0ZW1wdCBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFkZSB0byBsb2FkIGNvbmZpZyB3aXRob3V0IHRoZSAtLWFsbG93LXJlYWQgZmxhZzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleC5uYW1lID09PSAnUGVybWlzc2lvbkRlbmllZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZ3ZbY29uZmlnS2V5XSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IEVycm9yKF9fKCdJbnZhbGlkIEpTT04gY29uZmlnIGZpbGU6ICVzJywgY29uZmlnUGF0aCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGFyZ3MgZnJvbSBjb25maWcgb2JqZWN0LlxuICAgICAgICAvLyBpdCByZWN1cnNpdmVseSBjaGVja3MgbmVzdGVkIG9iamVjdHMuXG4gICAgICAgIGZ1bmN0aW9uIHNldENvbmZpZ09iamVjdChjb25maWcsIHByZXYpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvbmZpZykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjb25maWdba2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBmdWxsS2V5ID0gcHJldiA/IHByZXYgKyAnLicgKyBrZXkgOiBrZXk7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHZhbHVlIGlzIGFuIGlubmVyIG9iamVjdCBhbmQgd2UgaGF2ZSBkb3Qtbm90YXRpb25cbiAgICAgICAgICAgICAgICAvLyBlbmFibGVkLCB0cmVhdCBpbm5lciBvYmplY3RzIGluIGNvbmZpZyB0aGUgc2FtZSBhc1xuICAgICAgICAgICAgICAgIC8vIGhlYXZpbHkgbmVzdGVkIGRvdCBub3RhdGlvbnMgKGZvby5iYXIuYXBwbGUpLlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiBjb25maWd1cmF0aW9uWydkb3Qtbm90YXRpb24nXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IGJ1dCBub3QgYW4gYXJyYXksIGNoZWNrIG5lc3RlZCBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgc2V0Q29uZmlnT2JqZWN0KHZhbHVlLCBmdWxsS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgYXJndW1lbnRzIHZpYSBDTEkgdGFrZXMgcHJlY2VkZW5jZSBvdmVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlcyB3aXRoaW4gdGhlIGNvbmZpZyBmaWxlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc0tleShhcmd2LCBmdWxsS2V5LnNwbGl0KCcuJykpIHx8IChjaGVja0FsbEFsaWFzZXMoZnVsbEtleSwgZmxhZ3MuYXJyYXlzKSAmJiBjb25maWd1cmF0aW9uWydjb21iaW5lLWFycmF5cyddKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXJnKGZ1bGxLZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBhbGwgY29uZmlnIG9iamVjdHMgcGFzc2VkIGluIG9wdHNcbiAgICAgICAgZnVuY3Rpb24gc2V0Q29uZmlnT2JqZWN0cygpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uZmlnT2JqZWN0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25maWdPYmplY3RzLmZvckVhY2goZnVuY3Rpb24gKGNvbmZpZ09iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRDb25maWdPYmplY3QoY29uZmlnT2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcHBseUVudlZhcnMoYXJndiwgY29uZmlnT25seSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnZQcmVmaXggPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IHR5cGVvZiBlbnZQcmVmaXggPT09ICdzdHJpbmcnID8gZW52UHJlZml4IDogJyc7XG4gICAgICAgICAgICBjb25zdCBlbnYgPSBtaXhpbi5lbnYoKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChmdW5jdGlvbiAoZW52VmFyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZWZpeCA9PT0gJycgfHwgZW52VmFyLmxhc3RJbmRleE9mKHByZWZpeCwgMCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGFycmF5IG9mIG5lc3RlZCBrZXlzIGFuZCBjb252ZXJ0IHRoZW0gdG8gY2FtZWwgY2FzZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gZW52VmFyLnNwbGl0KCdfXycpLm1hcChmdW5jdGlvbiAoa2V5LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGtleS5zdWJzdHJpbmcocHJlZml4Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FtZWxDYXNlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKChjb25maWdPbmx5ICYmIGZsYWdzLmNvbmZpZ3Nba2V5cy5qb2luKCcuJyldKSB8fCAhY29uZmlnT25seSkgJiYgIWhhc0tleShhcmd2LCBrZXlzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXJnKGtleXMuam9pbignLicpLCBlbnZbZW52VmFyXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcHBseUNvZXJjaW9ucyhhcmd2KSB7XG4gICAgICAgICAgICBsZXQgY29lcmNlO1xuICAgICAgICAgICAgY29uc3QgYXBwbGllZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGFyZ3YpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGlmICghYXBwbGllZC5oYXMoa2V5KSkgeyAvLyBJZiB3ZSBoYXZlbid0IGFscmVhZHkgY29lcmNlZCB0aGlzIG9wdGlvbiB2aWEgb25lIG9mIGl0cyBhbGlhc2VzXG4gICAgICAgICAgICAgICAgICAgIGNvZXJjZSA9IGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmNvZXJjaW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29lcmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbWF5YmVDb2VyY2VOdW1iZXIoa2V5LCBjb2VyY2UoYXJndltrZXldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFtdLmNvbmNhdChmbGFncy5hbGlhc2VzW2tleV0gfHwgW10sIGtleSkpLmZvckVhY2goYWxpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGllZC5hZGQoYWxpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndlthbGldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXRQbGFjZWhvbGRlcktleXMoYXJndikge1xuICAgICAgICAgICAgZmxhZ3Mua2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBzZXQgcGxhY2Vob2xkZXIga2V5cyBmb3IgZG90IG5vdGF0aW9uIG9wdGlvbnMgJ2Zvby5iYXInLlxuICAgICAgICAgICAgICAgIGlmICh+a2V5LmluZGV4T2YoJy4nKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndltrZXldID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICAgICAgYXJndltrZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYXJndjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcHBseURlZmF1bHRzQW5kQWxpYXNlcyhvYmosIGFsaWFzZXMsIGRlZmF1bHRzLCBjYW5Mb2cgPSBmYWxzZSkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGVmYXVsdHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGlmICghaGFzS2V5KG9iaiwga2V5LnNwbGl0KCcuJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEtleShvYmosIGtleS5zcGxpdCgnLicpLCBkZWZhdWx0c1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbkxvZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRlZFtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgKGFsaWFzZXNba2V5XSB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0tleShvYmosIHguc3BsaXQoJy4nKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0S2V5KG9iaiwgeC5zcGxpdCgnLicpLCBkZWZhdWx0c1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFzS2V5KG9iaiwga2V5cykge1xuICAgICAgICAgICAgbGV0IG8gPSBvYmo7XG4gICAgICAgICAgICBpZiAoIWNvbmZpZ3VyYXRpb25bJ2RvdC1ub3RhdGlvbiddKVxuICAgICAgICAgICAgICAgIGtleXMgPSBba2V5cy5qb2luKCcuJyldO1xuICAgICAgICAgICAga2V5cy5zbGljZSgwLCAtMSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgbyA9IChvW2tleV0gfHwge30pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2tleXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIG8gIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5IGluIG87XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0S2V5KG9iaiwga2V5cywgdmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBvID0gb2JqO1xuICAgICAgICAgICAgaWYgKCFjb25maWd1cmF0aW9uWydkb3Qtbm90YXRpb24nXSlcbiAgICAgICAgICAgICAgICBrZXlzID0gW2tleXMuam9pbignLicpXTtcbiAgICAgICAgICAgIGtleXMuc2xpY2UoMCwgLTEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8oYmNvZSk6IGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgeWFyZ3MsIHN3aXRjaCB0b1xuICAgICAgICAgICAgICAgIC8vIE9iamVjdC5jcmVhdGUobnVsbCkgZm9yIGRvdCBub3RhdGlvbjpcbiAgICAgICAgICAgICAgICBrZXkgPSBzYW5pdGl6ZUtleShrZXkpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgb1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb1trZXldID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb1trZXldICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9ba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIHRoYXQgb1trZXldIGlzIGFuIGFycmF5LCBhbmQgdGhhdCB0aGUgbGFzdCBpdGVtIGlzIGFuIGVtcHR5IG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob1trZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb1trZXldLnB1c2goe30pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb1trZXldID0gW29ba2V5XSwge31dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gdXBkYXRlIHRoZSBlbXB0eSBvYmplY3QgYXQgdGhlIGVuZCBvZiB0aGUgb1trZXldIGFycmF5LCBzbyBzZXQgbyB0byB0aGF0IG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBvID0gb1trZXldW29ba2V5XS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG8gPSBvW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBUT0RPKGJjb2UpOiBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIHlhcmdzLCBzd2l0Y2ggdG9cbiAgICAgICAgICAgIC8vIE9iamVjdC5jcmVhdGUobnVsbCkgZm9yIGRvdCBub3RhdGlvbjpcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHNhbml0aXplS2V5KGtleXNba2V5cy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICBjb25zdCBpc1R5cGVBcnJheSA9IGNoZWNrQWxsQWxpYXNlcyhrZXlzLmpvaW4oJy4nKSwgZmxhZ3MuYXJyYXlzKTtcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsdWVBcnJheSA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICAgICAgICAgICAgbGV0IGR1cGxpY2F0ZSA9IGNvbmZpZ3VyYXRpb25bJ2R1cGxpY2F0ZS1hcmd1bWVudHMtYXJyYXknXTtcbiAgICAgICAgICAgIC8vIG5hcmdzIGhhcyBoaWdoZXIgcHJpb3JpdHkgdGhhbiBkdXBsaWNhdGVcbiAgICAgICAgICAgIGlmICghZHVwbGljYXRlICYmIGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLm5hcmdzKSkge1xuICAgICAgICAgICAgICAgIGR1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCghaXNVbmRlZmluZWQob1trZXldKSAmJiBmbGFncy5uYXJnc1trZXldID09PSAxKSB8fCAoQXJyYXkuaXNBcnJheShvW2tleV0pICYmIG9ba2V5XS5sZW5ndGggPT09IGZsYWdzLm5hcmdzW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IGluY3JlbWVudCgpKSB7XG4gICAgICAgICAgICAgICAgb1trZXldID0gaW5jcmVtZW50KG9ba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9ba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZHVwbGljYXRlICYmIGlzVHlwZUFycmF5ICYmIGlzVmFsdWVBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBvW2tleV0gPSBjb25maWd1cmF0aW9uWydmbGF0dGVuLWR1cGxpY2F0ZS1hcnJheXMnXSA/IG9ba2V5XS5jb25jYXQodmFsdWUpIDogKEFycmF5LmlzQXJyYXkob1trZXldWzBdKSA/IG9ba2V5XSA6IFtvW2tleV1dKS5jb25jYXQoW3ZhbHVlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFkdXBsaWNhdGUgJiYgQm9vbGVhbihpc1R5cGVBcnJheSkgPT09IEJvb2xlYW4oaXNWYWx1ZUFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICBvW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9ba2V5XSA9IG9ba2V5XS5jb25jYXQoW3ZhbHVlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob1trZXldID09PSB1bmRlZmluZWQgJiYgaXNUeXBlQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBvW2tleV0gPSBpc1ZhbHVlQXJyYXkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkdXBsaWNhdGUgJiYgIShvW2tleV0gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgIGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmNvdW50cykgfHxcbiAgICAgICAgICAgICAgICBjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5ib29scykpKSB7XG4gICAgICAgICAgICAgICAgb1trZXldID0gW29ba2V5XSwgdmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXh0ZW5kIHRoZSBhbGlhc2VzIGxpc3Qgd2l0aCBpbmZlcnJlZCBhbGlhc2VzLlxuICAgICAgICBmdW5jdGlvbiBleHRlbmRBbGlhc2VzKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMob2JqIHx8IHt9KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2hvcnQtY2lyY3VpdCBpZiB3ZSd2ZSBhbHJlYWR5IGFkZGVkIGEga2V5XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBhbGlhc2VzIGFycmF5LCBmb3IgZXhhbXBsZSBpdCBtaWdodFxuICAgICAgICAgICAgICAgICAgICAvLyBleGlzdCBpbiBib3RoICdvcHRzLmRlZmF1bHQnIGFuZCAnb3B0cy5rZXknLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MuYWxpYXNlc1trZXldKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBmbGFncy5hbGlhc2VzW2tleV0gPSBbXS5jb25jYXQoYWxpYXNlc1trZXldIHx8IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIFwiLS1vcHRpb24tbmFtZVwiLCBhbHNvIHNldCBhcmd2Lm9wdGlvbk5hbWVcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYWxpYXNlc1trZXldLmNvbmNhdChrZXkpLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvLS8udGVzdCh4KSAmJiBjb25maWd1cmF0aW9uWydjYW1lbC1jYXNlLWV4cGFuc2lvbiddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYyA9IGNhbWVsQ2FzZSh4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyAhPT0ga2V5ICYmIGZsYWdzLmFsaWFzZXNba2V5XS5pbmRleE9mKGMpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGFncy5hbGlhc2VzW2tleV0ucHVzaChjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3QWxpYXNlc1tjXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIFwiLS1vcHRpb25OYW1lXCIsIGFsc28gc2V0IGFyZ3ZbJ29wdGlvbi1uYW1lJ11cbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYWxpYXNlc1trZXldLmNvbmNhdChrZXkpLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4Lmxlbmd0aCA+IDEgJiYgL1tBLVpdLy50ZXN0KHgpICYmIGNvbmZpZ3VyYXRpb25bJ2NhbWVsLWNhc2UtZXhwYW5zaW9uJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjID0gZGVjYW1lbGl6ZSh4LCAnLScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjICE9PSBrZXkgJiYgZmxhZ3MuYWxpYXNlc1trZXldLmluZGV4T2YoYykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzLmFsaWFzZXNba2V5XS5wdXNoKGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdBbGlhc2VzW2NdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBmbGFncy5hbGlhc2VzW2tleV0uZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYWxpYXNlc1t4XSA9IFtrZXldLmNvbmNhdChmbGFncy5hbGlhc2VzW2tleV0uZmlsdGVyKGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHggIT09IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZykge1xuICAgICAgICAgICAgY29uc3QgdG9DaGVjayA9IFtdLmNvbmNhdChmbGFncy5hbGlhc2VzW2tleV0gfHwgW10sIGtleSk7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmxhZyk7XG4gICAgICAgICAgICBjb25zdCBzZXRBbGlhcyA9IHRvQ2hlY2suZmluZChrZXkgPT4ga2V5cy5pbmNsdWRlcyhrZXkpKTtcbiAgICAgICAgICAgIHJldHVybiBzZXRBbGlhcyA/IGZsYWdbc2V0QWxpYXNdIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFzQW55RmxhZyhrZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZsYWdzS2V5cyA9IE9iamVjdC5rZXlzKGZsYWdzKTtcbiAgICAgICAgICAgIGNvbnN0IHRvQ2hlY2sgPSBbXS5jb25jYXQoZmxhZ3NLZXlzLm1hcChrID0+IGZsYWdzW2tdKSk7XG4gICAgICAgICAgICByZXR1cm4gdG9DaGVjay5zb21lKGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZmxhZykgPyBmbGFnLmluY2x1ZGVzKGtleSkgOiBmbGFnW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYXNGbGFnc01hdGNoaW5nKGFyZywgLi4ucGF0dGVybnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvQ2hlY2sgPSBbXS5jb25jYXQoLi4ucGF0dGVybnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQ2hlY2suc29tZShmdW5jdGlvbiAocGF0dGVybikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gYXJnLm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaCAmJiBoYXNBbnlGbGFnKG1hdGNoWzFdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJhc2VkIG9uIGEgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIHRoZSBzaG9ydCBmbGFnIGdyb3VwIHBhcnNpbmcgbG9naWNcbiAgICAgICAgZnVuY3Rpb24gaGFzQWxsU2hvcnRGbGFncyhhcmcpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBuZWdhdGl2ZSBudW1iZXIsIG9yIGRvZXNuJ3Qgc3RhcnQgd2l0aCBhIHNpbmdsZSBoeXBoZW4sIGl0J3Mgbm90IGEgc2hvcnQgZmxhZyBncm91cFxuICAgICAgICAgICAgaWYgKGFyZy5tYXRjaChuZWdhdGl2ZSkgfHwgIWFyZy5tYXRjaCgvXi1bXi1dKy8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGhhc0FsbEZsYWdzID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBuZXh0O1xuICAgICAgICAgICAgY29uc3QgbGV0dGVycyA9IGFyZy5zbGljZSgxKS5zcGxpdCgnJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxldHRlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gYXJnLnNsaWNlKGogKyAyKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0FueUZsYWcobGV0dGVyc1tqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzQWxsRmxhZ3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgobGV0dGVyc1tqICsgMV0gJiYgbGV0dGVyc1tqICsgMV0gPT09ICc9JykgfHxcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9PT0gJy0nIHx8XG4gICAgICAgICAgICAgICAgICAgICgvW0EtWmEtel0vLnRlc3QobGV0dGVyc1tqXSkgJiYgL14tP1xcZCsoXFwuXFxkKik/KGUtP1xcZCspPyQvLnRlc3QobmV4dCkpIHx8XG4gICAgICAgICAgICAgICAgICAgIChsZXR0ZXJzW2ogKyAxXSAmJiBsZXR0ZXJzW2ogKyAxXS5tYXRjaCgvXFxXLykpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoYXNBbGxGbGFncztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc1Vua25vd25PcHRpb25Bc0FyZyhhcmcpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWd1cmF0aW9uWyd1bmtub3duLW9wdGlvbnMtYXMtYXJncyddICYmIGlzVW5rbm93bk9wdGlvbihhcmcpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzVW5rbm93bk9wdGlvbihhcmcpIHtcbiAgICAgICAgICAgIGFyZyA9IGFyZy5yZXBsYWNlKC9eLXszLH0vLCAnLS0nKTtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBuZWdhdGl2ZSBudW1iZXJzXG4gICAgICAgICAgICBpZiAoYXJnLm1hdGNoKG5lZ2F0aXZlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBzaG9ydCBvcHRpb24gZ3JvdXAgYW5kIGFsbCBvZiB0aGVtIGFyZSBjb25maWd1cmVkLCBpdCBpc24ndCB1bmtub3duXG4gICAgICAgICAgICBpZiAoaGFzQWxsU2hvcnRGbGFncyhhcmcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZS5nLiAnLS1jb3VudD0yJ1xuICAgICAgICAgICAgY29uc3QgZmxhZ1dpdGhFcXVhbHMgPSAvXi0rKFtePV0rPyk9W1xcc1xcU10qJC87XG4gICAgICAgICAgICAvLyBlLmcuICctYScgb3IgJy0tYXJnJ1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsRmxhZyA9IC9eLSsoW149XSs/KSQvO1xuICAgICAgICAgICAgLy8gZS5nLiAnLWEtJ1xuICAgICAgICAgICAgY29uc3QgZmxhZ0VuZGluZ0luSHlwaGVuID0gL14tKyhbXj1dKz8pLSQvO1xuICAgICAgICAgICAgLy8gZS5nLiAnLWFiYzEyMydcbiAgICAgICAgICAgIGNvbnN0IGZsYWdFbmRpbmdJbkRpZ2l0cyA9IC9eLSsoW149XSs/XFxkKykkLztcbiAgICAgICAgICAgIC8vIGUuZy4gJy1hL3Vzci9sb2NhbCdcbiAgICAgICAgICAgIGNvbnN0IGZsYWdFbmRpbmdJbk5vbldvcmRDaGFyYWN0ZXJzID0gL14tKyhbXj1dKz8pXFxXKy4qJC87XG4gICAgICAgICAgICAvLyBjaGVjayB0aGUgZGlmZmVyZW50IHR5cGVzIG9mIGZsYWcgc3R5bGVzLCBpbmNsdWRpbmcgbmVnYXRlZEJvb2xlYW4sIGEgcGF0dGVybiBkZWZpbmVkIG5lYXIgdGhlIHN0YXJ0IG9mIHRoZSBwYXJzZSBtZXRob2RcbiAgICAgICAgICAgIHJldHVybiAhaGFzRmxhZ3NNYXRjaGluZyhhcmcsIGZsYWdXaXRoRXF1YWxzLCBuZWdhdGVkQm9vbGVhbiwgbm9ybWFsRmxhZywgZmxhZ0VuZGluZ0luSHlwaGVuLCBmbGFnRW5kaW5nSW5EaWdpdHMsIGZsYWdFbmRpbmdJbk5vbldvcmRDaGFyYWN0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtYWtlIGEgYmVzdCBlZmZvcnQgdG8gcGljayBhIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgLy8gZm9yIGFuIG9wdGlvbiBiYXNlZCBvbiBuYW1lIGFuZCB0eXBlLlxuICAgICAgICBmdW5jdGlvbiBkZWZhdWx0VmFsdWUoa2V5KSB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmJvb2xzKSAmJlxuICAgICAgICAgICAgICAgICFjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5jb3VudHMpICYmXG4gICAgICAgICAgICAgICAgYCR7a2V5fWAgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdHNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0Rm9yVHlwZShndWVzc1R5cGUoa2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIGEgZGVmYXVsdCB2YWx1ZSwgZ2l2ZW4gdGhlIHR5cGUgb2YgYSBmbGFnLixcbiAgICAgICAgZnVuY3Rpb24gZGVmYXVsdEZvclR5cGUodHlwZSkge1xuICAgICAgICAgICAgY29uc3QgZGVmID0ge1xuICAgICAgICAgICAgICAgIFtEZWZhdWx0VmFsdWVzRm9yVHlwZUtleS5CT09MRUFOXTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBbRGVmYXVsdFZhbHVlc0ZvclR5cGVLZXkuU1RSSU5HXTogJycsXG4gICAgICAgICAgICAgICAgW0RlZmF1bHRWYWx1ZXNGb3JUeXBlS2V5Lk5VTUJFUl06IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBbRGVmYXVsdFZhbHVlc0ZvclR5cGVLZXkuQVJSQVldOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBkZWZbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2l2ZW4gYSBmbGFnLCBlbmZvcmNlIGEgZGVmYXVsdCB0eXBlLlxuICAgICAgICBmdW5jdGlvbiBndWVzc1R5cGUoa2V5KSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IERlZmF1bHRWYWx1ZXNGb3JUeXBlS2V5LkJPT0xFQU47XG4gICAgICAgICAgICBpZiAoY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3Muc3RyaW5ncykpXG4gICAgICAgICAgICAgICAgdHlwZSA9IERlZmF1bHRWYWx1ZXNGb3JUeXBlS2V5LlNUUklORztcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLm51bWJlcnMpKVxuICAgICAgICAgICAgICAgIHR5cGUgPSBEZWZhdWx0VmFsdWVzRm9yVHlwZUtleS5OVU1CRVI7XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5ib29scykpXG4gICAgICAgICAgICAgICAgdHlwZSA9IERlZmF1bHRWYWx1ZXNGb3JUeXBlS2V5LkJPT0xFQU47XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5hcnJheXMpKVxuICAgICAgICAgICAgICAgIHR5cGUgPSBEZWZhdWx0VmFsdWVzRm9yVHlwZUtleS5BUlJBWTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKG51bSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIHVzZXIgY29uZmlndXJhdGlvbiBzZXR0aW5ncyBmb3IgaW5jb25zaXN0ZW5jaWVzXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrQ29uZmlndXJhdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGNvdW50IGtleXMgc2hvdWxkIG5vdCBiZSBzZXQgYXMgYXJyYXkvbmFyZ1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZmxhZ3MuY291bnRzKS5maW5kKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmFycmF5cykpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBFcnJvcihfXygnSW52YWxpZCBjb25maWd1cmF0aW9uOiAlcywgb3B0cy5jb3VudCBleGNsdWRlcyBvcHRzLmFycmF5LicsIGtleSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MubmFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gRXJyb3IoX18oJ0ludmFsaWQgY29uZmlndXJhdGlvbjogJXMsIG9wdHMuY291bnQgZXhjbHVkZXMgb3B0cy5uYXJnLicsIGtleSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFsaWFzZXM6IE9iamVjdC5hc3NpZ24oe30sIGZsYWdzLmFsaWFzZXMpLFxuICAgICAgICAgICAgYXJndjogT2JqZWN0LmFzc2lnbihhcmd2UmV0dXJuLCBhcmd2KSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb246IGNvbmZpZ3VyYXRpb24sXG4gICAgICAgICAgICBkZWZhdWx0ZWQ6IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRlZCksXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICBuZXdBbGlhc2VzOiBPYmplY3QuYXNzaWduKHt9LCBuZXdBbGlhc2VzKVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8vIGlmIGFueSBhbGlhc2VzIHJlZmVyZW5jZSBlYWNoIG90aGVyLCB3ZSBzaG91bGRcbi8vIG1lcmdlIHRoZW0gdG9nZXRoZXIuXG5mdW5jdGlvbiBjb21iaW5lQWxpYXNlcyhhbGlhc2VzKSB7XG4gICAgY29uc3QgYWxpYXNBcnJheXMgPSBbXTtcbiAgICBjb25zdCBjb21iaW5lZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNoYW5nZSA9IHRydWU7XG4gICAgLy8gdHVybiBhbGlhcyBsb29rdXAgaGFzaCB7a2V5OiBbJ2FsaWFzMScsICdhbGlhczInXX0gaW50b1xuICAgIC8vIGEgc2ltcGxlIGFycmF5IFsna2V5JywgJ2FsaWFzMScsICdhbGlhczInXVxuICAgIE9iamVjdC5rZXlzKGFsaWFzZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBhbGlhc0FycmF5cy5wdXNoKFtdLmNvbmNhdChhbGlhc2VzW2tleV0sIGtleSkpO1xuICAgIH0pO1xuICAgIC8vIGNvbWJpbmUgYXJyYXlzIHVudGlsIHplcm8gY2hhbmdlcyBhcmVcbiAgICAvLyBtYWRlIGluIGFuIGl0ZXJhdGlvbi5cbiAgICB3aGlsZSAoY2hhbmdlKSB7XG4gICAgICAgIGNoYW5nZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsaWFzQXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpaSA9IGkgKyAxOyBpaSA8IGFsaWFzQXJyYXlzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdCA9IGFsaWFzQXJyYXlzW2ldLmZpbHRlcihmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxpYXNBcnJheXNbaWldLmluZGV4T2YodikgIT09IC0xO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsaWFzQXJyYXlzW2ldID0gYWxpYXNBcnJheXNbaV0uY29uY2F0KGFsaWFzQXJyYXlzW2lpXSk7XG4gICAgICAgICAgICAgICAgICAgIGFsaWFzQXJyYXlzLnNwbGljZShpaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBtYXAgYXJyYXlzIGJhY2sgdG8gdGhlIGhhc2gtbG9va3VwIChkZS1kdXBlIHdoaWxlXG4gICAgLy8gd2UncmUgYXQgaXQpLlxuICAgIGFsaWFzQXJyYXlzLmZvckVhY2goZnVuY3Rpb24gKGFsaWFzQXJyYXkpIHtcbiAgICAgICAgYWxpYXNBcnJheSA9IGFsaWFzQXJyYXkuZmlsdGVyKGZ1bmN0aW9uICh2LCBpLCBzZWxmKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5pbmRleE9mKHYpID09PSBpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbGFzdEFsaWFzID0gYWxpYXNBcnJheS5wb3AoKTtcbiAgICAgICAgaWYgKGxhc3RBbGlhcyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBsYXN0QWxpYXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb21iaW5lZFtsYXN0QWxpYXNdID0gYWxpYXNBcnJheTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb21iaW5lZDtcbn1cbi8vIHRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW4gYSBjb3VudCBpcyBnaXZlbiBhcyBhbiBhcmdcbi8vIGl0IGlzIE5PVCBjYWxsZWQgdG8gc2V0IGEgZGVmYXVsdCB2YWx1ZVxuLy8gdGh1cyB3ZSBjYW4gc3RhcnQgdGhlIGNvdW50IGF0IDEgaW5zdGVhZCBvZiAwXG5mdW5jdGlvbiBpbmNyZW1lbnQob3JpZykge1xuICAgIHJldHVybiBvcmlnICE9PSB1bmRlZmluZWQgPyBvcmlnICsgMSA6IDE7XG59XG4vLyBUT0RPKGJjb2UpOiBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIHlhcmdzLCBzd2l0Y2ggdG9cbi8vIE9iamVjdC5jcmVhdGUobnVsbCkgZm9yIGRvdCBub3RhdGlvbjpcbmZ1bmN0aW9uIHNhbml0aXplS2V5KGtleSkge1xuICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nKVxuICAgICAgICByZXR1cm4gJ19fX3Byb3RvX19fJztcbiAgICByZXR1cm4ga2V5O1xufVxuZnVuY3Rpb24gc3RyaXBRdW90ZXModmFsKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAodmFsWzBdID09PSBcIidcIiB8fCB2YWxbMF0gPT09ICdcIicpICYmXG4gICAgICAgIHZhbFt2YWwubGVuZ3RoIC0gMV0gPT09IHZhbFswXSlcbiAgICAgICAgPyB2YWwuc3Vic3RyaW5nKDEsIHZhbC5sZW5ndGggLSAxKVxuICAgICAgICA6IHZhbDtcbn1cbiIsImltcG9ydCB7IFlFcnJvciB9IGZyb20gJy4uL3llcnJvci5qcyc7XG5sZXQgcHJldmlvdXNseVZpc2l0ZWRDb25maWdzID0gW107XG5sZXQgc2hpbTtcbmV4cG9ydCBmdW5jdGlvbiBhcHBseUV4dGVuZHMoY29uZmlnLCBjd2QsIG1lcmdlRXh0ZW5kcywgX3NoaW0pIHtcbiAgICBzaGltID0gX3NoaW07XG4gICAgbGV0IGRlZmF1bHRDb25maWcgPSB7fTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2V4dGVuZHMnKSkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5leHRlbmRzICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0Q29uZmlnO1xuICAgICAgICBjb25zdCBpc1BhdGggPSAvXFwuanNvbnxcXC4uKnJjJC8udGVzdChjb25maWcuZXh0ZW5kcyk7XG4gICAgICAgIGxldCBwYXRoVG9EZWZhdWx0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpc1BhdGgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGF0aFRvRGVmYXVsdCA9IHJlcXVpcmUucmVzb2x2ZShjb25maWcuZXh0ZW5kcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2Vycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXRoVG9EZWZhdWx0ID0gZ2V0UGF0aFRvRGVmYXVsdENvbmZpZyhjd2QsIGNvbmZpZy5leHRlbmRzKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja0ZvckNpcmN1bGFyRXh0ZW5kcyhwYXRoVG9EZWZhdWx0KTtcbiAgICAgICAgcHJldmlvdXNseVZpc2l0ZWRDb25maWdzLnB1c2gocGF0aFRvRGVmYXVsdCk7XG4gICAgICAgIGRlZmF1bHRDb25maWcgPSBpc1BhdGhcbiAgICAgICAgICAgID8gSlNPTi5wYXJzZShzaGltLnJlYWRGaWxlU3luYyhwYXRoVG9EZWZhdWx0LCAndXRmOCcpKVxuICAgICAgICAgICAgOiByZXF1aXJlKGNvbmZpZy5leHRlbmRzKTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5leHRlbmRzO1xuICAgICAgICBkZWZhdWx0Q29uZmlnID0gYXBwbHlFeHRlbmRzKGRlZmF1bHRDb25maWcsIHNoaW0ucGF0aC5kaXJuYW1lKHBhdGhUb0RlZmF1bHQpLCBtZXJnZUV4dGVuZHMsIHNoaW0pO1xuICAgIH1cbiAgICBwcmV2aW91c2x5VmlzaXRlZENvbmZpZ3MgPSBbXTtcbiAgICByZXR1cm4gbWVyZ2VFeHRlbmRzXG4gICAgICAgID8gbWVyZ2VEZWVwKGRlZmF1bHRDb25maWcsIGNvbmZpZylcbiAgICAgICAgOiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0Q29uZmlnLCBjb25maWcpO1xufVxuZnVuY3Rpb24gY2hlY2tGb3JDaXJjdWxhckV4dGVuZHMoY2ZnUGF0aCkge1xuICAgIGlmIChwcmV2aW91c2x5VmlzaXRlZENvbmZpZ3MuaW5kZXhPZihjZmdQYXRoKSA+IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBZRXJyb3IoYENpcmN1bGFyIGV4dGVuZGVkIGNvbmZpZ3VyYXRpb25zOiAnJHtjZmdQYXRofScuYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0UGF0aFRvRGVmYXVsdENvbmZpZyhjd2QsIHBhdGhUb0V4dGVuZCkge1xuICAgIHJldHVybiBzaGltLnBhdGgucmVzb2x2ZShjd2QsIHBhdGhUb0V4dGVuZCk7XG59XG5mdW5jdGlvbiBtZXJnZURlZXAoY29uZmlnMSwgY29uZmlnMikge1xuICAgIGNvbnN0IHRhcmdldCA9IHt9O1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG9iaik7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBjb25maWcxKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjb25maWcyKSkge1xuICAgICAgICBpZiAoaXNPYmplY3QoY29uZmlnMltrZXldKSAmJiBpc09iamVjdCh0YXJnZXRba2V5XSkpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gbWVyZ2VEZWVwKGNvbmZpZzFba2V5XSwgY29uZmlnMltrZXldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gY29uZmlnMltrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG4iLCJmdW5jdGlvbiBnZXRQcm9jZXNzQXJndkJpbkluZGV4KCkge1xuICAgIGlmIChpc0J1bmRsZWRFbGVjdHJvbkFwcCgpKVxuICAgICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gMTtcbn1cbmZ1bmN0aW9uIGlzQnVuZGxlZEVsZWN0cm9uQXBwKCkge1xuICAgIHJldHVybiBpc0VsZWN0cm9uQXBwKCkgJiYgIXByb2Nlc3MuZGVmYXVsdEFwcDtcbn1cbmZ1bmN0aW9uIGlzRWxlY3Ryb25BcHAoKSB7XG4gICAgcmV0dXJuICEhcHJvY2Vzcy52ZXJzaW9ucy5lbGVjdHJvbjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoaWRlQmluKGFyZ3YpIHtcbiAgICByZXR1cm4gYXJndi5zbGljZShnZXRQcm9jZXNzQXJndkJpbkluZGV4KCkgKyAxKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9jZXNzQXJndkJpbigpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5hcmd2W2dldFByb2Nlc3NBcmd2QmluSW5kZXgoKV07XG59XG4iLCJleHBvcnQgY2xhc3MgWUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1zZykge1xuICAgICAgICBzdXBlcihtc2cgfHwgJ3lhcmdzIGVycm9yJyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdZRXJyb3InO1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFlFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgbm90U3RyaWN0RXF1YWwsIHN0cmljdEVxdWFsIH0gZnJvbSAnYXNzZXJ0J1xuaW1wb3J0IGNsaXVpIGZyb20gJ2NsaXVpJ1xuaW1wb3J0IGVzY2FsYWRlIGZyb20gJ2VzY2FsYWRlL3N5bmMnXG5pbXBvcnQgeyBpbnNwZWN0IH0gZnJvbSAndXRpbCdcbmltcG9ydCB7IHJlYWRGaWxlU3luYyB9IGZyb20gJ2ZzJ1xuaW1wb3J0IHsgZmlsZVVSTFRvUGF0aCB9IGZyb20gJ3VybCc7XG5pbXBvcnQgUGFyc2VyIGZyb20gJ3lhcmdzLXBhcnNlcidcbmltcG9ydCB7IGJhc2VuYW1lLCBkaXJuYW1lLCBleHRuYW1lLCByZWxhdGl2ZSwgcmVzb2x2ZSB9IGZyb20gJ3BhdGgnXG5pbXBvcnQgeyBnZXRQcm9jZXNzQXJndkJpbiB9IGZyb20gJy4uLy4uL2J1aWxkL2xpYi91dGlscy9wcm9jZXNzLWFyZ3YuanMnXG5pbXBvcnQgeyBZRXJyb3IgfSBmcm9tICcuLi8uLi9idWlsZC9saWIveWVycm9yLmpzJ1xuaW1wb3J0IHkxOG4gZnJvbSAneTE4bidcblxuY29uc3QgUkVRVUlSRV9FUlJPUiA9ICdyZXF1aXJlIGlzIG5vdCBzdXBwb3J0ZWQgYnkgRVNNJ1xuY29uc3QgUkVRVUlSRV9ESVJFQ1RPUllfRVJST1IgPSAnbG9hZGluZyBhIGRpcmVjdG9yeSBvZiBjb21tYW5kcyBpcyBub3Qgc3VwcG9ydGVkIHlldCBmb3IgRVNNJ1xuXG5sZXQgX19kaXJuYW1lO1xudHJ5IHtcbiAgX19kaXJuYW1lID0gZmlsZVVSTFRvUGF0aChpbXBvcnQubWV0YS51cmwpO1xufSBjYXRjaCAoZSkge1xuICBfX2Rpcm5hbWUgPSBwcm9jZXNzLmN3ZCgpO1xufVxuY29uc3QgbWFpbkZpbGVuYW1lID0gX19kaXJuYW1lLnN1YnN0cmluZygwLCBfX2Rpcm5hbWUubGFzdEluZGV4T2YoJ25vZGVfbW9kdWxlcycpKTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBhc3NlcnQ6IHtcbiAgICBub3RTdHJpY3RFcXVhbCxcbiAgICBzdHJpY3RFcXVhbFxuICB9LFxuICBjbGl1aSxcbiAgZmluZFVwOiBlc2NhbGFkZSxcbiAgZ2V0RW52OiAoa2V5KSA9PiB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52W2tleV1cbiAgfSxcbiAgaW5zcGVjdCxcbiAgZ2V0Q2FsbGVyRmlsZTogKCkgPT4ge1xuICAgIHRocm93IG5ldyBZRXJyb3IoUkVRVUlSRV9ESVJFQ1RPUllfRVJST1IpXG4gIH0sXG4gIGdldFByb2Nlc3NBcmd2QmluLFxuICBtYWluRmlsZW5hbWU6IG1haW5GaWxlbmFtZSB8fCBwcm9jZXNzLmN3ZCgpLFxuICBQYXJzZXIsXG4gIHBhdGg6IHtcbiAgICBiYXNlbmFtZSxcbiAgICBkaXJuYW1lLFxuICAgIGV4dG5hbWUsXG4gICAgcmVsYXRpdmUsXG4gICAgcmVzb2x2ZVxuICB9LFxuICBwcm9jZXNzOiB7XG4gICAgYXJndjogKCkgPT4gcHJvY2Vzcy5hcmd2LFxuICAgIGN3ZDogcHJvY2Vzcy5jd2QsXG4gICAgZW1pdFdhcm5pbmc6ICh3YXJuaW5nLCB0eXBlKSA9PiBwcm9jZXNzLmVtaXRXYXJuaW5nKHdhcm5pbmcsIHR5cGUpLFxuICAgIGV4ZWNQYXRoOiAoKSA9PiBwcm9jZXNzLmV4ZWNQYXRoLFxuICAgIGV4aXQ6IHByb2Nlc3MuZXhpdCxcbiAgICBuZXh0VGljazogcHJvY2Vzcy5uZXh0VGljayxcbiAgICBzdGRDb2x1bW5zOiB0eXBlb2YgcHJvY2Vzcy5zdGRvdXQuY29sdW1ucyAhPT0gJ3VuZGVmaW5lZCcgPyBwcm9jZXNzLnN0ZG91dC5jb2x1bW5zIDogbnVsbFxuICB9LFxuICByZWFkRmlsZVN5bmMsXG4gIHJlcXVpcmU6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgWUVycm9yKFJFUVVJUkVfRVJST1IpXG4gIH0sXG4gIHJlcXVpcmVEaXJlY3Rvcnk6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgWUVycm9yKFJFUVVJUkVfRElSRUNUT1JZX0VSUk9SKVxuICB9LFxuICBzdHJpbmdXaWR0aDogKHN0cikgPT4ge1xuICAgIHJldHVybiBbLi4uc3RyXS5sZW5ndGhcbiAgfSxcbiAgeTE4bjogeTE4bih7XG4gICAgZGlyZWN0b3J5OiByZXNvbHZlKF9fZGlybmFtZSwgJy4uLy4uLy4uL2xvY2FsZXMnKSxcbiAgICB1cGRhdGVGaWxlczogZmFsc2VcbiAgfSlcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==